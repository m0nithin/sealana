import {
    A as fl,
    B as pl,
    C as wr,
    D as t_,
    E as _r,
    a as _,
    b as Q,
    d as Tn,
    f as oa,
    i as Hn,
    j as yA,
    k as x,
    l as Hf,
    m as vA,
    n as Q0,
    o as Gf,
    p as wA,
    q as q0,
    r as me,
    s as K0,
    t as Y0,
    u as J0,
    v as hn,
    w as Os,
    x as X0,
    y as e_,
    z as fn
} from "./chunk-LXGWDIWZ.js";
var jM = oa((tY, Lv) => {
    "use strict";
    var V2 = /[\p{Lu}]/u,
        U2 = /[\p{Ll}]/u,
        FM = /^[\p{Lu}](?![\p{Lu}])/gu,
        LM = /([\p{Alpha}\p{N}_]|$)/u,
        VM = /[_.\- ]+/,
        j2 = new RegExp("^" + VM.source),
        kM = new RegExp(VM.source + LM.source, "gu"),
        PM = new RegExp("\\d+" + LM.source, "gu"),
        B2 = (t, e, n) => {
            let r = !1,
                i = !1,
                s = !1;
            for (let o = 0; o < t.length; o++) {
                let a = t[o];
                r && V2.test(a) ? (t = t.slice(0, o) + "-" + t.slice(o), r = !1, s = i, i = !0, o++) : i && s && U2.test(a) ? (t = t.slice(0, o - 1) + "-" + t.slice(o - 1), s = i, i = !1, r = !0) : (r = e(a) === a && n(a) !== a, s = i, i = n(a) === a && e(a) !== a)
            }
            return t
        },
        z2 = (t, e) => (FM.lastIndex = 0, t.replace(FM, n => e(n))),
        $2 = (t, e) => (kM.lastIndex = 0, PM.lastIndex = 0, t.replace(kM, (n, r) => e(r)).replace(PM, n => e(n))),
        UM = (t, e) => {
            if (!(typeof t == "string" || Array.isArray(t))) throw new TypeError("Expected the input to be `string | string[]`");
            if (e = _({
                    pascalCase: !1,
                    preserveConsecutiveUppercase: !1
                }, e), Array.isArray(t) ? t = t.map(s => s.trim()).filter(s => s.length).join("-") : t = t.trim(), t.length === 0) return "";
            let n = e.locale === !1 ? s => s.toLowerCase() : s => s.toLocaleLowerCase(e.locale),
                r = e.locale === !1 ? s => s.toUpperCase() : s => s.toLocaleUpperCase(e.locale);
            return t.length === 1 ? e.pascalCase ? r(t) : n(t) : (t !== n(t) && (t = B2(t, n, r)), t = t.replace(j2, ""), e.preserveConsecutiveUppercase ? t = z2(t, n) : t = n(t), e.pascalCase && (t = r(t.charAt(0)) + t.slice(1)), $2(t, r))
        };
    Lv.exports = UM;
    Lv.exports.default = UM
});
var Wv = oa(U => {
    "use strict";
    var Ee = class {
        constructor(e, n) {
            if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
            this.span = e, this.property = n
        }
        makeDestinationObject() {
            return {}
        }
        decode(e, n) {
            throw new Error("Layout is abstract")
        }
        encode(e, n, r) {
            throw new Error("Layout is abstract")
        }
        getSpan(e, n) {
            if (0 > this.span) throw new RangeError("indeterminate span");
            return this.span
        }
        replicate(e) {
            let n = Object.create(this.constructor.prototype);
            return Object.assign(n, this), n.property = e, n
        }
        fromArray(e) {}
    };
    U.Layout = Ee;

    function $v(t, e) {
        return e.property ? t + "[" + e.property + "]" : t
    }
    U.nameWithProperty = $v;

    function W2(t, e) {
        if (typeof t != "function") throw new TypeError("Class must be constructor");
        if (t.hasOwnProperty("layout_")) throw new Error("Class is already bound to a layout");
        if (!(e && e instanceof Ee)) throw new TypeError("layout must be a Layout");
        if (e.hasOwnProperty("boundConstructor_")) throw new Error("layout is already bound to a constructor");
        t.layout_ = e, e.boundConstructor_ = t, e.makeDestinationObject = () => new t, Object.defineProperty(t.prototype, "encode", {
            value: function(n, r) {
                return e.encode(this, n, r)
            },
            writable: !0
        }), Object.defineProperty(t, "decode", {
            value: function(n, r) {
                return e.decode(n, r)
            },
            writable: !0
        })
    }
    U.bindConstructorLayout = W2;
    var At = class extends Ee {
            isCount() {
                throw new Error("ExternalLayout is abstract")
            }
        },
        bh = class extends At {
            constructor(e, n) {
                if (e === void 0 && (e = 1), !Number.isInteger(e) || 0 >= e) throw new TypeError("elementSpan must be a (positive) integer");
                super(-1, n), this.elementSpan = e
            }
            isCount() {
                return !0
            }
            decode(e, n) {
                n === void 0 && (n = 0);
                let r = e.length - n;
                return Math.floor(r / this.elementSpan)
            }
            encode(e, n, r) {
                return 0
            }
        },
        Cc = class extends At {
            constructor(e, n, r) {
                if (!(e instanceof Ee)) throw new TypeError("layout must be a Layout");
                if (n === void 0) n = 0;
                else if (!Number.isInteger(n)) throw new TypeError("offset must be integer or undefined");
                super(e.span, r || e.property), this.layout = e, this.offset = n
            }
            isCount() {
                return this.layout instanceof Dn || this.layout instanceof zn
            }
            decode(e, n) {
                return n === void 0 && (n = 0), this.layout.decode(e, n + this.offset)
            }
            encode(e, n, r) {
                return r === void 0 && (r = 0), this.layout.encode(e, n, r + this.offset)
            }
        },
        Dn = class extends Ee {
            constructor(e, n) {
                if (super(e, n), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, n) {
                return n === void 0 && (n = 0), e.readUIntLE(n, this.span)
            }
            encode(e, n, r) {
                return r === void 0 && (r = 0), n.writeUIntLE(e, r, this.span), this.span
            }
        },
        zn = class extends Ee {
            constructor(e, n) {
                if (super(e, n), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, n) {
                return n === void 0 && (n = 0), e.readUIntBE(n, this.span)
            }
            encode(e, n, r) {
                return r === void 0 && (r = 0), n.writeUIntBE(e, r, this.span), this.span
            }
        },
        kr = class extends Ee {
            constructor(e, n) {
                if (super(e, n), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, n) {
                return n === void 0 && (n = 0), e.readIntLE(n, this.span)
            }
            encode(e, n, r) {
                return r === void 0 && (r = 0), n.writeIntLE(e, r, this.span), this.span
            }
        },
        vi = class extends Ee {
            constructor(e, n) {
                if (super(e, n), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, n) {
                return n === void 0 && (n = 0), e.readIntBE(n, this.span)
            }
            encode(e, n, r) {
                return r === void 0 && (r = 0), n.writeIntBE(e, r, this.span), this.span
            }
        },
        Vv = Math.pow(2, 32);

    function Fh(t) {
        let e = Math.floor(t / Vv),
            n = t - e * Vv;
        return {
            hi32: e,
            lo32: n
        }
    }

    function kh(t, e) {
        return t * Vv + e
    }
    var Uv = class extends Ee {
            constructor(e) {
                super(8, e)
            }
            decode(e, n) {
                n === void 0 && (n = 0);
                let r = e.readUInt32LE(n),
                    i = e.readUInt32LE(n + 4);
                return kh(i, r)
            }
            encode(e, n, r) {
                r === void 0 && (r = 0);
                let i = Fh(e);
                return n.writeUInt32LE(i.lo32, r), n.writeUInt32LE(i.hi32, r + 4), 8
            }
        },
        jv = class extends Ee {
            constructor(e) {
                super(8, e)
            }
            decode(e, n) {
                n === void 0 && (n = 0);
                let r = e.readUInt32BE(n),
                    i = e.readUInt32BE(n + 4);
                return kh(r, i)
            }
            encode(e, n, r) {
                r === void 0 && (r = 0);
                let i = Fh(e);
                return n.writeUInt32BE(i.hi32, r), n.writeUInt32BE(i.lo32, r + 4), 8
            }
        },
        Bv = class extends Ee {
            constructor(e) {
                super(8, e)
            }
            decode(e, n) {
                n === void 0 && (n = 0);
                let r = e.readUInt32LE(n),
                    i = e.readInt32LE(n + 4);
                return kh(i, r)
            }
            encode(e, n, r) {
                r === void 0 && (r = 0);
                let i = Fh(e);
                return n.writeUInt32LE(i.lo32, r), n.writeInt32LE(i.hi32, r + 4), 8
            }
        },
        zv = class extends Ee {
            constructor(e) {
                super(8, e)
            }
            decode(e, n) {
                n === void 0 && (n = 0);
                let r = e.readInt32BE(n),
                    i = e.readUInt32BE(n + 4);
                return kh(r, i)
            }
            encode(e, n, r) {
                r === void 0 && (r = 0);
                let i = Fh(e);
                return n.writeInt32BE(i.hi32, r), n.writeUInt32BE(i.lo32, r + 4), 8
            }
        },
        Dh = class extends Ee {
            constructor(e) {
                super(4, e)
            }
            decode(e, n) {
                return n === void 0 && (n = 0), e.readFloatLE(n)
            }
            encode(e, n, r) {
                return r === void 0 && (r = 0), n.writeFloatLE(e, r), 4
            }
        },
        Eh = class extends Ee {
            constructor(e) {
                super(4, e)
            }
            decode(e, n) {
                return n === void 0 && (n = 0), e.readFloatBE(n)
            }
            encode(e, n, r) {
                return r === void 0 && (r = 0), n.writeFloatBE(e, r), 4
            }
        },
        Ch = class extends Ee {
            constructor(e) {
                super(8, e)
            }
            decode(e, n) {
                return n === void 0 && (n = 0), e.readDoubleLE(n)
            }
            encode(e, n, r) {
                return r === void 0 && (r = 0), n.writeDoubleLE(e, r), 8
            }
        },
        Sh = class extends Ee {
            constructor(e) {
                super(8, e)
            }
            decode(e, n) {
                return n === void 0 && (n = 0), e.readDoubleBE(n)
            }
            encode(e, n, r) {
                return r === void 0 && (r = 0), n.writeDoubleBE(e, r), 8
            }
        },
        Mh = class extends Ee {
            constructor(e, n, r) {
                if (!(e instanceof Ee)) throw new TypeError("elementLayout must be a Layout");
                if (!(n instanceof At && n.isCount() || Number.isInteger(n) && 0 <= n)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
                let i = -1;
                !(n instanceof At) && 0 < e.span && (i = n * e.span), super(i, r), this.elementLayout = e, this.count = n
            }
            getSpan(e, n) {
                if (0 <= this.span) return this.span;
                n === void 0 && (n = 0);
                let r = 0,
                    i = this.count;
                if (i instanceof At && (i = i.decode(e, n)), 0 < this.elementLayout.span) r = i * this.elementLayout.span;
                else {
                    let s = 0;
                    for (; s < i;) r += this.elementLayout.getSpan(e, n + r), ++s
                }
                return r
            }
            decode(e, n) {
                n === void 0 && (n = 0);
                let r = [],
                    i = 0,
                    s = this.count;
                for (s instanceof At && (s = s.decode(e, n)); i < s;) r.push(this.elementLayout.decode(e, n)), n += this.elementLayout.getSpan(e, n), i += 1;
                return r
            }
            encode(e, n, r) {
                r === void 0 && (r = 0);
                let i = this.elementLayout,
                    s = e.reduce((o, a) => o + i.encode(a, n, r + o), 0);
                return this.count instanceof At && this.count.encode(e.length, n, r), s
            }
        },
        Ih = class extends Ee {
            constructor(e, n, r) {
                if (!(Array.isArray(e) && e.reduce((s, o) => s && o instanceof Ee, !0))) throw new TypeError("fields must be array of Layout instances");
                typeof n == "boolean" && r === void 0 && (r = n, n = void 0);
                for (let s of e)
                    if (0 > s.span && s.property === void 0) throw new Error("fields cannot contain unnamed variable-length layout");
                let i = -1;
                try {
                    i = e.reduce((s, o) => s + o.getSpan(), 0)
                } catch {}
                super(i, n), this.fields = e, this.decodePrefixes = !!r
            }
            getSpan(e, n) {
                if (0 <= this.span) return this.span;
                n === void 0 && (n = 0);
                let r = 0;
                try {
                    r = this.fields.reduce((i, s) => {
                        let o = s.getSpan(e, n);
                        return n += o, i + o
                    }, 0)
                } catch {
                    throw new RangeError("indeterminate span")
                }
                return r
            }
            decode(e, n) {
                n === void 0 && (n = 0);
                let r = this.makeDestinationObject();
                for (let i of this.fields)
                    if (i.property !== void 0 && (r[i.property] = i.decode(e, n)), n += i.getSpan(e, n), this.decodePrefixes && e.length === n) break;
                return r
            }
            encode(e, n, r) {
                r === void 0 && (r = 0);
                let i = r,
                    s = 0,
                    o = 0;
                for (let a of this.fields) {
                    let c = a.span;
                    if (o = 0 < c ? c : 0, a.property !== void 0) {
                        let l = e[a.property];
                        l !== void 0 && (o = a.encode(l, n, r), 0 > c && (c = a.getSpan(n, r)))
                    }
                    s = r, r += c
                }
                return s + o - i
            }
            fromArray(e) {
                let n = this.makeDestinationObject();
                for (let r of this.fields) r.property !== void 0 && 0 < e.length && (n[r.property] = e.shift());
                return n
            }
            layoutFor(e) {
                if (typeof e != "string") throw new TypeError("property must be string");
                for (let n of this.fields)
                    if (n.property === e) return n
            }
            offsetOf(e) {
                if (typeof e != "string") throw new TypeError("property must be string");
                let n = 0;
                for (let r of this.fields) {
                    if (r.property === e) return n;
                    0 > r.span ? n = -1 : 0 <= n && (n += r.span)
                }
            }
        },
        Sc = class {
            constructor(e) {
                this.property = e
            }
            decode() {
                throw new Error("UnionDiscriminator is abstract")
            }
            encode() {
                throw new Error("UnionDiscriminator is abstract")
            }
        },
        zo = class extends Sc {
            constructor(e, n) {
                if (!(e instanceof At && e.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
                super(n || e.property || "variant"), this.layout = e
            }
            decode(e, n) {
                return this.layout.decode(e, n)
            }
            encode(e, n, r) {
                return this.layout.encode(e, n, r)
            }
        },
        Mc = class extends Ee {
            constructor(e, n, r) {
                let i = e instanceof Dn || e instanceof zn;
                if (i) e = new zo(new Cc(e));
                else if (e instanceof At && e.isCount()) e = new zo(e);
                else if (!(e instanceof Sc)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                if (n === void 0 && (n = null), !(n === null || n instanceof Ee)) throw new TypeError("defaultLayout must be null or a Layout");
                if (n !== null) {
                    if (0 > n.span) throw new Error("defaultLayout must have constant span");
                    n.property === void 0 && (n = n.replicate("content"))
                }
                let s = -1;
                n && (s = n.span, 0 <= s && i && (s += e.layout.span)), super(s, r), this.discriminator = e, this.usesPrefixDiscriminator = i, this.defaultLayout = n, this.registry = {};
                let o = this.defaultGetSourceVariant.bind(this);
                this.getSourceVariant = function(a) {
                    return o(a)
                }, this.configGetSourceVariant = function(a) {
                    o = a.bind(this)
                }
            }
            getSpan(e, n) {
                if (0 <= this.span) return this.span;
                n === void 0 && (n = 0);
                let r = this.getVariant(e, n);
                if (!r) throw new Error("unable to determine span for unrecognized variant");
                return r.getSpan(e, n)
            }
            defaultGetSourceVariant(e) {
                if (e.hasOwnProperty(this.discriminator.property)) {
                    if (this.defaultLayout && e.hasOwnProperty(this.defaultLayout.property)) return;
                    let n = this.registry[e[this.discriminator.property]];
                    if (n && (!n.layout || e.hasOwnProperty(n.property))) return n
                } else
                    for (let n in this.registry) {
                        let r = this.registry[n];
                        if (e.hasOwnProperty(r.property)) return r
                    }
                throw new Error("unable to infer src variant")
            }
            decode(e, n) {
                n === void 0 && (n = 0);
                let r, i = this.discriminator,
                    s = i.decode(e, n),
                    o = this.registry[s];
                if (o === void 0) {
                    let a = 0;
                    o = this.defaultLayout, this.usesPrefixDiscriminator && (a = i.layout.span), r = this.makeDestinationObject(), r[i.property] = s, r[o.property] = this.defaultLayout.decode(e, n + a)
                } else r = o.decode(e, n);
                return r
            }
            encode(e, n, r) {
                r === void 0 && (r = 0);
                let i = this.getSourceVariant(e);
                if (i === void 0) {
                    let s = this.discriminator,
                        o = this.defaultLayout,
                        a = 0;
                    return this.usesPrefixDiscriminator && (a = s.layout.span), s.encode(e[s.property], n, r), a + o.encode(e[o.property], n, r + a)
                }
                return i.encode(e, n, r)
            }
            addVariant(e, n, r) {
                let i = new Th(this, e, n, r);
                return this.registry[e] = i, i
            }
            getVariant(e, n) {
                let r = e;
                return Buffer.isBuffer(e) && (n === void 0 && (n = 0), r = this.discriminator.decode(e, n)), this.registry[r]
            }
        },
        Th = class extends Ee {
            constructor(e, n, r, i) {
                if (!(e instanceof Mc)) throw new TypeError("union must be a Union");
                if (!Number.isInteger(n) || 0 > n) throw new TypeError("variant must be a (non-negative) integer");
                if (typeof r == "string" && i === void 0 && (i = r, r = null), r) {
                    if (!(r instanceof Ee)) throw new TypeError("layout must be a Layout");
                    if (e.defaultLayout !== null && 0 <= r.span && r.span > e.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                    if (typeof i != "string") throw new TypeError("variant must have a String property")
                }
                let s = e.span;
                0 > e.span && (s = r ? r.span : 0, 0 <= s && e.usesPrefixDiscriminator && (s += e.discriminator.layout.span)), super(s, i), this.union = e, this.variant = n, this.layout = r || null
            }
            getSpan(e, n) {
                if (0 <= this.span) return this.span;
                n === void 0 && (n = 0);
                let r = 0;
                return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), r + this.layout.getSpan(e, n + r)
            }
            decode(e, n) {
                let r = this.makeDestinationObject();
                if (n === void 0 && (n = 0), this !== this.union.getVariant(e, n)) throw new Error("variant mismatch");
                let i = 0;
                return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout ? r[this.property] = this.layout.decode(e, n + i) : this.property ? r[this.property] = !0 : this.union.usesPrefixDiscriminator && (r[this.union.discriminator.property] = this.variant), r
            }
            encode(e, n, r) {
                r === void 0 && (r = 0);
                let i = 0;
                if (this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout && !e.hasOwnProperty(this.property)) throw new TypeError("variant lacks property " + this.property);
                this.union.discriminator.encode(this.variant, n, r);
                let s = i;
                if (this.layout && (this.layout.encode(e[this.property], n, r + i), s += this.layout.getSpan(n, r + i), 0 <= this.union.span && s > this.union.span)) throw new Error("encoded variant overruns containing union");
                return s
            }
            fromArray(e) {
                if (this.layout) return this.layout.fromArray(e)
            }
        };

    function Bo(t) {
        return 0 > t && (t += 4294967296), t
    }
    var Ic = class extends Ee {
            constructor(e, n, r) {
                if (!(e instanceof Dn || e instanceof zn)) throw new TypeError("word must be a UInt or UIntBE layout");
                if (typeof n == "string" && r === void 0 && (r = n, n = void 0), 4 < e.span) throw new RangeError("word cannot exceed 32 bits");
                super(e.span, r), this.word = e, this.msb = !!n, this.fields = [];
                let i = 0;
                this._packedSetValue = function(s) {
                    return i = Bo(s), this
                }, this._packedGetValue = function() {
                    return i
                }
            }
            decode(e, n) {
                let r = this.makeDestinationObject();
                n === void 0 && (n = 0);
                let i = this.word.decode(e, n);
                this._packedSetValue(i);
                for (let s of this.fields) s.property !== void 0 && (r[s.property] = s.decode(i));
                return r
            }
            encode(e, n, r) {
                r === void 0 && (r = 0);
                let i = this.word.decode(n, r);
                this._packedSetValue(i);
                for (let s of this.fields)
                    if (s.property !== void 0) {
                        let o = e[s.property];
                        o !== void 0 && s.encode(o)
                    }
                return this.word.encode(this._packedGetValue(), n, r)
            }
            addField(e, n) {
                let r = new fs(this, e, n);
                return this.fields.push(r), r
            }
            addBoolean(e) {
                let n = new xh(this, e);
                return this.fields.push(n), n
            }
            fieldFor(e) {
                if (typeof e != "string") throw new TypeError("property must be string");
                for (let n of this.fields)
                    if (n.property === e) return n
            }
        },
        fs = class {
            constructor(e, n, r) {
                if (!(e instanceof Ic)) throw new TypeError("container must be a BitStructure");
                if (!Number.isInteger(n) || 0 >= n) throw new TypeError("bits must be positive integer");
                let i = 8 * e.span,
                    s = e.fields.reduce((o, a) => o + a.bits, 0);
                if (n + s > i) throw new Error("bits too long for span remainder (" + (i - s) + " of " + i + " remain)");
                this.container = e, this.bits = n, this.valueMask = (1 << n) - 1, n === 32 && (this.valueMask = 4294967295), this.start = s, this.container.msb && (this.start = i - s - n), this.wordMask = Bo(this.valueMask << this.start), this.property = r
            }
            decode() {
                let e = this.container._packedGetValue();
                return Bo(e & this.wordMask) >>> this.start
            }
            encode(e) {
                if (!Number.isInteger(e) || e !== Bo(e & this.valueMask)) throw new TypeError($v("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
                let n = this.container._packedGetValue(),
                    r = Bo(e << this.start);
                this.container._packedSetValue(Bo(n & ~this.wordMask) | r)
            }
        },
        xh = class extends fs {
            constructor(e, n) {
                super(e, 1, n)
            }
            decode(e, n) {
                return !!fs.prototype.decode.call(this, e, n)
            }
            encode(e) {
                return typeof e == "boolean" && (e = +e), fs.prototype.encode.call(this, e)
            }
        },
        Ah = class extends Ee {
            constructor(e, n) {
                if (!(e instanceof At && e.isCount() || Number.isInteger(e) && 0 <= e)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                let r = -1;
                e instanceof At || (r = e), super(r, n), this.length = e
            }
            getSpan(e, n) {
                let r = this.span;
                return 0 > r && (r = this.length.decode(e, n)), r
            }
            decode(e, n) {
                n === void 0 && (n = 0);
                let r = this.span;
                return 0 > r && (r = this.length.decode(e, n)), e.slice(n, n + r)
            }
            encode(e, n, r) {
                let i = this.length;
                if (this.length instanceof At && (i = e.length), !(Buffer.isBuffer(e) && i === e.length)) throw new TypeError($v("Blob.encode", this) + " requires (length " + i + ") Buffer as src");
                if (r + i > n.length) throw new RangeError("encoding overruns Buffer");
                return n.write(e.toString("hex"), r, i, "hex"), this.length instanceof At && this.length.encode(i, n, r), i
            }
        },
        Nh = class extends Ee {
            constructor(e) {
                super(-1, e)
            }
            getSpan(e, n) {
                if (!Buffer.isBuffer(e)) throw new TypeError("b must be a Buffer");
                n === void 0 && (n = 0);
                let r = n;
                for (; r < e.length && e[r] !== 0;) r += 1;
                return 1 + r - n
            }
            decode(e, n, r) {
                n === void 0 && (n = 0);
                let i = this.getSpan(e, n);
                return e.slice(n, n + i - 1).toString("utf-8")
            }
            encode(e, n, r) {
                r === void 0 && (r = 0), typeof e != "string" && (e = e.toString());
                let i = new Buffer(e, "utf8"),
                    s = i.length;
                if (r + s > n.length) throw new RangeError("encoding overruns Buffer");
                return i.copy(n, r), n[r + s] = 0, s + 1
            }
        },
        Rh = class extends Ee {
            constructor(e, n) {
                if (typeof e == "string" && n === void 0 && (n = e, e = void 0), e === void 0) e = -1;
                else if (!Number.isInteger(e)) throw new TypeError("maxSpan must be an integer");
                super(-1, n), this.maxSpan = e
            }
            getSpan(e, n) {
                if (!Buffer.isBuffer(e)) throw new TypeError("b must be a Buffer");
                return n === void 0 && (n = 0), e.length - n
            }
            decode(e, n, r) {
                n === void 0 && (n = 0);
                let i = this.getSpan(e, n);
                if (0 <= this.maxSpan && this.maxSpan < i) throw new RangeError("text length exceeds maxSpan");
                return e.slice(n, n + i).toString("utf-8")
            }
            encode(e, n, r) {
                r === void 0 && (r = 0), typeof e != "string" && (e = e.toString());
                let i = new Buffer(e, "utf8"),
                    s = i.length;
                if (0 <= this.maxSpan && this.maxSpan < s) throw new RangeError("text length exceeds maxSpan");
                if (r + s > n.length) throw new RangeError("encoding overruns Buffer");
                return i.copy(n, r), s
            }
        },
        Oh = class extends Ee {
            constructor(e, n) {
                super(0, n), this.value = e
            }
            decode(e, n, r) {
                return this.value
            }
            encode(e, n, r) {
                return 0
            }
        };
    U.ExternalLayout = At;
    U.GreedyCount = bh;
    U.OffsetLayout = Cc;
    U.UInt = Dn;
    U.UIntBE = zn;
    U.Int = kr;
    U.IntBE = vi;
    U.Float = Dh;
    U.FloatBE = Eh;
    U.Double = Ch;
    U.DoubleBE = Sh;
    U.Sequence = Mh;
    U.Structure = Ih;
    U.UnionDiscriminator = Sc;
    U.UnionLayoutDiscriminator = zo;
    U.Union = Mc;
    U.VariantLayout = Th;
    U.BitStructure = Ic;
    U.BitField = fs;
    U.Boolean = xh;
    U.Blob = Ah;
    U.CString = Nh;
    U.UTF8 = Rh;
    U.Constant = Oh;
    U.greedy = (t, e) => new bh(t, e);
    U.offset = (t, e, n) => new Cc(t, e, n);
    U.u8 = t => new Dn(1, t);
    U.u16 = t => new Dn(2, t);
    U.u24 = t => new Dn(3, t);
    U.u32 = t => new Dn(4, t);
    U.u40 = t => new Dn(5, t);
    U.u48 = t => new Dn(6, t);
    U.nu64 = t => new Uv(t);
    U.u16be = t => new zn(2, t);
    U.u24be = t => new zn(3, t);
    U.u32be = t => new zn(4, t);
    U.u40be = t => new zn(5, t);
    U.u48be = t => new zn(6, t);
    U.nu64be = t => new jv(t);
    U.s8 = t => new kr(1, t);
    U.s16 = t => new kr(2, t);
    U.s24 = t => new kr(3, t);
    U.s32 = t => new kr(4, t);
    U.s40 = t => new kr(5, t);
    U.s48 = t => new kr(6, t);
    U.ns64 = t => new Bv(t);
    U.s16be = t => new vi(2, t);
    U.s24be = t => new vi(3, t);
    U.s32be = t => new vi(4, t);
    U.s40be = t => new vi(5, t);
    U.s48be = t => new vi(6, t);
    U.ns64be = t => new zv(t);
    U.f32 = t => new Dh(t);
    U.f32be = t => new Eh(t);
    U.f64 = t => new Ch(t);
    U.f64be = t => new Sh(t);
    U.struct = (t, e, n) => new Ih(t, e, n);
    U.bits = (t, e, n) => new Ic(t, e, n);
    U.seq = (t, e, n) => new Mh(t, e, n);
    U.union = (t, e, n) => new Mc(t, e, n);
    U.unionLayoutDiscriminator = (t, e) => new zo(t, e);
    U.blob = (t, e) => new Ah(t, e);
    U.cstr = t => new Nh(t);
    U.utf8 = (t, e) => new Rh(t, e);
    U.const = (t, e) => new Oh(t, e)
});
var $M = oa(q => {
    "use strict";
    var H2 = q && q.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    };
    Object.defineProperty(q, "__esModule", {
        value: !0
    });
    q.map = q.array = q.rustEnum = q.str = q.vecU8 = q.tagged = q.vec = q.bool = q.option = q.publicKey = q.i256 = q.u256 = q.i128 = q.u128 = q.i64 = q.u64 = q.struct = q.f64 = q.f32 = q.i32 = q.u32 = q.i16 = q.u16 = q.i8 = q.u8 = void 0;
    var Pe = Wv(),
        G2 = (_r(), yA(t_)),
        Z2 = H2(Hf()),
        Pr = Wv();
    Object.defineProperty(q, "u8", {
        enumerable: !0,
        get: function() {
            return Pr.u8
        }
    });
    Object.defineProperty(q, "i8", {
        enumerable: !0,
        get: function() {
            return Pr.s8
        }
    });
    Object.defineProperty(q, "u16", {
        enumerable: !0,
        get: function() {
            return Pr.u16
        }
    });
    Object.defineProperty(q, "i16", {
        enumerable: !0,
        get: function() {
            return Pr.s16
        }
    });
    Object.defineProperty(q, "u32", {
        enumerable: !0,
        get: function() {
            return Pr.u32
        }
    });
    Object.defineProperty(q, "i32", {
        enumerable: !0,
        get: function() {
            return Pr.s32
        }
    });
    Object.defineProperty(q, "f32", {
        enumerable: !0,
        get: function() {
            return Pr.f32
        }
    });
    Object.defineProperty(q, "f64", {
        enumerable: !0,
        get: function() {
            return Pr.f64
        }
    });
    Object.defineProperty(q, "struct", {
        enumerable: !0,
        get: function() {
            return Pr.struct
        }
    });
    var wi = class extends Pe.Layout {
        constructor(e, n, r) {
            super(e, r), this.blob = (0, Pe.blob)(e), this.signed = n
        }
        decode(e, n = 0) {
            let r = new Z2.default(this.blob.decode(e, n), 10, "le");
            return this.signed ? r.fromTwos(this.span * 8).clone() : r
        }
        encode(e, n, r = 0) {
            return this.signed && (e = e.toTwos(this.span * 8)), this.blob.encode(e.toArrayLike(Buffer, "le", this.span), n, r)
        }
    };

    function BM(t) {
        return new wi(8, !1, t)
    }
    q.u64 = BM;

    function Q2(t) {
        return new wi(8, !0, t)
    }
    q.i64 = Q2;

    function q2(t) {
        return new wi(16, !1, t)
    }
    q.u128 = q2;

    function K2(t) {
        return new wi(16, !0, t)
    }
    q.i128 = K2;

    function Y2(t) {
        return new wi(32, !1, t)
    }
    q.u256 = Y2;

    function J2(t) {
        return new wi(32, !0, t)
    }
    q.i256 = J2;
    var ur = class extends Pe.Layout {
        constructor(e, n, r, i) {
            super(e.span, i), this.layout = e, this.decoder = n, this.encoder = r
        }
        decode(e, n) {
            return this.decoder(this.layout.decode(e, n))
        }
        encode(e, n, r) {
            return this.layout.encode(this.encoder(e), n, r)
        }
        getSpan(e, n) {
            return this.layout.getSpan(e, n)
        }
    };

    function X2(t) {
        return new ur((0, Pe.blob)(32), e => new G2.PublicKey(e), e => e.toBuffer(), t)
    }
    q.publicKey = X2;
    var Hv = class extends Pe.Layout {
        constructor(e, n) {
            super(-1, n), this.layout = e, this.discriminator = (0, Pe.u8)()
        }
        encode(e, n, r = 0) {
            return e == null ? this.discriminator.encode(0, n, r) : (this.discriminator.encode(1, n, r), this.layout.encode(e, n, r + 1) + 1)
        }
        decode(e, n = 0) {
            let r = this.discriminator.decode(e, n);
            if (r === 0) return null;
            if (r === 1) return this.layout.decode(e, n + 1);
            throw new Error("Invalid option " + this.property)
        }
        getSpan(e, n = 0) {
            let r = this.discriminator.decode(e, n);
            if (r === 0) return 1;
            if (r === 1) return this.layout.getSpan(e, n + 1) + 1;
            throw new Error("Invalid option " + this.property)
        }
    };

    function ej(t, e) {
        return new Hv(t, e)
    }
    q.option = ej;

    function tj(t) {
        return new ur((0, Pe.u8)(), nj, rj, t)
    }
    q.bool = tj;

    function nj(t) {
        if (t === 0) return !1;
        if (t === 1) return !0;
        throw new Error("Invalid bool: " + t)
    }

    function rj(t) {
        return t ? 1 : 0
    }

    function ij(t, e) {
        let n = (0, Pe.u32)("length"),
            r = (0, Pe.struct)([n, (0, Pe.seq)(t, (0, Pe.offset)(n, -n.span), "values")]);
        return new ur(r, ({
            values: i
        }) => i, i => ({
            values: i
        }), e)
    }
    q.vec = ij;

    function sj(t, e, n) {
        let r = (0, Pe.struct)([BM("tag"), e.replicate("data")]);

        function i({
            tag: s,
            data: o
        }) {
            if (!s.eq(t)) throw new Error("Invalid tag, expected: " + t.toString("hex") + ", got: " + s.toString("hex"));
            return o
        }
        return new ur(r, i, s => ({
            tag: t,
            data: s
        }), n)
    }
    q.tagged = sj;

    function zM(t) {
        let e = (0, Pe.u32)("length"),
            n = (0, Pe.struct)([e, (0, Pe.blob)((0, Pe.offset)(e, -e.span), "data")]);
        return new ur(n, ({
            data: r
        }) => r, r => ({
            data: r
        }), t)
    }
    q.vecU8 = zM;

    function oj(t) {
        return new ur(zM(), e => e.toString("utf-8"), e => Buffer.from(e, "utf-8"), t)
    }
    q.str = oj;

    function aj(t, e, n) {
        let r = (0, Pe.union)(n ? ? (0, Pe.u8)(), e);
        return t.forEach((i, s) => r.addVariant(s, i, i.property)), r
    }
    q.rustEnum = aj;

    function cj(t, e, n) {
        let r = (0, Pe.struct)([(0, Pe.seq)(t, e, "values")]);
        return new ur(r, ({
            values: i
        }) => i, i => ({
            values: i
        }), n)
    }
    q.array = cj;
    var Gv = class extends Pe.Layout {
        constructor(e, n, r) {
            super(e.span + n.span, r), this.keyLayout = e, this.valueLayout = n
        }
        decode(e, n) {
            n = n || 0;
            let r = this.keyLayout.decode(e, n),
                i = this.valueLayout.decode(e, n + this.keyLayout.getSpan(e, n));
            return [r, i]
        }
        encode(e, n, r) {
            r = r || 0;
            let i = this.keyLayout.encode(e[0], n, r),
                s = this.valueLayout.encode(e[1], n, r + i);
            return i + s
        }
        getSpan(e, n) {
            return this.keyLayout.getSpan(e, n) + this.valueLayout.getSpan(e, n)
        }
    };

    function lj(t, e, n) {
        let r = (0, Pe.u32)("length"),
            i = (0, Pe.struct)([r, (0, Pe.seq)(new Gv(t, e), (0, Pe.offset)(r, -r.span), "values")]);
        return new ur(i, ({
            values: s
        }) => new Map(s), s => ({
            values: Array.from(s.entries())
        }), n)
    }
    q.map = lj
});
var rx = oa((f7, nx) => {
    "use strict";

    function F3(t) {
        if (t.length >= 255) throw new TypeError("Alphabet too long");
        for (var e = new Uint8Array(256), n = 0; n < e.length; n++) e[n] = 255;
        for (var r = 0; r < t.length; r++) {
            var i = t.charAt(r),
                s = i.charCodeAt(0);
            if (e[s] !== 255) throw new TypeError(i + " is ambiguous");
            e[s] = r
        }
        var o = t.length,
            a = t.charAt(0),
            c = Math.log(o) / Math.log(256),
            l = Math.log(256) / Math.log(o);

        function u(f) {
            if (f instanceof Uint8Array || (ArrayBuffer.isView(f) ? f = new Uint8Array(f.buffer, f.byteOffset, f.byteLength) : Array.isArray(f) && (f = Uint8Array.from(f))), !(f instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
            if (f.length === 0) return "";
            for (var p = 0, g = 0, m = 0, y = f.length; m !== y && f[m] === 0;) m++, p++;
            for (var E = (y - m) * l + 1 >>> 0, T = new Uint8Array(E); m !== y;) {
                for (var w = f[m], N = 0, L = E - 1;
                    (w !== 0 || N < g) && L !== -1; L--, N++) w += 256 * T[L] >>> 0, T[L] = w % o >>> 0, w = w / o >>> 0;
                if (w !== 0) throw new Error("Non-zero carry");
                g = N, m++
            }
            for (var D = E - g; D !== E && T[D] === 0;) D++;
            for (var j = a.repeat(p); D < E; ++D) j += t.charAt(T[D]);
            return j
        }

        function d(f) {
            if (typeof f != "string") throw new TypeError("Expected String");
            if (f.length === 0) return new Uint8Array;
            for (var p = 0, g = 0, m = 0; f[p] === a;) g++, p++;
            for (var y = (f.length - p) * c + 1 >>> 0, E = new Uint8Array(y); f[p];) {
                var T = e[f.charCodeAt(p)];
                if (T === 255) return;
                for (var w = 0, N = y - 1;
                    (T !== 0 || w < m) && N !== -1; N--, w++) T += o * E[N] >>> 0, E[N] = T % 256 >>> 0, T = T / 256 >>> 0;
                if (T !== 0) throw new Error("Non-zero carry");
                m = w, p++
            }
            for (var L = y - m; L !== y && E[L] === 0;) L++;
            for (var D = new Uint8Array(g + (y - L)), j = g; L !== y;) D[j++] = E[L++];
            return D
        }

        function h(f) {
            var p = d(f);
            if (p) return p;
            throw new Error("Non-base" + o + " character")
        }
        return {
            encode: u,
            decodeUnsafe: d,
            decode: h
        }
    }
    nx.exports = F3
});
var sx = oa((p7, ix) => {
    "use strict";
    var k3 = rx(),
        P3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    ix.exports = k3(P3)
});

function n_(t, e) {
    return Object.is(t, e)
}
var lt = null,
    gl = !1,
    ml = 1,
    br = Symbol("SIGNAL");

function pe(t) {
    let e = lt;
    return lt = t, e
}
var vl = {
    version: 0,
    lastCleanEpoch: 0,
    dirty: !1,
    producerNode: void 0,
    producerLastReadVersion: void 0,
    producerIndexOfThis: void 0,
    nextProducerIndex: 0,
    liveConsumerNode: void 0,
    liveConsumerIndexOfThis: void 0,
    consumerAllowSignalWrites: !1,
    consumerIsAlwaysLive: !1,
    producerMustRecompute: () => !1,
    producerRecomputeValue: () => {},
    consumerMarkedDirty: () => {},
    consumerOnSignalRead: () => {}
};

function qf(t) {
    if (gl) throw new Error("");
    if (lt === null) return;
    lt.consumerOnSignalRead(t);
    let e = lt.nextProducerIndex++;
    if (Fs(lt), e < lt.producerNode.length && lt.producerNode[e] !== t && aa(lt)) {
        let n = lt.producerNode[e];
        wl(n, lt.producerIndexOfThis[e])
    }
    lt.producerNode[e] !== t && (lt.producerNode[e] = t, lt.producerIndexOfThis[e] = aa(lt) ? a_(t, lt, e) : 0), lt.producerLastReadVersion[e] = t.version
}

function _A() {
    ml++
}

function r_(t) {
    if (!(aa(t) && !t.dirty) && !(!t.dirty && t.lastCleanEpoch === ml)) {
        if (!t.producerMustRecompute(t) && !Jf(t)) {
            t.dirty = !1, t.lastCleanEpoch = ml;
            return
        }
        t.producerRecomputeValue(t), t.dirty = !1, t.lastCleanEpoch = ml
    }
}

function i_(t) {
    if (t.liveConsumerNode === void 0) return;
    let e = gl;
    gl = !0;
    try {
        for (let n of t.liveConsumerNode) n.dirty || bA(n)
    } finally {
        gl = e
    }
}

function s_() {
    return lt ? .consumerAllowSignalWrites !== !1
}

function bA(t) {
    t.dirty = !0, i_(t), t.consumerMarkedDirty ? .(t)
}

function Kf(t) {
    return t && (t.nextProducerIndex = 0), pe(t)
}

function Yf(t, e) {
    if (pe(e), !(!t || t.producerNode === void 0 || t.producerIndexOfThis === void 0 || t.producerLastReadVersion === void 0)) {
        if (aa(t))
            for (let n = t.nextProducerIndex; n < t.producerNode.length; n++) wl(t.producerNode[n], t.producerIndexOfThis[n]);
        for (; t.producerNode.length > t.nextProducerIndex;) t.producerNode.pop(), t.producerLastReadVersion.pop(), t.producerIndexOfThis.pop()
    }
}

function Jf(t) {
    Fs(t);
    for (let e = 0; e < t.producerNode.length; e++) {
        let n = t.producerNode[e],
            r = t.producerLastReadVersion[e];
        if (r !== n.version || (r_(n), r !== n.version)) return !0
    }
    return !1
}

function o_(t) {
    if (Fs(t), aa(t))
        for (let e = 0; e < t.producerNode.length; e++) wl(t.producerNode[e], t.producerIndexOfThis[e]);
    t.producerNode.length = t.producerLastReadVersion.length = t.producerIndexOfThis.length = 0, t.liveConsumerNode && (t.liveConsumerNode.length = t.liveConsumerIndexOfThis.length = 0)
}

function a_(t, e, n) {
    if (c_(t), Fs(t), t.liveConsumerNode.length === 0)
        for (let r = 0; r < t.producerNode.length; r++) t.producerIndexOfThis[r] = a_(t.producerNode[r], t, r);
    return t.liveConsumerIndexOfThis.push(n), t.liveConsumerNode.push(e) - 1
}

function wl(t, e) {
    if (c_(t), Fs(t), t.liveConsumerNode.length === 1)
        for (let r = 0; r < t.producerNode.length; r++) wl(t.producerNode[r], t.producerIndexOfThis[r]);
    let n = t.liveConsumerNode.length - 1;
    if (t.liveConsumerNode[e] = t.liveConsumerNode[n], t.liveConsumerIndexOfThis[e] = t.liveConsumerIndexOfThis[n], t.liveConsumerNode.length--, t.liveConsumerIndexOfThis.length--, e < t.liveConsumerNode.length) {
        let r = t.liveConsumerIndexOfThis[e],
            i = t.liveConsumerNode[e];
        Fs(i), i.producerIndexOfThis[r] = e
    }
}

function aa(t) {
    return t.consumerIsAlwaysLive || (t ? .liveConsumerNode ? .length ? ? 0) > 0
}

function Fs(t) {
    t.producerNode ? ? = [], t.producerIndexOfThis ? ? = [], t.producerLastReadVersion ? ? = []
}

function c_(t) {
    t.liveConsumerNode ? ? = [], t.liveConsumerIndexOfThis ? ? = []
}

function l_(t) {
    let e = Object.create(DA);
    e.computation = t;
    let n = () => {
        if (r_(e), qf(e), e.value === yl) throw e.error;
        return e.value
    };
    return n[br] = e, n
}
var Zf = Symbol("UNSET"),
    Qf = Symbol("COMPUTING"),
    yl = Symbol("ERRORED"),
    DA = Q(_({}, vl), {
        value: Zf,
        dirty: !0,
        error: null,
        equal: n_,
        producerMustRecompute(t) {
            return t.value === Zf || t.value === Qf
        },
        producerRecomputeValue(t) {
            if (t.value === Qf) throw new Error("Detected cycle in computations.");
            let e = t.value;
            t.value = Qf;
            let n = Kf(t),
                r;
            try {
                r = t.computation()
            } catch (i) {
                r = yl, t.error = i
            } finally {
                Yf(t, n)
            }
            if (e !== Zf && e !== yl && r !== yl && t.equal(e, r)) {
                t.value = e;
                return
            }
            t.value = r, t.version++
        }
    });

function EA() {
    throw new Error
}
var u_ = EA;

function d_() {
    u_()
}

function h_(t) {
    u_ = t
}
var CA = null;

function f_(t) {
    let e = Object.create(g_);
    e.value = t;
    let n = () => (qf(e), e.value);
    return n[br] = e, n
}

function Xf(t, e) {
    s_() || d_(), t.equal(t.value, e) || (t.value = e, SA(t))
}

function p_(t, e) {
    s_() || d_(), Xf(t, e(t.value))
}
var g_ = Q(_({}, vl), {
    equal: n_,
    value: void 0
});

function SA(t) {
    t.version++, _A(), i_(t), CA ? .()
}

function J(t) {
    return typeof t == "function"
}

function ks(t) {
    let n = t(r => {
        Error.call(r), r.stack = new Error().stack
    });
    return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n
}
var _l = ks(t => function(n) {
    t(this), this.message = n ? `${n.length} errors occurred during unsubscription:
${n.map((r,i)=>`${i+1}) ${r.toString()}`).join(`
  `)}` : "", this.name = "UnsubscriptionError", this.errors = n
});

function Ri(t, e) {
    if (t) {
        let n = t.indexOf(e);
        0 <= n && t.splice(n, 1)
    }
}
var Oe = class t {
    constructor(e) {
        this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null
    }
    unsubscribe() {
        let e;
        if (!this.closed) {
            this.closed = !0;
            let {
                _parentage: n
            } = this;
            if (n)
                if (this._parentage = null, Array.isArray(n))
                    for (let s of n) s.remove(this);
                else n.remove(this);
            let {
                initialTeardown: r
            } = this;
            if (J(r)) try {
                r()
            } catch (s) {
                e = s instanceof _l ? s.errors : [s]
            }
            let {
                _finalizers: i
            } = this;
            if (i) {
                this._finalizers = null;
                for (let s of i) try {
                    m_(s)
                } catch (o) {
                    e = e ? ? [], o instanceof _l ? e = [...e, ...o.errors] : e.push(o)
                }
            }
            if (e) throw new _l(e)
        }
    }
    add(e) {
        var n;
        if (e && e !== this)
            if (this.closed) m_(e);
            else {
                if (e instanceof t) {
                    if (e.closed || e._hasParent(this)) return;
                    e._addParent(this)
                }(this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(e)
            }
    }
    _hasParent(e) {
        let {
            _parentage: n
        } = this;
        return n === e || Array.isArray(n) && n.includes(e)
    }
    _addParent(e) {
        let {
            _parentage: n
        } = this;
        this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e
    }
    _removeParent(e) {
        let {
            _parentage: n
        } = this;
        n === e ? this._parentage = null : Array.isArray(n) && Ri(n, e)
    }
    remove(e) {
        let {
            _finalizers: n
        } = this;
        n && Ri(n, e), e instanceof t && e._removeParent(this)
    }
};
Oe.EMPTY = (() => {
    let t = new Oe;
    return t.closed = !0, t
})();
var ep = Oe.EMPTY;

function bl(t) {
    return t instanceof Oe || t && "closed" in t && J(t.remove) && J(t.add) && J(t.unsubscribe)
}

function m_(t) {
    J(t) ? t() : t.unsubscribe()
}
var xn = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: !1,
    useDeprecatedNextContext: !1
};
var Ps = {
    setTimeout(t, e, ...n) {
        let {
            delegate: r
        } = Ps;
        return r ? .setTimeout ? r.setTimeout(t, e, ...n) : setTimeout(t, e, ...n)
    },
    clearTimeout(t) {
        let {
            delegate: e
        } = Ps;
        return (e ? .clearTimeout || clearTimeout)(t)
    },
    delegate: void 0
};

function Dl(t) {
    Ps.setTimeout(() => {
        let {
            onUnhandledError: e
        } = xn;
        if (e) e(t);
        else throw t
    })
}

function Oi() {}
var y_ = tp("C", void 0, void 0);

function v_(t) {
    return tp("E", void 0, t)
}

function w_(t) {
    return tp("N", t, void 0)
}

function tp(t, e, n) {
    return {
        kind: t,
        value: e,
        error: n
    }
}
var Fi = null;

function Ls(t) {
    if (xn.useDeprecatedSynchronousErrorHandling) {
        let e = !Fi;
        if (e && (Fi = {
                errorThrown: !1,
                error: null
            }), t(), e) {
            let {
                errorThrown: n,
                error: r
            } = Fi;
            if (Fi = null, n) throw r
        }
    } else t()
}

function __(t) {
    xn.useDeprecatedSynchronousErrorHandling && Fi && (Fi.errorThrown = !0, Fi.error = t)
}
var ki = class extends Oe {
        constructor(e) {
            super(), this.isStopped = !1, e ? (this.destination = e, bl(e) && e.add(this)) : this.destination = TA
        }
        static create(e, n, r) {
            return new An(e, n, r)
        }
        next(e) {
            this.isStopped ? rp(w_(e), this) : this._next(e)
        }
        error(e) {
            this.isStopped ? rp(v_(e), this) : (this.isStopped = !0, this._error(e))
        }
        complete() {
            this.isStopped ? rp(y_, this) : (this.isStopped = !0, this._complete())
        }
        unsubscribe() {
            this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null)
        }
        _next(e) {
            this.destination.next(e)
        }
        _error(e) {
            try {
                this.destination.error(e)
            } finally {
                this.unsubscribe()
            }
        }
        _complete() {
            try {
                this.destination.complete()
            } finally {
                this.unsubscribe()
            }
        }
    },
    MA = Function.prototype.bind;

function np(t, e) {
    return MA.call(t, e)
}
var ip = class {
        constructor(e) {
            this.partialObserver = e
        }
        next(e) {
            let {
                partialObserver: n
            } = this;
            if (n.next) try {
                n.next(e)
            } catch (r) {
                El(r)
            }
        }
        error(e) {
            let {
                partialObserver: n
            } = this;
            if (n.error) try {
                n.error(e)
            } catch (r) {
                El(r)
            } else El(e)
        }
        complete() {
            let {
                partialObserver: e
            } = this;
            if (e.complete) try {
                e.complete()
            } catch (n) {
                El(n)
            }
        }
    },
    An = class extends ki {
        constructor(e, n, r) {
            super();
            let i;
            if (J(e) || !e) i = {
                next: e ? ? void 0,
                error: n ? ? void 0,
                complete: r ? ? void 0
            };
            else {
                let s;
                this && xn.useDeprecatedNextContext ? (s = Object.create(e), s.unsubscribe = () => this.unsubscribe(), i = {
                    next: e.next && np(e.next, s),
                    error: e.error && np(e.error, s),
                    complete: e.complete && np(e.complete, s)
                }) : i = e
            }
            this.destination = new ip(i)
        }
    };

function El(t) {
    xn.useDeprecatedSynchronousErrorHandling ? __(t) : Dl(t)
}

function IA(t) {
    throw t
}

function rp(t, e) {
    let {
        onStoppedNotification: n
    } = xn;
    n && Ps.setTimeout(() => n(t, e))
}
var TA = {
    closed: !0,
    next: Oi,
    error: IA,
    complete: Oi
};
var Vs = typeof Symbol == "function" && Symbol.observable || "@@observable";

function gt(t) {
    return t
}

function sp(...t) {
    return op(t)
}

function op(t) {
    return t.length === 0 ? gt : t.length === 1 ? t[0] : function(n) {
        return t.reduce((r, i) => i(r), n)
    }
}
var ie = (() => {
    class t {
        constructor(n) {
            n && (this._subscribe = n)
        }
        lift(n) {
            let r = new t;
            return r.source = this, r.operator = n, r
        }
        subscribe(n, r, i) {
            let s = AA(n) ? n : new An(n, r, i);
            return Ls(() => {
                let {
                    operator: o,
                    source: a
                } = this;
                s.add(o ? o.call(s, a) : a ? this._subscribe(s) : this._trySubscribe(s))
            }), s
        }
        _trySubscribe(n) {
            try {
                return this._subscribe(n)
            } catch (r) {
                n.error(r)
            }
        }
        forEach(n, r) {
            return r = b_(r), new r((i, s) => {
                let o = new An({
                    next: a => {
                        try {
                            n(a)
                        } catch (c) {
                            s(c), o.unsubscribe()
                        }
                    },
                    error: s,
                    complete: i
                });
                this.subscribe(o)
            })
        }
        _subscribe(n) {
            var r;
            return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)
        }[Vs]() {
            return this
        }
        pipe(...n) {
            return op(n)(this)
        }
        toPromise(n) {
            return n = b_(n), new n((r, i) => {
                let s;
                this.subscribe(o => s = o, o => i(o), () => r(s))
            })
        }
    }
    return t.create = e => new t(e), t
})();

function b_(t) {
    var e;
    return (e = t ? ? xn.Promise) !== null && e !== void 0 ? e : Promise
}

function xA(t) {
    return t && J(t.next) && J(t.error) && J(t.complete)
}

function AA(t) {
    return t && t instanceof ki || xA(t) && bl(t)
}

function ap(t) {
    return J(t ? .lift)
}

function ne(t) {
    return e => {
        if (ap(e)) return e.lift(function(n) {
            try {
                return t(n, this)
            } catch (r) {
                this.error(r)
            }
        });
        throw new TypeError("Unable to lift unknown Observable type")
    }
}

function te(t, e, n, r, i) {
    return new cp(t, e, n, r, i)
}
var cp = class extends ki {
    constructor(e, n, r, i, s, o) {
        super(e), this.onFinalize = s, this.shouldUnsubscribe = o, this._next = n ? function(a) {
            try {
                n(a)
            } catch (c) {
                e.error(c)
            }
        } : super._next, this._error = i ? function(a) {
            try {
                i(a)
            } catch (c) {
                e.error(c)
            } finally {
                this.unsubscribe()
            }
        } : super._error, this._complete = r ? function() {
            try {
                r()
            } catch (a) {
                e.error(a)
            } finally {
                this.unsubscribe()
            }
        } : super._complete
    }
    unsubscribe() {
        var e;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            let {
                closed: n
            } = this;
            super.unsubscribe(), !n && ((e = this.onFinalize) === null || e === void 0 || e.call(this))
        }
    }
};

function Us() {
    return ne((t, e) => {
        let n = null;
        t._refCount++;
        let r = te(e, void 0, void 0, void 0, () => {
            if (!t || t._refCount <= 0 || 0 < --t._refCount) {
                n = null;
                return
            }
            let i = t._connection,
                s = n;
            n = null, i && (!s || i === s) && i.unsubscribe(), e.unsubscribe()
        });
        t.subscribe(r), r.closed || (n = t.connect())
    })
}
var js = class extends ie {
    constructor(e, n) {
        super(), this.source = e, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, ap(e) && (this.lift = e.lift)
    }
    _subscribe(e) {
        return this.getSubject().subscribe(e)
    }
    getSubject() {
        let e = this._subject;
        return (!e || e.isStopped) && (this._subject = this.subjectFactory()), this._subject
    }
    _teardown() {
        this._refCount = 0;
        let {
            _connection: e
        } = this;
        this._subject = this._connection = null, e ? .unsubscribe()
    }
    connect() {
        let e = this._connection;
        if (!e) {
            e = this._connection = new Oe;
            let n = this.getSubject();
            e.add(this.source.subscribe(te(n, void 0, () => {
                this._teardown(), n.complete()
            }, r => {
                this._teardown(), n.error(r)
            }, () => this._teardown()))), e.closed && (this._connection = null, e = Oe.EMPTY)
        }
        return e
    }
    refCount() {
        return Us()(this)
    }
};
var Bs = {
    schedule(t) {
        let e = requestAnimationFrame,
            n = cancelAnimationFrame,
            {
                delegate: r
            } = Bs;
        r && (e = r.requestAnimationFrame, n = r.cancelAnimationFrame);
        let i = e(s => {
            n = void 0, t(s)
        });
        return new Oe(() => n ? .(i))
    },
    requestAnimationFrame(...t) {
        let {
            delegate: e
        } = Bs;
        return (e ? .requestAnimationFrame || requestAnimationFrame)(...t)
    },
    cancelAnimationFrame(...t) {
        let {
            delegate: e
        } = Bs;
        return (e ? .cancelAnimationFrame || cancelAnimationFrame)(...t)
    },
    delegate: void 0
};
var D_ = ks(t => function() {
    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed"
});
var Me = (() => {
        class t extends ie {
            constructor() {
                super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null
            }
            lift(n) {
                let r = new Cl(this, this);
                return r.operator = n, r
            }
            _throwIfClosed() {
                if (this.closed) throw new D_
            }
            next(n) {
                Ls(() => {
                    if (this._throwIfClosed(), !this.isStopped) {
                        this.currentObservers || (this.currentObservers = Array.from(this.observers));
                        for (let r of this.currentObservers) r.next(n)
                    }
                })
            }
            error(n) {
                Ls(() => {
                    if (this._throwIfClosed(), !this.isStopped) {
                        this.hasError = this.isStopped = !0, this.thrownError = n;
                        let {
                            observers: r
                        } = this;
                        for (; r.length;) r.shift().error(n)
                    }
                })
            }
            complete() {
                Ls(() => {
                    if (this._throwIfClosed(), !this.isStopped) {
                        this.isStopped = !0;
                        let {
                            observers: n
                        } = this;
                        for (; n.length;) n.shift().complete()
                    }
                })
            }
            unsubscribe() {
                this.isStopped = this.closed = !0, this.observers = this.currentObservers = null
            }
            get observed() {
                var n;
                return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0
            }
            _trySubscribe(n) {
                return this._throwIfClosed(), super._trySubscribe(n)
            }
            _subscribe(n) {
                return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n)
            }
            _innerSubscribe(n) {
                let {
                    hasError: r,
                    isStopped: i,
                    observers: s
                } = this;
                return r || i ? ep : (this.currentObservers = null, s.push(n), new Oe(() => {
                    this.currentObservers = null, Ri(s, n)
                }))
            }
            _checkFinalizedStatuses(n) {
                let {
                    hasError: r,
                    thrownError: i,
                    isStopped: s
                } = this;
                r ? n.error(i) : s && n.complete()
            }
            asObservable() {
                let n = new ie;
                return n.source = this, n
            }
        }
        return t.create = (e, n) => new Cl(e, n), t
    })(),
    Cl = class extends Me {
        constructor(e, n) {
            super(), this.destination = e, this.source = n
        }
        next(e) {
            var n, r;
            (r = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || r === void 0 || r.call(n, e)
        }
        error(e) {
            var n, r;
            (r = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || r === void 0 || r.call(n, e)
        }
        complete() {
            var e, n;
            (n = (e = this.destination) === null || e === void 0 ? void 0 : e.complete) === null || n === void 0 || n.call(e)
        }
        _subscribe(e) {
            var n, r;
            return (r = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(e)) !== null && r !== void 0 ? r : ep
        }
    };
var Ze = class extends Me {
    constructor(e) {
        super(), this._value = e
    }
    get value() {
        return this.getValue()
    }
    _subscribe(e) {
        let n = super._subscribe(e);
        return !n.closed && e.next(this._value), n
    }
    getValue() {
        let {
            hasError: e,
            thrownError: n,
            _value: r
        } = this;
        if (e) throw n;
        return this._throwIfClosed(), r
    }
    next(e) {
        super.next(this._value = e)
    }
};
var ca = {
    now() {
        return (ca.delegate || Date).now()
    },
    delegate: void 0
};
var Gr = class extends Me {
    constructor(e = 1 / 0, n = 1 / 0, r = ca) {
        super(), this._bufferSize = e, this._windowTime = n, this._timestampProvider = r, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = n === 1 / 0, this._bufferSize = Math.max(1, e), this._windowTime = Math.max(1, n)
    }
    next(e) {
        let {
            isStopped: n,
            _buffer: r,
            _infiniteTimeWindow: i,
            _timestampProvider: s,
            _windowTime: o
        } = this;
        n || (r.push(e), !i && r.push(s.now() + o)), this._trimBuffer(), super.next(e)
    }
    _subscribe(e) {
        this._throwIfClosed(), this._trimBuffer();
        let n = this._innerSubscribe(e),
            {
                _infiniteTimeWindow: r,
                _buffer: i
            } = this,
            s = i.slice();
        for (let o = 0; o < s.length && !e.closed; o += r ? 1 : 2) e.next(s[o]);
        return this._checkFinalizedStatuses(e), n
    }
    _trimBuffer() {
        let {
            _bufferSize: e,
            _timestampProvider: n,
            _buffer: r,
            _infiniteTimeWindow: i
        } = this, s = (i ? 1 : 2) * e;
        if (e < 1 / 0 && s < r.length && r.splice(0, r.length - s), !i) {
            let o = n.now(),
                a = 0;
            for (let c = 1; c < r.length && r[c] <= o; c += 2) a = c;
            a && r.splice(0, a + 1)
        }
    }
};
var Sl = class extends Oe {
    constructor(e, n) {
        super()
    }
    schedule(e, n = 0) {
        return this
    }
};
var la = {
    setInterval(t, e, ...n) {
        let {
            delegate: r
        } = la;
        return r ? .setInterval ? r.setInterval(t, e, ...n) : setInterval(t, e, ...n)
    },
    clearInterval(t) {
        let {
            delegate: e
        } = la;
        return (e ? .clearInterval || clearInterval)(t)
    },
    delegate: void 0
};
var Gn = class extends Sl {
    constructor(e, n) {
        super(e, n), this.scheduler = e, this.work = n, this.pending = !1
    }
    schedule(e, n = 0) {
        var r;
        if (this.closed) return this;
        this.state = e;
        let i = this.id,
            s = this.scheduler;
        return i != null && (this.id = this.recycleAsyncId(s, i, n)), this.pending = !0, this.delay = n, this.id = (r = this.id) !== null && r !== void 0 ? r : this.requestAsyncId(s, this.id, n), this
    }
    requestAsyncId(e, n, r = 0) {
        return la.setInterval(e.flush.bind(e, this), r)
    }
    recycleAsyncId(e, n, r = 0) {
        if (r != null && this.delay === r && this.pending === !1) return n;
        n != null && la.clearInterval(n)
    }
    execute(e, n) {
        if (this.closed) return new Error("executing a cancelled action");
        this.pending = !1;
        let r = this._execute(e, n);
        if (r) return r;
        this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
    }
    _execute(e, n) {
        let r = !1,
            i;
        try {
            this.work(e)
        } catch (s) {
            r = !0, i = s || new Error("Scheduled action threw falsy error")
        }
        if (r) return this.unsubscribe(), i
    }
    unsubscribe() {
        if (!this.closed) {
            let {
                id: e,
                scheduler: n
            } = this, {
                actions: r
            } = n;
            this.work = this.state = this.scheduler = null, this.pending = !1, Ri(r, this), e != null && (this.id = this.recycleAsyncId(n, e, null)), this.delay = null, super.unsubscribe()
        }
    }
};
var NA = 1,
    lp, up = {};

function E_(t) {
    return t in up ? (delete up[t], !0) : !1
}
var C_ = {
    setImmediate(t) {
        let e = NA++;
        return up[e] = !0, lp || (lp = Promise.resolve()), lp.then(() => E_(e) && t()), e
    },
    clearImmediate(t) {
        E_(t)
    }
};
var {
    setImmediate: RA,
    clearImmediate: OA
} = C_, ua = {
    setImmediate(...t) {
        let {
            delegate: e
        } = ua;
        return (e ? .setImmediate || RA)(...t)
    },
    clearImmediate(t) {
        let {
            delegate: e
        } = ua;
        return (e ? .clearImmediate || OA)(t)
    },
    delegate: void 0
};
var Ml = class extends Gn {
    constructor(e, n) {
        super(e, n), this.scheduler = e, this.work = n
    }
    requestAsyncId(e, n, r = 0) {
        return r !== null && r > 0 ? super.requestAsyncId(e, n, r) : (e.actions.push(this), e._scheduled || (e._scheduled = ua.setImmediate(e.flush.bind(e, void 0))))
    }
    recycleAsyncId(e, n, r = 0) {
        var i;
        if (r != null ? r > 0 : this.delay > 0) return super.recycleAsyncId(e, n, r);
        let {
            actions: s
        } = e;
        n != null && ((i = s[s.length - 1]) === null || i === void 0 ? void 0 : i.id) !== n && (ua.clearImmediate(n), e._scheduled === n && (e._scheduled = void 0))
    }
};
var zs = class t {
    constructor(e, n = t.now) {
        this.schedulerActionCtor = e, this.now = n
    }
    schedule(e, n = 0, r) {
        return new this.schedulerActionCtor(this, e).schedule(r, n)
    }
};
zs.now = ca.now;
var Zn = class extends zs {
    constructor(e, n = zs.now) {
        super(e, n), this.actions = [], this._active = !1
    }
    flush(e) {
        let {
            actions: n
        } = this;
        if (this._active) {
            n.push(e);
            return
        }
        let r;
        this._active = !0;
        do
            if (r = e.execute(e.state, e.delay)) break; while (e = n.shift());
        if (this._active = !1, r) {
            for (; e = n.shift();) e.unsubscribe();
            throw r
        }
    }
};
var Il = class extends Zn {
    flush(e) {
        this._active = !0;
        let n = this._scheduled;
        this._scheduled = void 0;
        let {
            actions: r
        } = this, i;
        e = e || r.shift();
        do
            if (i = e.execute(e.state, e.delay)) break; while ((e = r[0]) && e.id === n && r.shift());
        if (this._active = !1, i) {
            for (;
                (e = r[0]) && e.id === n && r.shift();) e.unsubscribe();
            throw i
        }
    }
};
var Tl = new Il(Ml);
var dp = new Zn(Gn),
    S_ = dp;
var xl = class extends Gn {
    constructor(e, n) {
        super(e, n), this.scheduler = e, this.work = n
    }
    schedule(e, n = 0) {
        return n > 0 ? super.schedule(e, n) : (this.delay = n, this.state = e, this.scheduler.flush(this), this)
    }
    execute(e, n) {
        return n > 0 || this.closed ? super.execute(e, n) : this._execute(e, n)
    }
    requestAsyncId(e, n, r = 0) {
        return r != null && r > 0 || r == null && this.delay > 0 ? super.requestAsyncId(e, n, r) : (e.flush(this), 0)
    }
};
var Al = class extends Zn {};
var Nl = new Al(xl);
var Rl = class extends Gn {
    constructor(e, n) {
        super(e, n), this.scheduler = e, this.work = n
    }
    requestAsyncId(e, n, r = 0) {
        return r !== null && r > 0 ? super.requestAsyncId(e, n, r) : (e.actions.push(this), e._scheduled || (e._scheduled = Bs.requestAnimationFrame(() => e.flush(void 0))))
    }
    recycleAsyncId(e, n, r = 0) {
        var i;
        if (r != null ? r > 0 : this.delay > 0) return super.recycleAsyncId(e, n, r);
        let {
            actions: s
        } = e;
        n != null && ((i = s[s.length - 1]) === null || i === void 0 ? void 0 : i.id) !== n && (Bs.cancelAnimationFrame(n), e._scheduled = void 0)
    }
};
var Ol = class extends Zn {
    flush(e) {
        this._active = !0;
        let n = this._scheduled;
        this._scheduled = void 0;
        let {
            actions: r
        } = this, i;
        e = e || r.shift();
        do
            if (i = e.execute(e.state, e.delay)) break; while ((e = r[0]) && e.id === n && r.shift());
        if (this._active = !1, i) {
            for (;
                (e = r[0]) && e.id === n && r.shift();) e.unsubscribe();
            throw i
        }
    }
};
var hp = new Ol(Rl);
var Ye = new ie(t => t.complete());

function Fl(t) {
    return t && J(t.schedule)
}

function fp(t) {
    return t[t.length - 1]
}

function $s(t) {
    return J(fp(t)) ? t.pop() : void 0
}

function Qn(t) {
    return Fl(fp(t)) ? t.pop() : void 0
}

function M_(t, e) {
    return typeof fp(t) == "number" ? t.pop() : e
}

function T_(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        })
    }
    return new(n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                l(r.next(u))
            } catch (d) {
                o(d)
            }
        }

        function c(u) {
            try {
                l(r.throw(u))
            } catch (d) {
                o(d)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(a, c)
        }
        l((r = r.apply(t, e || [])).next())
    })
}

function I_(t) {
    var e = typeof Symbol == "function" && Symbol.iterator,
        n = e && t[e],
        r = 0;
    if (n) return n.call(t);
    if (t && typeof t.length == "number") return {
        next: function() {
            return t && r >= t.length && (t = void 0), {
                value: t && t[r++],
                done: !t
            }
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function Pi(t) {
    return this instanceof Pi ? (this.v = t, this) : new Pi(t)
}

function x_(t, e, n) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var r = n.apply(t, e || []),
        i, s = [];
    return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
        return this
    }, i;

    function o(h) {
        r[h] && (i[h] = function(f) {
            return new Promise(function(p, g) {
                s.push([h, f, p, g]) > 1 || a(h, f)
            })
        })
    }

    function a(h, f) {
        try {
            c(r[h](f))
        } catch (p) {
            d(s[0][3], p)
        }
    }

    function c(h) {
        h.value instanceof Pi ? Promise.resolve(h.value.v).then(l, u) : d(s[0][2], h)
    }

    function l(h) {
        a("next", h)
    }

    function u(h) {
        a("throw", h)
    }

    function d(h, f) {
        h(f), s.shift(), s.length && a(s[0][0], s[0][1])
    }
}

function A_(t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator],
        n;
    return e ? e.call(t) : (t = typeof I_ == "function" ? I_(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
        return this
    }, n);

    function r(s) {
        n[s] = t[s] && function(o) {
            return new Promise(function(a, c) {
                o = t[s](o), i(a, c, o.done, o.value)
            })
        }
    }

    function i(s, o, a, c) {
        Promise.resolve(c).then(function(l) {
            s({
                value: l,
                done: a
            })
        }, o)
    }
}
var Ws = t => t && typeof t.length == "number" && typeof t != "function";

function kl(t) {
    return J(t ? .then)
}

function Pl(t) {
    return J(t[Vs])
}

function Ll(t) {
    return Symbol.asyncIterator && J(t ? .[Symbol.asyncIterator])
}

function Vl(t) {
    return new TypeError(`You provided ${t!==null&&typeof t=="object"?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)
}

function FA() {
    return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator
}
var Ul = FA();

function jl(t) {
    return J(t ? .[Ul])
}

function Bl(t) {
    return x_(this, arguments, function*() {
        let n = t.getReader();
        try {
            for (;;) {
                let {
                    value: r,
                    done: i
                } = yield Pi(n.read());
                if (i) return yield Pi(void 0);
                yield yield Pi(r)
            }
        } finally {
            n.releaseLock()
        }
    })
}

function zl(t) {
    return J(t ? .getReader)
}

function Ie(t) {
    if (t instanceof ie) return t;
    if (t != null) {
        if (Pl(t)) return kA(t);
        if (Ws(t)) return PA(t);
        if (kl(t)) return LA(t);
        if (Ll(t)) return N_(t);
        if (jl(t)) return VA(t);
        if (zl(t)) return UA(t)
    }
    throw Vl(t)
}

function kA(t) {
    return new ie(e => {
        let n = t[Vs]();
        if (J(n.subscribe)) return n.subscribe(e);
        throw new TypeError("Provided object does not correctly implement Symbol.observable")
    })
}

function PA(t) {
    return new ie(e => {
        for (let n = 0; n < t.length && !e.closed; n++) e.next(t[n]);
        e.complete()
    })
}

function LA(t) {
    return new ie(e => {
        t.then(n => {
            e.closed || (e.next(n), e.complete())
        }, n => e.error(n)).then(null, Dl)
    })
}

function VA(t) {
    return new ie(e => {
        for (let n of t)
            if (e.next(n), e.closed) return;
        e.complete()
    })
}

function N_(t) {
    return new ie(e => {
        jA(t, e).catch(n => e.error(n))
    })
}

function UA(t) {
    return N_(Bl(t))
}

function jA(t, e) {
    var n, r, i, s;
    return T_(this, void 0, void 0, function*() {
        try {
            for (n = A_(t); r = yield n.next(), !r.done;) {
                let o = r.value;
                if (e.next(o), e.closed) return
            }
        } catch (o) {
            i = {
                error: o
            }
        } finally {
            try {
                r && !r.done && (s = n.return) && (yield s.call(n))
            } finally {
                if (i) throw i.error
            }
        }
        e.complete()
    })
}

function Bt(t, e, n, r = 0, i = !1) {
    let s = e.schedule(function() {
        n(), i ? t.add(this.schedule(null, r)) : this.unsubscribe()
    }, r);
    if (t.add(s), !i) return s
}

function Li(t, e = 0) {
    return ne((n, r) => {
        n.subscribe(te(r, i => Bt(r, t, () => r.next(i), e), () => Bt(r, t, () => r.complete(), e), i => Bt(r, t, () => r.error(i), e)))
    })
}

function $l(t, e = 0) {
    return ne((n, r) => {
        r.add(t.schedule(() => n.subscribe(r), e))
    })
}

function R_(t, e) {
    return Ie(t).pipe($l(e), Li(e))
}

function O_(t, e) {
    return Ie(t).pipe($l(e), Li(e))
}

function F_(t, e) {
    return new ie(n => {
        let r = 0;
        return e.schedule(function() {
            r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule())
        })
    })
}

function k_(t, e) {
    return new ie(n => {
        let r;
        return Bt(n, e, () => {
            r = t[Ul](), Bt(n, e, () => {
                let i, s;
                try {
                    ({
                        value: i,
                        done: s
                    } = r.next())
                } catch (o) {
                    n.error(o);
                    return
                }
                s ? n.complete() : n.next(i)
            }, 0, !0)
        }), () => J(r ? .return) && r.return()
    })
}

function Wl(t, e) {
    if (!t) throw new Error("Iterable cannot be null");
    return new ie(n => {
        Bt(n, e, () => {
            let r = t[Symbol.asyncIterator]();
            Bt(n, e, () => {
                r.next().then(i => {
                    i.done ? n.complete() : n.next(i.value)
                })
            }, 0, !0)
        })
    })
}

function P_(t, e) {
    return Wl(Bl(t), e)
}

function da(t, e) {
    if (t != null) {
        if (Pl(t)) return R_(t, e);
        if (Ws(t)) return F_(t, e);
        if (kl(t)) return O_(t, e);
        if (Ll(t)) return Wl(t, e);
        if (jl(t)) return k_(t, e);
        if (zl(t)) return P_(t, e)
    }
    throw Vl(t)
}

function le(t, e) {
    return e ? da(t, e) : Ie(t)
}

function k(...t) {
    let e = Qn(t);
    return le(t, e)
}

function Qe(t, e) {
    let n = J(t) ? t : () => t,
        r = i => i.error(n());
    return new ie(e ? i => e.schedule(r, 0, i) : r)
}

function Rt(t) {
    return !!t && (t instanceof ie || J(t.lift) && J(t.subscribe))
}
var Nn = ks(t => function() {
    t(this), this.name = "EmptyError", this.message = "no elements in sequence"
});

function Hl(t, e) {
    let n = typeof e == "object";
    return new Promise((r, i) => {
        let s = new An({
            next: o => {
                r(o), s.unsubscribe()
            },
            error: i,
            complete: () => {
                n ? r(e.defaultValue) : i(new Nn)
            }
        });
        t.subscribe(s)
    })
}

function L_(t) {
    return t instanceof Date && !isNaN(t)
}

function Z(t, e) {
    return ne((n, r) => {
        let i = 0;
        n.subscribe(te(r, s => {
            r.next(t.call(e, s, i++))
        }))
    })
}
var {
    isArray: BA
} = Array;

function zA(t, e) {
    return BA(e) ? t(...e) : t(e)
}

function Zr(t) {
    return Z(e => zA(t, e))
}
var {
    isArray: $A
} = Array, {
    getPrototypeOf: WA,
    prototype: HA,
    keys: GA
} = Object;

function Gl(t) {
    if (t.length === 1) {
        let e = t[0];
        if ($A(e)) return {
            args: e,
            keys: null
        };
        if (ZA(e)) {
            let n = GA(e);
            return {
                args: n.map(r => e[r]),
                keys: n
            }
        }
    }
    return {
        args: t,
        keys: null
    }
}

function ZA(t) {
    return t && typeof t == "object" && WA(t) === HA
}

function Zl(t, e) {
    return t.reduce((n, r, i) => (n[r] = e[i], n), {})
}

function Ot(...t) {
    let e = Qn(t),
        n = $s(t),
        {
            args: r,
            keys: i
        } = Gl(t);
    if (r.length === 0) return le([], e);
    let s = new ie(QA(r, e, i ? o => Zl(i, o) : gt));
    return n ? s.pipe(Zr(n)) : s
}

function QA(t, e, n = gt) {
    return r => {
        V_(e, () => {
            let {
                length: i
            } = t, s = new Array(i), o = i, a = i;
            for (let c = 0; c < i; c++) V_(e, () => {
                let l = le(t[c], e),
                    u = !1;
                l.subscribe(te(r, d => {
                    s[c] = d, u || (u = !0, a--), a || r.next(n(s.slice()))
                }, () => {
                    --o || r.complete()
                }))
            }, r)
        }, r)
    }
}

function V_(t, e, n) {
    t ? Bt(n, t, e) : e()
}

function U_(t, e, n, r, i, s, o, a) {
    let c = [],
        l = 0,
        u = 0,
        d = !1,
        h = () => {
            d && !c.length && !l && e.complete()
        },
        f = g => l < r ? p(g) : c.push(g),
        p = g => {
            s && e.next(g), l++;
            let m = !1;
            Ie(n(g, u++)).subscribe(te(e, y => {
                i ? .(y), s ? f(y) : e.next(y)
            }, () => {
                m = !0
            }, void 0, () => {
                if (m) try {
                    for (l--; c.length && l < r;) {
                        let y = c.shift();
                        o ? Bt(e, o, () => p(y)) : p(y)
                    }
                    h()
                } catch (y) {
                    e.error(y)
                }
            }))
        };
    return t.subscribe(te(e, f, () => {
        d = !0, h()
    })), () => {
        a ? .()
    }
}

function qe(t, e, n = 1 / 0) {
    return J(e) ? qe((r, i) => Z((s, o) => e(r, s, i, o))(Ie(t(r, i))), n) : (typeof e == "number" && (n = e), ne((r, i) => U_(r, i, t, n)))
}

function Qr(t = 1 / 0) {
    return qe(gt, t)
}

function j_() {
    return Qr(1)
}

function Dr(...t) {
    return j_()(le(t, Qn(t)))
}

function mt(t) {
    return new ie(e => {
        Ie(t()).subscribe(e)
    })
}

function ha(...t) {
    let e = $s(t),
        {
            args: n,
            keys: r
        } = Gl(t),
        i = new ie(s => {
            let {
                length: o
            } = n;
            if (!o) {
                s.complete();
                return
            }
            let a = new Array(o),
                c = o,
                l = o;
            for (let u = 0; u < o; u++) {
                let d = !1;
                Ie(n[u]).subscribe(te(s, h => {
                    d || (d = !0, l--), a[u] = h
                }, () => c--, void 0, () => {
                    (!c || !d) && (l || s.next(r ? Zl(r, a) : a), s.complete())
                }))
            }
        });
    return e ? i.pipe(Zr(e)) : i
}
var qA = ["addListener", "removeListener"],
    KA = ["addEventListener", "removeEventListener"],
    YA = ["on", "off"];

function qn(t, e, n, r) {
    if (J(n) && (r = n, n = void 0), r) return qn(t, e, n).pipe(Zr(r));
    let [i, s] = eN(t) ? KA.map(o => a => t[o](e, a, n)) : JA(t) ? qA.map(B_(t, e)) : XA(t) ? YA.map(B_(t, e)) : [];
    if (!i && Ws(t)) return qe(o => qn(o, e, n))(Ie(t));
    if (!i) throw new TypeError("Invalid event target");
    return new ie(o => {
        let a = (...c) => o.next(1 < c.length ? c : c[0]);
        return i(a), () => s(a)
    })
}

function B_(t, e) {
    return n => r => t[n](e, r)
}

function JA(t) {
    return J(t.addListener) && J(t.removeListener)
}

function XA(t) {
    return J(t.on) && J(t.off)
}

function eN(t) {
    return J(t.addEventListener) && J(t.removeEventListener)
}

function fa(t, e, n) {
    return n ? fa(t, e).pipe(Zr(n)) : new ie(r => {
        let i = (...o) => r.next(o.length === 1 ? o[0] : o),
            s = t(i);
        return J(e) ? () => e(i, s) : void 0
    })
}

function z_(t = 0, e, n = S_) {
    let r = -1;
    return e != null && (Fl(e) ? n = e : r = e), new ie(i => {
        let s = L_(t) ? +t - n.now() : t;
        s < 0 && (s = 0);
        let o = 0;
        return n.schedule(function() {
            i.closed || (i.next(o++), 0 <= r ? this.schedule(void 0, r) : i.complete())
        }, s)
    })
}

function pp(t = 0, e = dp) {
    return t < 0 && (t = 0), z_(t, t, e)
}

function Hs(...t) {
    let e = Qn(t),
        n = M_(t, 1 / 0),
        r = t;
    return r.length ? r.length === 1 ? Ie(r[0]) : Qr(n)(le(r, e)) : Ye
}

function Fe(t, e) {
    return ne((n, r) => {
        let i = 0;
        n.subscribe(te(r, s => t.call(e, s, i++) && r.next(s)))
    })
}

function yt(t) {
    return ne((e, n) => {
        let r = null,
            i = !1,
            s;
        r = e.subscribe(te(n, void 0, void 0, o => {
            s = Ie(t(o, yt(t)(e))), r ? (r.unsubscribe(), r = null, s.subscribe(n)) : i = !0
        })), i && (r.unsubscribe(), r = null, s.subscribe(n))
    })
}

function $_(t, e, n, r, i) {
    return (s, o) => {
        let a = n,
            c = e,
            l = 0;
        s.subscribe(te(o, u => {
            let d = l++;
            c = a ? t(c, u, d) : (a = !0, u), r && o.next(c)
        }, i && (() => {
            a && o.next(c), o.complete()
        })))
    }
}

function nt(t, e) {
    return J(e) ? qe(t, e, 1) : qe(t, 1)
}

function qr(t) {
    return ne((e, n) => {
        let r = !1;
        e.subscribe(te(n, i => {
            r = !0, n.next(i)
        }, () => {
            r || n.next(t), n.complete()
        }))
    })
}

function vt(t) {
    return t <= 0 ? () => Ye : ne((e, n) => {
        let r = 0;
        e.subscribe(te(n, i => {
            ++r <= t && (n.next(i), t <= r && n.complete())
        }))
    })
}

function gp(t) {
    return Z(() => t)
}

function mp(t, e = gt) {
    return t = t ? ? tN, ne((n, r) => {
        let i, s = !0;
        n.subscribe(te(r, o => {
            let a = e(o);
            (s || !t(i, a)) && (s = !1, i = a, r.next(o))
        }))
    })
}

function tN(t, e) {
    return t === e
}

function Ql(t = nN) {
    return ne((e, n) => {
        let r = !1;
        e.subscribe(te(n, i => {
            r = !0, n.next(i)
        }, () => r ? n.complete() : n.error(t())))
    })
}

function nN() {
    return new Nn
}

function Ft(t) {
    return ne((e, n) => {
        try {
            e.subscribe(n)
        } finally {
            n.add(t)
        }
    })
}

function kt(t, e) {
    let n = arguments.length >= 2;
    return r => r.pipe(t ? Fe((i, s) => t(i, s, r)) : gt, vt(1), n ? qr(e) : Ql(() => new Nn))
}

function Gs(t) {
    return t <= 0 ? () => Ye : ne((e, n) => {
        let r = [];
        e.subscribe(te(n, i => {
            r.push(i), t < r.length && r.shift()
        }, () => {
            for (let i of r) n.next(i);
            n.complete()
        }, void 0, () => {
            r = null
        }))
    })
}

function yp(t, e) {
    let n = arguments.length >= 2;
    return r => r.pipe(t ? Fe((i, s) => t(i, s, r)) : gt, Gs(1), n ? qr(e) : Ql(() => new Nn))
}

function ql() {
    return ne((t, e) => {
        let n, r = !1;
        t.subscribe(te(e, i => {
            let s = n;
            n = i, r && e.next([s, i]), r = !0
        }))
    })
}

function vp(t, e) {
    return ne($_(t, e, arguments.length >= 2, !0))
}

function pa(t = {}) {
    let {
        connector: e = () => new Me,
        resetOnError: n = !0,
        resetOnComplete: r = !0,
        resetOnRefCountZero: i = !0
    } = t;
    return s => {
        let o, a, c, l = 0,
            u = !1,
            d = !1,
            h = () => {
                a ? .unsubscribe(), a = void 0
            },
            f = () => {
                h(), o = c = void 0, u = d = !1
            },
            p = () => {
                let g = o;
                f(), g ? .unsubscribe()
            };
        return ne((g, m) => {
            l++, !d && !u && h();
            let y = c = c ? ? e();
            m.add(() => {
                l--, l === 0 && !d && !u && (a = wp(p, i))
            }), y.subscribe(m), !o && l > 0 && (o = new An({
                next: E => y.next(E),
                error: E => {
                    d = !0, h(), a = wp(f, n, E), y.error(E)
                },
                complete: () => {
                    u = !0, h(), a = wp(f, r), y.complete()
                }
            }), Ie(g).subscribe(o))
        })(s)
    }
}

function wp(t, e, ...n) {
    if (e === !0) {
        t();
        return
    }
    if (e === !1) return;
    let r = new An({
        next: () => {
            r.unsubscribe(), t()
        }
    });
    return Ie(e(...n)).subscribe(r)
}

function Zs(t, e, n) {
    let r, i = !1;
    return t && typeof t == "object" ? {
        bufferSize: r = 1 / 0,
        windowTime: e = 1 / 0,
        refCount: i = !1,
        scheduler: n
    } = t : r = t ? ? 1 / 0, pa({
        connector: () => new Gr(r, e, n),
        resetOnError: !0,
        resetOnComplete: !1,
        resetOnRefCountZero: i
    })
}

function _p(...t) {
    let e = Qn(t);
    return ne((n, r) => {
        (e ? Dr(t, n, e) : Dr(t, n)).subscribe(r)
    })
}

function Je(t, e) {
    return ne((n, r) => {
        let i = null,
            s = 0,
            o = !1,
            a = () => o && !i && r.complete();
        n.subscribe(te(r, c => {
            i ? .unsubscribe();
            let l = 0,
                u = s++;
            Ie(t(c, u)).subscribe(i = te(r, d => r.next(e ? e(c, d, u, l++) : d), () => {
                i = null, a()
            }))
        }, () => {
            o = !0, a()
        }))
    })
}

function Rn(t) {
    return ne((e, n) => {
        Ie(t).subscribe(te(n, () => n.complete(), Oi)), !n.closed && e.subscribe(n)
    })
}

function ve(t, e, n) {
    let r = J(t) || e || n ? {
        next: t,
        error: e,
        complete: n
    } : t;
    return r ? ne((i, s) => {
        var o;
        (o = r.subscribe) === null || o === void 0 || o.call(r);
        let a = !0;
        i.subscribe(te(s, c => {
            var l;
            (l = r.next) === null || l === void 0 || l.call(r, c), s.next(c)
        }, () => {
            var c;
            a = !1, (c = r.complete) === null || c === void 0 || c.call(r), s.complete()
        }, c => {
            var l;
            a = !1, (l = r.error) === null || l === void 0 || l.call(r, c), s.error(c)
        }, () => {
            var c, l;
            a && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (l = r.finalize) === null || l === void 0 || l.call(r)
        }))
    }) : gt
}

function Qs(...t) {
    let e = $s(t);
    return ne((n, r) => {
        let i = t.length,
            s = new Array(i),
            o = t.map(() => !1),
            a = !1;
        for (let c = 0; c < i; c++) Ie(t[c]).subscribe(te(r, l => {
            s[c] = l, !a && !o[c] && (o[c] = !0, (a = o.every(gt)) && (o = null))
        }, Oi));
        n.subscribe(te(r, c => {
            if (a) {
                let l = [c, ...s];
                r.next(e ? e(...l) : l)
            }
        }))
    })
}
var Tb = "https://g.co/ng/security#xss",
    S = class extends Error {
        constructor(e, n) {
            super(Tu(e, n)), this.code = e
        }
    };

function Tu(t, e) {
    return `${`NG0${Math.abs(t)}`}${e?": "+e:""}`
}

function xa(t) {
    return {
        toString: t
    }.toString()
}
var Kl = "__parameters__";

function rN(t) {
    return function(...n) {
        if (t) {
            let r = t(...n);
            for (let i in r) this[i] = r[i]
        }
    }
}

function xb(t, e, n) {
    return xa(() => {
        let r = rN(e);

        function i(...s) {
            if (this instanceof i) return r.apply(this, s), this;
            let o = new i(...s);
            return a.annotation = o, a;

            function a(c, l, u) {
                let d = c.hasOwnProperty(Kl) ? c[Kl] : Object.defineProperty(c, Kl, {
                    value: []
                })[Kl];
                for (; d.length <= u;) d.push(null);
                return (d[u] = d[u] || []).push(o), c
            }
        }
        return n && (i.prototype = Object.create(n.prototype)), i.prototype.ngMetadataName = t, i.annotationCls = i, i
    })
}
var Kt = globalThis;

function Ae(t) {
    for (let e in t)
        if (t[e] === Ae) return e;
    throw Error("Could not find renamed property on target object.")
}

function iN(t, e) {
    for (let n in e) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n])
}

function Lt(t) {
    if (typeof t == "string") return t;
    if (Array.isArray(t)) return "[" + t.map(Lt).join(", ") + "]";
    if (t == null) return "" + t;
    if (t.overriddenName) return `${t.overriddenName}`;
    if (t.name) return `${t.name}`;
    let e = t.toString();
    if (e == null) return "" + e;
    let n = e.indexOf(`
`);
    return n === -1 ? e : e.substring(0, n)
}

function W_(t, e) {
    return t == null || t === "" ? e === null ? "" : e : e == null || e === "" ? t : t + " " + e
}
var sN = Ae({
    __forward_ref__: Ae
});

function uo(t) {
    return t.__forward_ref__ = uo, t.toString = function() {
        return Lt(this())
    }, t
}

function Pt(t) {
    return Ab(t) ? t() : t
}

function Ab(t) {
    return typeof t == "function" && t.hasOwnProperty(sN) && t.__forward_ref__ === uo
}

function I(t) {
    return {
        token: t.token,
        providedIn: t.providedIn || null,
        factory: t.factory,
        value: void 0
    }
}

function Te(t) {
    return {
        providers: t.providers || [],
        imports: t.imports || []
    }
}

function xu(t) {
    return H_(t, Rb) || H_(t, Ob)
}

function Nb(t) {
    return xu(t) !== null
}

function H_(t, e) {
    return t.hasOwnProperty(e) ? t[e] : null
}

function oN(t) {
    let e = t && (t[Rb] || t[Ob]);
    return e || null
}

function G_(t) {
    return t && (t.hasOwnProperty(Z_) || t.hasOwnProperty(aN)) ? t[Z_] : null
}
var Rb = Ae({\
        u0275prov: Ae
    }),
    Z_ = Ae({\
        u0275inj: Ae
    }),
    Ob = Ae({
        ngInjectableDef: Ae
    }),
    aN = Ae({
        ngInjectorDef: Ae
    }),
    R = class {
        constructor(e, n) {
            this._desc = e, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, typeof n == "number" ? this.__NG_ELEMENT_ID__ = n : n !== void 0 && (this.\u0275prov = I({
                token: this,
                providedIn: n.providedIn || "root",
                factory: n.factory
            }))
        }
        get multi() {
            return this
        }
        toString() {
            return `InjectionToken ${this._desc}`
        }
    };

function Fb(t) {
    return t && !!t.\u0275providers
}
var cN = Ae({\
        u0275cmp: Ae
    }),
    lN = Ae({\
        u0275dir: Ae
    }),
    uN = Ae({\
        u0275pipe: Ae
    }),
    dN = Ae({\
        u0275mod: Ae
    }),
    ou = Ae({\
        u0275fac: Ae
    }),
    ga = Ae({
        __NG_ELEMENT_ID__: Ae
    }),
    Q_ = Ae({
        __NG_ENV_ID__: Ae
    });

function Au(t) {
    return typeof t == "string" ? t : t == null ? "" : String(t)
}

function hN(t) {
    return typeof t == "function" ? t.name || t.toString() : typeof t == "object" && t != null && typeof t.type == "function" ? t.type.name || t.type.toString() : Au(t)
}

function fN(t, e) {
    let n = e ? `. Dependency path: ${e.join(" > ")} > ${t}` : "";
    throw new S(-200, t)
}

function Ug(t, e) {
    throw new S(-201, !1)
}
var ue = function(t) {
        return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t
    }(ue || {}),
    Pp;

function kb() {
    return Pp
}

function zt(t) {
    let e = Pp;
    return Pp = t, e
}

function Pb(t, e, n) {
    let r = xu(t);
    if (r && r.providedIn == "root") return r.value === void 0 ? r.value = r.factory() : r.value;
    if (n & ue.Optional) return null;
    if (e !== void 0) return e;
    Ug(t, "Injector")
}
var pN = {},
    ya = pN,
    Lp = "__NG_DI_FLAG__",
    au = "ngTempTokenPath",
    gN = "ngTokenPath",
    mN = /\n/gm,
    yN = "\u0275",
    q_ = "__source",
    Xs;

function vN() {
    return Xs
}

function Kr(t) {
    let e = Xs;
    return Xs = t, e
}

function wN(t, e = ue.Default) {
    if (Xs === void 0) throw new S(-203, !1);
    return Xs === null ? Pb(t, void 0, e) : Xs.get(t, e & ue.Optional ? null : void 0, e)
}

function C(t, e = ue.Default) {
    return (kb() || wN)(Pt(t), e)
}

function M(t, e = ue.Default) {
    return C(t, Nu(e))
}

function Nu(t) {
    return typeof t > "u" || typeof t == "number" ? t : 0 | (t.optional && 8) | (t.host && 1) | (t.self && 2) | (t.skipSelf && 4)
}

function Vp(t) {
    let e = [];
    for (let n = 0; n < t.length; n++) {
        let r = Pt(t[n]);
        if (Array.isArray(r)) {
            if (r.length === 0) throw new S(900, !1);
            let i, s = ue.Default;
            for (let o = 0; o < r.length; o++) {
                let a = r[o],
                    c = _N(a);
                typeof c == "number" ? c === -1 ? i = a.token : s |= c : i = a
            }
            e.push(C(i, s))
        } else e.push(C(r))
    }
    return e
}

function Lb(t, e) {
    return t[Lp] = e, t.prototype[Lp] = e, t
}

function _N(t) {
    return t[Lp]
}

function bN(t, e, n, r) {
    let i = t[au];
    throw e[q_] && i.unshift(e[q_]), t.message = DN(`
` + t.message, i, n, r), t[gN] = i, t[au] = null, t
}

function DN(t, e, n, r = null) {
    t = t && t.charAt(0) === `
` && t.charAt(1) == yN ? t.slice(2) : t;
    let i = Lt(e);
    if (Array.isArray(e)) i = e.map(Lt).join(" -> ");
    else if (typeof e == "object") {
        let s = [];
        for (let o in e)
            if (e.hasOwnProperty(o)) {
                let a = e[o];
                s.push(o + ":" + (typeof a == "string" ? JSON.stringify(a) : Lt(a)))
            }
        i = `{${s.join(", ")}}`
    }
    return `${n}${r?"("+r+")":""}[${i}]: ${t.replace(mN,`
  `)}`
}
var Sr = Lb(xb("Optional"), 8);
var ho = Lb(xb("SkipSelf"), 4);

function ji(t, e) {
    let n = t.hasOwnProperty(ou);
    return n ? t[ou] : null
}

function EN(t, e, n) {
    if (t.length !== e.length) return !1;
    for (let r = 0; r < t.length; r++) {
        let i = t[r],
            s = e[r];
        if (n && (i = n(i), s = n(s)), s !== i) return !1
    }
    return !0
}

function CN(t) {
    return t.flat(Number.POSITIVE_INFINITY)
}

function jg(t, e) {
    t.forEach(n => Array.isArray(n) ? jg(n, e) : e(n))
}

function Vb(t, e, n) {
    e >= t.length ? t.push(n) : t.splice(e, 0, n)
}

function cu(t, e) {
    return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0]
}

function SN(t, e) {
    let n = [];
    for (let r = 0; r < t; r++) n.push(e);
    return n
}

function MN(t, e, n, r) {
    let i = t.length;
    if (i == e) t.push(n, r);
    else if (i === 1) t.push(r, t[0]), t[0] = n;
    else {
        for (i--, t.push(t[i - 1], t[i]); i > e;) {
            let s = i - 2;
            t[i] = t[s], i--
        }
        t[e] = n, t[e + 1] = r
    }
}

function IN(t, e, n) {
    let r = Aa(t, e);
    return r >= 0 ? t[r | 1] = n : (r = ~r, MN(t, r, e, n)), r
}

function bp(t, e) {
    let n = Aa(t, e);
    if (n >= 0) return t[n | 1]
}

function Aa(t, e) {
    return TN(t, e, 1)
}

function TN(t, e, n) {
    let r = 0,
        i = t.length >> n;
    for (; i !== r;) {
        let s = r + (i - r >> 1),
            o = t[s << n];
        if (e === o) return s << n;
        o > e ? i = s : r = s + 1
    }
    return ~(i << n)
}
var to = {},
    pn = [],
    no = new R(""),
    Ub = new R("", -1),
    jb = new R(""),
    lu = class {
        get(e, n = ya) {
            if (n === ya) {
                let r = new Error(`NullInjectorError: No provider for ${Lt(e)}!`);
                throw r.name = "NullInjectorError", r
            }
            return n
        }
    },
    Bb = function(t) {
        return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t
    }(Bb || {}),
    gn = function(t) {
        return t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t
    }(gn || {}),
    Vt = function(t) {
        return t[t.None = 0] = "None", t[t.SignalBased = 1] = "SignalBased", t[t.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform", t
    }(Vt || {});

function xN(t, e, n) {
    let r = t.length;
    for (;;) {
        let i = t.indexOf(e, n);
        if (i === -1) return i;
        if (i === 0 || t.charCodeAt(i - 1) <= 32) {
            let s = e.length;
            if (i + s === r || t.charCodeAt(i + s) <= 32) return i
        }
        n = i + 1
    }
}

function Up(t, e, n) {
    let r = 0;
    for (; r < n.length;) {
        let i = n[r];
        if (typeof i == "number") {
            if (i !== 0) break;
            r++;
            let s = n[r++],
                o = n[r++],
                a = n[r++];
            t.setAttribute(e, o, a, s)
        } else {
            let s = i,
                o = n[++r];
            NN(s) ? t.setProperty(e, s, o) : t.setAttribute(e, s, o), r++
        }
    }
    return r
}

function AN(t) {
    return t === 3 || t === 4 || t === 6
}

function NN(t) {
    return t.charCodeAt(0) === 64
}

function va(t, e) {
    if (!(e === null || e.length === 0))
        if (t === null || t.length === 0) t = e.slice();
        else {
            let n = -1;
            for (let r = 0; r < e.length; r++) {
                let i = e[r];
                typeof i == "number" ? n = i : n === 0 || (n === -1 || n === 2 ? K_(t, n, i, null, e[++r]) : K_(t, n, i, null, null))
            }
        }
    return t
}

function K_(t, e, n, r, i) {
    let s = 0,
        o = t.length;
    if (e === -1) o = -1;
    else
        for (; s < t.length;) {
            let a = t[s++];
            if (typeof a == "number") {
                if (a === e) {
                    o = -1;
                    break
                } else if (a > e) {
                    o = s - 1;
                    break
                }
            }
        }
    for (; s < t.length;) {
        let a = t[s];
        if (typeof a == "number") break;
        if (a === n) {
            if (r === null) {
                i !== null && (t[s + 1] = i);
                return
            } else if (r === t[s + 1]) {
                t[s + 2] = i;
                return
            }
        }
        s++, r !== null && s++, i !== null && s++
    }
    o !== -1 && (t.splice(o, 0, e), s = o + 1), t.splice(s++, 0, n), r !== null && t.splice(s++, 0, r), i !== null && t.splice(s++, 0, i)
}
var zb = "ng-template";

function RN(t, e, n, r) {
    let i = 0;
    if (r) {
        for (; i < e.length && typeof e[i] == "string"; i += 2)
            if (e[i] === "class" && xN(e[i + 1].toLowerCase(), n, 0) !== -1) return !0
    } else if (Bg(t)) return !1;
    if (i = e.indexOf(1, i), i > -1) {
        let s;
        for (; ++i < e.length && typeof(s = e[i]) == "string";)
            if (s.toLowerCase() === n) return !0
    }
    return !1
}

function Bg(t) {
    return t.type === 4 && t.value !== zb
}

function ON(t, e, n) {
    let r = t.type === 4 && !n ? zb : t.value;
    return e === r
}

function FN(t, e, n) {
    let r = 4,
        i = t.attrs,
        s = i !== null ? LN(i) : 0,
        o = !1;
    for (let a = 0; a < e.length; a++) {
        let c = e[a];
        if (typeof c == "number") {
            if (!o && !On(r) && !On(c)) return !1;
            if (o && On(c)) continue;
            o = !1, r = c | r & 1;
            continue
        }
        if (!o)
            if (r & 4) {
                if (r = 2 | r & 1, c !== "" && !ON(t, c, n) || c === "" && e.length === 1) {
                    if (On(r)) return !1;
                    o = !0
                }
            } else if (r & 8) {
            if (i === null || !RN(t, i, c, n)) {
                if (On(r)) return !1;
                o = !0
            }
        } else {
            let l = e[++a],
                u = kN(c, i, Bg(t), n);
            if (u === -1) {
                if (On(r)) return !1;
                o = !0;
                continue
            }
            if (l !== "") {
                let d;
                if (u > s ? d = "" : d = i[u + 1].toLowerCase(), r & 2 && l !== d) {
                    if (On(r)) return !1;
                    o = !0
                }
            }
        }
    }
    return On(r) || o
}

function On(t) {
    return (t & 1) === 0
}

function kN(t, e, n, r) {
    if (e === null) return -1;
    let i = 0;
    if (r || !n) {
        let s = !1;
        for (; i < e.length;) {
            let o = e[i];
            if (o === t) return i;
            if (o === 3 || o === 6) s = !0;
            else if (o === 1 || o === 2) {
                let a = e[++i];
                for (; typeof a == "string";) a = e[++i];
                continue
            } else {
                if (o === 4) break;
                if (o === 0) {
                    i += 4;
                    continue
                }
            }
            i += s ? 1 : 2
        }
        return -1
    } else return VN(e, t)
}

function $b(t, e, n = !1) {
    for (let r = 0; r < e.length; r++)
        if (FN(t, e[r], n)) return !0;
    return !1
}

function PN(t) {
    let e = t.attrs;
    if (e != null) {
        let n = e.indexOf(5);
        if (!(n & 1)) return e[n + 1]
    }
    return null
}

function LN(t) {
    for (let e = 0; e < t.length; e++) {
        let n = t[e];
        if (AN(n)) return e
    }
    return t.length
}

function VN(t, e) {
    let n = t.indexOf(4);
    if (n > -1)
        for (n++; n < t.length;) {
            let r = t[n];
            if (typeof r == "number") return -1;
            if (r === e) return n;
            n++
        }
    return -1
}

function UN(t, e) {
    e: for (let n = 0; n < e.length; n++) {
        let r = e[n];
        if (t.length === r.length) {
            for (let i = 0; i < t.length; i++)
                if (t[i] !== r[i]) continue e;
            return !0
        }
    }
    return !1
}

function Y_(t, e) {
    return t ? ":not(" + e.trim() + ")" : e
}

function jN(t) {
    let e = t[0],
        n = 1,
        r = 2,
        i = "",
        s = !1;
    for (; n < t.length;) {
        let o = t[n];
        if (typeof o == "string")
            if (r & 2) {
                let a = t[++n];
                i += "[" + o + (a.length > 0 ? '="' + a + '"' : "") + "]"
            } else r & 8 ? i += "." + o : r & 4 && (i += " " + o);
        else i !== "" && !On(o) && (e += Y_(s, i), i = ""), r = o, s = s || !On(r);
        n++
    }
    return i !== "" && (e += Y_(s, i)), e
}

function BN(t) {
    return t.map(jN).join(",")
}

function zN(t) {
    let e = [],
        n = [],
        r = 1,
        i = 2;
    for (; r < t.length;) {
        let s = t[r];
        if (typeof s == "string") i === 2 ? s !== "" && e.push(s, t[++r]) : i === 8 && n.push(s);
        else {
            if (!On(i)) break;
            i = s
        }
        r++
    }
    return {
        attrs: e,
        classes: n
    }
}

function He(t) {
    return xa(() => {
        let e = Qb(t),
            n = Q(_({}, e), {
                decls: t.decls,
                vars: t.vars,
                template: t.template,
                consts: t.consts || null,
                ngContentSelectors: t.ngContentSelectors,
                onPush: t.changeDetection === Bb.OnPush,
                directiveDefs: null,
                pipeDefs: null,
                dependencies: e.standalone && t.dependencies || null,
                getStandaloneInjector: null,
                signals: t.signals ? ? !1,
                data: t.data || {},
                encapsulation: t.encapsulation || gn.Emulated,
                styles: t.styles || pn,
                _: null,
                schemas: t.schemas || null,
                tView: null,
                id: ""
            });
        qb(n);
        let r = t.dependencies;
        return n.directiveDefs = X_(r, !1), n.pipeDefs = X_(r, !0), n.id = HN(n), n
    })
}

function $N(t) {
    return Jr(t) || Wb(t)
}

function WN(t) {
    return t !== null
}

function xe(t) {
    return xa(() => ({
        type: t.type,
        bootstrap: t.bootstrap || pn,
        declarations: t.declarations || pn,
        imports: t.imports || pn,
        exports: t.exports || pn,
        transitiveCompileScopes: null,
        schemas: t.schemas || null,
        id: t.id || null
    }))
}

function J_(t, e) {
    if (t == null) return to;
    let n = {};
    for (let r in t)
        if (t.hasOwnProperty(r)) {
            let i = t[r],
                s, o, a = Vt.None;
            Array.isArray(i) ? (a = i[0], s = i[1], o = i[2] ? ? s) : (s = i, o = i), e ? (n[s] = a !== Vt.None ? [r, a] : r, e[s] = o) : n[s] = r
        }
    return n
}

function et(t) {
    return xa(() => {
        let e = Qb(t);
        return qb(e), e
    })
}

function zg(t) {
    return {
        type: t.type,
        name: t.name,
        factory: null,
        pure: t.pure !== !1,
        standalone: t.standalone === !0,
        onDestroy: t.type.prototype.ngOnDestroy || null
    }
}

function Jr(t) {
    return t[cN] || null
}

function Wb(t) {
    return t[lN] || null
}

function Hb(t) {
    return t[uN] || null
}

function Gb(t) {
    let e = Jr(t) || Wb(t) || Hb(t);
    return e !== null ? e.standalone : !1
}

function Zb(t, e) {
    let n = t[dN] || null;
    if (!n && e === !0) throw new Error(`Type ${Lt(t)} does not have '\u0275mod' property.`);
    return n
}

function Qb(t) {
    let e = {};
    return {
        type: t.type,
        providersResolver: null,
        factory: null,
        hostBindings: t.hostBindings || null,
        hostVars: t.hostVars || 0,
        hostAttrs: t.hostAttrs || null,
        contentQueries: t.contentQueries || null,
        declaredInputs: e,
        inputTransforms: null,
        inputConfig: t.inputs || to,
        exportAs: t.exportAs || null,
        standalone: t.standalone === !0,
        signals: t.signals === !0,
        selectors: t.selectors || pn,
        viewQuery: t.viewQuery || null,
        features: t.features || null,
        setInput: null,
        findHostDirectiveDefs: null,
        hostDirectives: null,
        inputs: J_(t.inputs, e),
        outputs: J_(t.outputs),
        debugInfo: null
    }
}

function qb(t) {
    t.features ? .forEach(e => e(t))
}

function X_(t, e) {
    if (!t) return null;
    let n = e ? Hb : $N;
    return () => (typeof t == "function" ? t() : t).map(r => n(r)).filter(WN)
}

function HN(t) {
    let e = 0,
        n = [t.selectors, t.ngContentSelectors, t.hostVars, t.hostAttrs, t.consts, t.vars, t.decls, t.encapsulation, t.standalone, t.signals, t.exportAs, JSON.stringify(t.inputs), JSON.stringify(t.outputs), Object.getOwnPropertyNames(t.type.prototype), !!t.contentQueries, !!t.viewQuery].join("|");
    for (let i of n) e = Math.imul(31, e) + i.charCodeAt(0) << 0;
    return e += 2147483648, "c" + e
}

function Ru(t) {
    return {\
        u0275providers: t
    }
}

function GN(...t) {
    return {\
        u0275providers: Kb(!0, t),
        \u0275fromNgModule: !0
    }
}

function Kb(t, ...e) {
    let n = [],
        r = new Set,
        i, s = o => {
            n.push(o)
        };
    return jg(e, o => {
        let a = o;
        jp(a, s, [], r) && (i || = [], i.push(a))
    }), i !== void 0 && Yb(i, s), n
}

function Yb(t, e) {
    for (let n = 0; n < t.length; n++) {
        let {
            ngModule: r,
            providers: i
        } = t[n];
        $g(i, s => {
            e(s, r)
        })
    }
}

function jp(t, e, n, r) {
    if (t = Pt(t), !t) return !1;
    let i = null,
        s = G_(t),
        o = !s && Jr(t);
    if (!s && !o) {
        let c = t.ngModule;
        if (s = G_(c), s) i = c;
        else return !1
    } else {
        if (o && !o.standalone) return !1;
        i = t
    }
    let a = r.has(i);
    if (o) {
        if (a) return !1;
        if (r.add(i), o.dependencies) {
            let c = typeof o.dependencies == "function" ? o.dependencies() : o.dependencies;
            for (let l of c) jp(l, e, n, r)
        }
    } else if (s) {
        if (s.imports != null && !a) {
            r.add(i);
            let l;
            try {
                jg(s.imports, u => {
                    jp(u, e, n, r) && (l || = [], l.push(u))
                })
            } finally {}
            l !== void 0 && Yb(l, e)
        }
        if (!a) {
            let l = ji(i) || (() => new i);
            e({
                provide: i,
                useFactory: l,
                deps: pn
            }, i), e({
                provide: jb,
                useValue: i,
                multi: !0
            }, i), e({
                provide: no,
                useValue: () => C(i),
                multi: !0
            }, i)
        }
        let c = s.providers;
        if (c != null && !a) {
            let l = t;
            $g(c, u => {
                e(u, l)
            })
        }
    } else return !1;
    return i !== t && t.providers !== void 0
}

function $g(t, e) {
    for (let n of t) Fb(n) && (n = n.\u0275providers), Array.isArray(n) ? $g(n, e) : e(n)
}
var ZN = Ae({
    provide: String,
    useValue: Ae
});

function Jb(t) {
    return t !== null && typeof t == "object" && ZN in t
}

function QN(t) {
    return !!(t && t.useExisting)
}

function qN(t) {
    return !!(t && t.useFactory)
}

function ro(t) {
    return typeof t == "function"
}

function KN(t) {
    return !!t.useClass
}
var Ou = new R(""),
    eu = {},
    YN = {},
    Dp;

function Wg() {
    return Dp === void 0 && (Dp = new lu), Dp
}
var Ut = class {},
    wa = class extends Ut {
        get destroyed() {
            return this._destroyed
        }
        constructor(e, n, r, i) {
            super(), this.parent = n, this.source = r, this.scopes = i, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, zp(e, o => this.processProvider(o)), this.records.set(Ub, qs(void 0, this)), i.has("environment") && this.records.set(Ut, qs(void 0, this));
            let s = this.records.get(Ou);
            s != null && typeof s.value == "string" && this.scopes.add(s.value), this.injectorDefTypes = new Set(this.get(jb, pn, ue.Self))
        }
        destroy() {
            this.assertNotDestroyed(), this._destroyed = !0;
            let e = pe(null);
            try {
                for (let r of this._ngOnDestroyHooks) r.ngOnDestroy();
                let n = this._onDestroyHooks;
                this._onDestroyHooks = [];
                for (let r of n) r()
            } finally {
                this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), pe(e)
            }
        }
        onDestroy(e) {
            return this.assertNotDestroyed(), this._onDestroyHooks.push(e), () => this.removeOnDestroy(e)
        }
        runInContext(e) {
            this.assertNotDestroyed();
            let n = Kr(this),
                r = zt(void 0),
                i;
            try {
                return e()
            } finally {
                Kr(n), zt(r)
            }
        }
        get(e, n = ya, r = ue.Default) {
            if (this.assertNotDestroyed(), e.hasOwnProperty(Q_)) return e[Q_](this);
            r = Nu(r);
            let i, s = Kr(this),
                o = zt(void 0);
            try {
                if (!(r & ue.SkipSelf)) {
                    let c = this.records.get(e);
                    if (c === void 0) {
                        let l = n1(e) && xu(e);
                        l && this.injectableDefInScope(l) ? c = qs(Bp(e), eu) : c = null, this.records.set(e, c)
                    }
                    if (c != null) return this.hydrate(e, c)
                }
                let a = r & ue.Self ? Wg() : this.parent;
                return n = r & ue.Optional && n === ya ? null : n, a.get(e, n)
            } catch (a) {
                if (a.name === "NullInjectorError") {
                    if ((a[au] = a[au] || []).unshift(Lt(e)), s) throw a;
                    return bN(a, e, "R3InjectorError", this.source)
                } else throw a
            } finally {
                zt(o), Kr(s)
            }
        }
        resolveInjectorInitializers() {
            let e = pe(null),
                n = Kr(this),
                r = zt(void 0),
                i;
            try {
                let s = this.get(no, pn, ue.Self);
                for (let o of s) o()
            } finally {
                Kr(n), zt(r), pe(e)
            }
        }
        toString() {
            let e = [],
                n = this.records;
            for (let r of n.keys()) e.push(Lt(r));
            return `R3Injector[${e.join(", ")}]`
        }
        assertNotDestroyed() {
            if (this._destroyed) throw new S(205, !1)
        }
        processProvider(e) {
            e = Pt(e);
            let n = ro(e) ? e : Pt(e && e.provide),
                r = XN(e);
            if (!ro(e) && e.multi === !0) {
                let i = this.records.get(n);
                i || (i = qs(void 0, eu, !0), i.factory = () => Vp(i.multi), this.records.set(n, i)), n = e, i.multi.push(e)
            }
            this.records.set(n, r)
        }
        hydrate(e, n) {
            let r = pe(null);
            try {
                return n.value === eu && (n.value = YN, n.value = n.factory()), typeof n.value == "object" && n.value && t1(n.value) && this._ngOnDestroyHooks.add(n.value), n.value
            } finally {
                pe(r)
            }
        }
        injectableDefInScope(e) {
            if (!e.providedIn) return !1;
            let n = Pt(e.providedIn);
            return typeof n == "string" ? n === "any" || this.scopes.has(n) : this.injectorDefTypes.has(n)
        }
        removeOnDestroy(e) {
            let n = this._onDestroyHooks.indexOf(e);
            n !== -1 && this._onDestroyHooks.splice(n, 1)
        }
    };

function Bp(t) {
    let e = xu(t),
        n = e !== null ? e.factory : ji(t);
    if (n !== null) return n;
    if (t instanceof R) throw new S(204, !1);
    if (t instanceof Function) return JN(t);
    throw new S(204, !1)
}

function JN(t) {
    if (t.length > 0) throw new S(204, !1);
    let n = oN(t);
    return n !== null ? () => n.factory(t) : () => new t
}

function XN(t) {
    if (Jb(t)) return qs(void 0, t.useValue); {
        let e = Xb(t);
        return qs(e, eu)
    }
}

function Xb(t, e, n) {
    let r;
    if (ro(t)) {
        let i = Pt(t);
        return ji(i) || Bp(i)
    } else if (Jb(t)) r = () => Pt(t.useValue);
    else if (qN(t)) r = () => t.useFactory(...Vp(t.deps || []));
    else if (QN(t)) r = () => C(Pt(t.useExisting));
    else {
        let i = Pt(t && (t.useClass || t.provide));
        if (e1(t)) r = () => new i(...Vp(t.deps));
        else return ji(i) || Bp(i)
    }
    return r
}

function qs(t, e, n = !1) {
    return {
        factory: t,
        value: e,
        multi: n ? [] : void 0
    }
}

function e1(t) {
    return !!t.deps
}

function t1(t) {
    return t !== null && typeof t == "object" && typeof t.ngOnDestroy == "function"
}

function n1(t) {
    return typeof t == "function" || typeof t == "object" && t instanceof R
}

function zp(t, e) {
    for (let n of t) Array.isArray(n) ? zp(n, e) : n && Fb(n) ? zp(n.\u0275providers, e) : e(n)
}

function Ln(t, e) {
    t instanceof wa && t.assertNotDestroyed();
    let n, r = Kr(t),
        i = zt(void 0);
    try {
        return e()
    } finally {
        Kr(r), zt(i)
    }
}

function eD() {
    return kb() !== void 0 || vN() != null
}

function Hg(t) {
    if (!eD()) throw new S(-203, !1)
}

function r1(t) {
    let e = Kt.ng;
    if (e && e.\u0275compilerFacade) return e.\u0275compilerFacade;
    throw new Error("JIT compiler unavailable")
}

function i1(t) {
    return typeof t == "function"
}
var Mr = 0,
    ee = 1,
    X = 2,
    wt = 3,
    Fn = 4,
    Yt = 5,
    io = 6,
    _a = 7,
    It = 8,
    so = 9,
    kn = 10,
    Xe = 11,
    ba = 12,
    eb = 13,
    fo = 14,
    mn = 15,
    Na = 16,
    Ks = 17,
    Er = 18,
    Fu = 19,
    tD = 20,
    Yr = 21,
    Ep = 22,
    Bi = 23,
    $t = 25,
    nD = 1;
var zi = 7,
    uu = 8,
    oo = 9,
    Tt = 10,
    Gg = function(t) {
        return t[t.None = 0] = "None", t[t.HasTransplantedViews = 2] = "HasTransplantedViews", t
    }(Gg || {});

function Vi(t) {
    return Array.isArray(t) && typeof t[nD] == "object"
}

function Ir(t) {
    return Array.isArray(t) && t[nD] === !0
}

function rD(t) {
    return (t.flags & 4) !== 0
}

function ku(t) {
    return t.componentOffset > -1
}

function Zg(t) {
    return (t.flags & 1) === 1
}

function Xr(t) {
    return !!t.template
}

function s1(t) {
    return (t[X] & 512) !== 0
}
var $p = class {
    constructor(e, n, r) {
        this.previousValue = e, this.currentValue = n, this.firstChange = r
    }
    isFirstChange() {
        return this.firstChange
    }
};

function iD(t, e, n, r) {
    e !== null ? e.applyValueToInputSignal(e, r) : t[n] = r
}

function Vn() {
    return sD
}

function sD(t) {
    return t.type.prototype.ngOnChanges && (t.setInput = a1), o1
}
Vn.ngInherit = !0;

function o1() {
    let t = aD(this),
        e = t ? .current;
    if (e) {
        let n = t.previous;
        if (n === to) t.previous = e;
        else
            for (let r in e) n[r] = e[r];
        t.current = null, this.ngOnChanges(e)
    }
}

function a1(t, e, n, r, i) {
    let s = this.declaredInputs[r],
        o = aD(t) || c1(t, {
            previous: to,
            current: null
        }),
        a = o.current || (o.current = {}),
        c = o.previous,
        l = c[s];
    a[s] = new $p(l && l.currentValue, n, c === to), iD(t, e, i, n)
}
var oD = "__ngSimpleChanges__";

function aD(t) {
    return t[oD] || null
}

function c1(t, e) {
    return t[oD] = e
}
var tb = null;
var Kn = function(t, e, n) {
        tb ? .(t, e, n)
    },
    l1 = "svg",
    u1 = "math",
    d1 = !1;

function h1() {
    return d1
}

function Jn(t) {
    for (; Array.isArray(t);) t = t[Mr];
    return t
}

function cD(t, e) {
    return Jn(e[t])
}

function wn(t, e) {
    return Jn(e[t.index])
}

function Qg(t, e) {
    return t.data[e]
}

function f1(t, e) {
    return t[e]
}

function ti(t, e) {
    let n = e[t];
    return Vi(n) ? n : n[Mr]
}

function p1(t) {
    return (t[X] & 4) === 4
}

function qg(t) {
    return (t[X] & 128) === 128
}

function g1(t) {
    return Ir(t[wt])
}

function du(t, e) {
    return e == null ? null : t[e]
}

function lD(t) {
    t[Ks] = 0
}

function m1(t) {
    t[X] & 1024 || (t[X] |= 1024, qg(t) && Da(t))
}

function y1(t, e) {
    for (; t > 0;) e = e[fo], t--;
    return e
}

function Kg(t) {
    return !!(t[X] & 9216 || t[Bi] ? .dirty)
}

function Wp(t) {
    t[kn].changeDetectionScheduler ? .notify(1), Kg(t) ? Da(t) : t[X] & 64 && (h1() ? (t[X] |= 1024, Da(t)) : t[kn].changeDetectionScheduler ? .notify())
}

function Da(t) {
    t[kn].changeDetectionScheduler ? .notify();
    let e = Ea(t);
    for (; e !== null && !(e[X] & 8192 || (e[X] |= 8192, !qg(e)));) e = Ea(e)
}

function uD(t, e) {
    if ((t[X] & 256) === 256) throw new S(911, !1);
    t[Yr] === null && (t[Yr] = []), t[Yr].push(e)
}

function v1(t, e) {
    if (t[Yr] === null) return;
    let n = t[Yr].indexOf(e);
    n !== -1 && t[Yr].splice(n, 1)
}

function Ea(t) {
    let e = t[wt];
    return Ir(e) ? e[wt] : e
}
var de = {
    lFrame: wD(null),
    bindingsEnabled: !0,
    skipHydrationRootTNode: null
};

function w1() {
    return de.lFrame.elementDepthCount
}

function _1() {
    de.lFrame.elementDepthCount++
}

function b1() {
    de.lFrame.elementDepthCount--
}

function dD() {
    return de.bindingsEnabled
}

function hD() {
    return de.skipHydrationRootTNode !== null
}

function D1(t) {
    return de.skipHydrationRootTNode === t
}

function E1() {
    de.skipHydrationRootTNode = null
}

function he() {
    return de.lFrame.lView
}

function ut() {
    return de.lFrame.tView
}

function rt(t) {
    return de.lFrame.contextLView = t, t[It]
}

function it(t) {
    return de.lFrame.contextLView = null, t
}

function Jt() {
    let t = fD();
    for (; t !== null && t.type === 64;) t = t.parent;
    return t
}

function fD() {
    return de.lFrame.currentTNode
}

function C1() {
    let t = de.lFrame,
        e = t.currentTNode;
    return t.isParent ? e : e.parent
}

function Ra(t, e) {
    let n = de.lFrame;
    n.currentTNode = t, n.isParent = e
}

function pD() {
    return de.lFrame.isParent
}

function gD() {
    de.lFrame.isParent = !1
}

function Yg() {
    let t = de.lFrame,
        e = t.bindingRootIndex;
    return e === -1 && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e
}

function S1(t) {
    return de.lFrame.bindingIndex = t
}

function po() {
    return de.lFrame.bindingIndex++
}

function M1(t) {
    let e = de.lFrame,
        n = e.bindingIndex;
    return e.bindingIndex = e.bindingIndex + t, n
}

function I1() {
    return de.lFrame.inI18n
}

function T1(t, e) {
    let n = de.lFrame;
    n.bindingIndex = n.bindingRootIndex = t, Hp(e)
}

function x1() {
    return de.lFrame.currentDirectiveIndex
}

function Hp(t) {
    de.lFrame.currentDirectiveIndex = t
}

function A1(t) {
    let e = de.lFrame.currentDirectiveIndex;
    return e === -1 ? null : t[e]
}

function mD() {
    return de.lFrame.currentQueryIndex
}

function Jg(t) {
    de.lFrame.currentQueryIndex = t
}

function N1(t) {
    let e = t[ee];
    return e.type === 2 ? e.declTNode : e.type === 1 ? t[Yt] : null
}

function yD(t, e, n) {
    if (n & ue.SkipSelf) {
        let i = e,
            s = t;
        for (; i = i.parent, i === null && !(n & ue.Host);)
            if (i = N1(s), i === null || (s = s[fo], i.type & 10)) break;
        if (i === null) return !1;
        e = i, t = s
    }
    let r = de.lFrame = vD();
    return r.currentTNode = e, r.lView = t, !0
}

function Xg(t) {
    let e = vD(),
        n = t[ee];
    de.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex, e.inI18n = !1
}

function vD() {
    let t = de.lFrame,
        e = t === null ? null : t.child;
    return e === null ? wD(t) : e
}

function wD(t) {
    let e = {
        currentTNode: null,
        isParent: !0,
        lView: null,
        tView: null,
        selectedIndex: -1,
        contextLView: null,
        elementDepthCount: 0,
        currentNamespace: null,
        currentDirectiveIndex: -1,
        bindingRootIndex: -1,
        bindingIndex: -1,
        currentQueryIndex: 0,
        parent: t,
        child: null,
        inI18n: !1
    };
    return t !== null && (t.child = e), e
}

function _D() {
    let t = de.lFrame;
    return de.lFrame = t.parent, t.currentTNode = null, t.lView = null, t
}
var bD = _D;

function em() {
    let t = _D();
    t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0
}

function R1(t) {
    return (de.lFrame.contextLView = y1(t, de.lFrame.contextLView))[It]
}

function qi() {
    return de.lFrame.selectedIndex
}

function $i(t) {
    de.lFrame.selectedIndex = t
}

function Pu() {
    let t = de.lFrame;
    return Qg(t.tView, t.selectedIndex)
}

function O1() {
    return de.lFrame.currentNamespace
}
var DD = !0;

function tm() {
    return DD
}

function nm(t) {
    DD = t
}

function F1(t, e, n) {
    let {
        ngOnChanges: r,
        ngOnInit: i,
        ngDoCheck: s
    } = e.type.prototype;
    if (r) {
        let o = sD(e);
        (n.preOrderHooks ? ? = []).push(t, o), (n.preOrderCheckHooks ? ? = []).push(t, o)
    }
    i && (n.preOrderHooks ? ? = []).push(0 - t, i), s && ((n.preOrderHooks ? ? = []).push(t, s), (n.preOrderCheckHooks ? ? = []).push(t, s))
}

function rm(t, e) {
    for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) {
        let s = t.data[n].type.prototype,
            {
                ngAfterContentInit: o,
                ngAfterContentChecked: a,
                ngAfterViewInit: c,
                ngAfterViewChecked: l,
                ngOnDestroy: u
            } = s;
        o && (t.contentHooks ? ? = []).push(-n, o), a && ((t.contentHooks ? ? = []).push(n, a), (t.contentCheckHooks ? ? = []).push(n, a)), c && (t.viewHooks ? ? = []).push(-n, c), l && ((t.viewHooks ? ? = []).push(n, l), (t.viewCheckHooks ? ? = []).push(n, l)), u != null && (t.destroyHooks ? ? = []).push(n, u)
    }
}

function tu(t, e, n) {
    ED(t, e, 3, n)
}

function nu(t, e, n, r) {
    (t[X] & 3) === n && ED(t, e, n, r)
}

function Cp(t, e) {
    let n = t[X];
    (n & 3) === e && (n &= 16383, n += 1, t[X] = n)
}

function ED(t, e, n, r) {
    let i = r !== void 0 ? t[Ks] & 65535 : 0,
        s = r ? ? -1,
        o = e.length - 1,
        a = 0;
    for (let c = i; c < o; c++)
        if (typeof e[c + 1] == "number") {
            if (a = e[c], r != null && a >= r) break
        } else e[c] < 0 && (t[Ks] += 65536), (a < s || s == -1) && (k1(t, n, e, c), t[Ks] = (t[Ks] & 4294901760) + c + 2), c++
}

function nb(t, e) {
    Kn(4, t, e);
    let n = pe(null);
    try {
        e.call(t)
    } finally {
        pe(n), Kn(5, t, e)
    }
}

function k1(t, e, n, r) {
    let i = n[r] < 0,
        s = n[r + 1],
        o = i ? -n[r] : n[r],
        a = t[o];
    i ? t[X] >> 14 < t[Ks] >> 16 && (t[X] & 3) === e && (t[X] += 16384, nb(a, s)) : nb(a, s)
}
var eo = -1,
    Wi = class {
        constructor(e, n, r) {
            this.factory = e, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r
        }
    };

function P1(t) {
    return t instanceof Wi
}

function L1(t) {
    return (t.flags & 8) !== 0
}

function V1(t) {
    return (t.flags & 16) !== 0
}

function CD(t) {
    return t !== eo
}

function hu(t) {
    return t & 32767
}

function U1(t) {
    return t >> 16
}

function fu(t, e) {
    let n = U1(t),
        r = e;
    for (; n > 0;) r = r[fo], n--;
    return r
}
var Gp = !0;

function pu(t) {
    let e = Gp;
    return Gp = t, e
}
var j1 = 256,
    SD = j1 - 1,
    MD = 5,
    B1 = 0,
    Yn = {};

function z1(t, e, n) {
    let r;
    typeof n == "string" ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(ga) && (r = n[ga]), r == null && (r = n[ga] = B1++);
    let i = r & SD,
        s = 1 << i;
    e.data[t + (i >> MD)] |= s
}

function gu(t, e) {
    let n = ID(t, e);
    if (n !== -1) return n;
    let r = e[ee];
    r.firstCreatePass && (t.injectorIndex = e.length, Sp(r.data, t), Sp(e, null), Sp(r.blueprint, null));
    let i = im(t, e),
        s = t.injectorIndex;
    if (CD(i)) {
        let o = hu(i),
            a = fu(i, e),
            c = a[ee].data;
        for (let l = 0; l < 8; l++) e[s + l] = a[o + l] | c[o + l]
    }
    return e[s + 8] = i, s
}

function Sp(t, e) {
    t.push(0, 0, 0, 0, 0, 0, 0, 0, e)
}

function ID(t, e) {
    return t.injectorIndex === -1 || t.parent && t.parent.injectorIndex === t.injectorIndex || e[t.injectorIndex + 8] === null ? -1 : t.injectorIndex
}

function im(t, e) {
    if (t.parent && t.parent.injectorIndex !== -1) return t.parent.injectorIndex;
    let n = 0,
        r = null,
        i = e;
    for (; i !== null;) {
        if (r = RD(i), r === null) return eo;
        if (n++, i = i[fo], r.injectorIndex !== -1) return r.injectorIndex | n << 16
    }
    return eo
}

function Zp(t, e, n) {
    z1(t, e, n)
}

function TD(t, e, n) {
    if (n & ue.Optional || t !== void 0) return t;
    Ug(e, "NodeInjector")
}

function xD(t, e, n, r) {
    if (n & ue.Optional && r === void 0 && (r = null), !(n & (ue.Self | ue.Host))) {
        let i = t[so],
            s = zt(void 0);
        try {
            return i ? i.get(e, r, n & ue.Optional) : Pb(e, r, n & ue.Optional)
        } finally {
            zt(s)
        }
    }
    return TD(r, e, n)
}

function AD(t, e, n, r = ue.Default, i) {
    if (t !== null) {
        if (e[X] & 2048 && !(r & ue.Self)) {
            let o = G1(t, e, n, r, Yn);
            if (o !== Yn) return o
        }
        let s = ND(t, e, n, r, Yn);
        if (s !== Yn) return s
    }
    return xD(e, n, r, i)
}

function ND(t, e, n, r, i) {
    let s = W1(n);
    if (typeof s == "function") {
        if (!yD(e, t, r)) return r & ue.Host ? TD(i, n, r) : xD(e, n, r, i);
        try {
            let o;
            if (o = s(r), o == null && !(r & ue.Optional)) Ug(n);
            else return o
        } finally {
            bD()
        }
    } else if (typeof s == "number") {
        let o = null,
            a = ID(t, e),
            c = eo,
            l = r & ue.Host ? e[mn][Yt] : null;
        for ((a === -1 || r & ue.SkipSelf) && (c = a === -1 ? im(t, e) : e[a + 8], c === eo || !ib(r, !1) ? a = -1 : (o = e[ee], a = hu(c), e = fu(c, e))); a !== -1;) {
            let u = e[ee];
            if (rb(s, a, u.data)) {
                let d = $1(a, e, n, o, r, l);
                if (d !== Yn) return d
            }
            c = e[a + 8], c !== eo && ib(r, e[ee].data[a + 8] === l) && rb(s, a, e) ? (o = u, a = hu(c), e = fu(c, e)) : a = -1
        }
    }
    return i
}

function $1(t, e, n, r, i, s) {
    let o = e[ee],
        a = o.data[t + 8],
        c = r == null ? ku(a) && Gp : r != o && (a.type & 3) !== 0,
        l = i & ue.Host && s === a,
        u = ru(a, o, n, c, l);
    return u !== null ? Hi(e, o, u, a) : Yn
}

function ru(t, e, n, r, i) {
    let s = t.providerIndexes,
        o = e.data,
        a = s & 1048575,
        c = t.directiveStart,
        l = t.directiveEnd,
        u = s >> 20,
        d = r ? a : a + u,
        h = i ? a + u : l;
    for (let f = d; f < h; f++) {
        let p = o[f];
        if (f < c && n === p || f >= c && p.type === n) return f
    }
    if (i) {
        let f = o[c];
        if (f && Xr(f) && f.type === n) return c
    }
    return null
}

function Hi(t, e, n, r) {
    let i = t[n],
        s = e.data;
    if (P1(i)) {
        let o = i;
        o.resolving && fN(hN(s[n]));
        let a = pu(o.canSeeViewProviders);
        o.resolving = !0;
        let c, l = o.injectImpl ? zt(o.injectImpl) : null,
            u = yD(t, r, ue.Default);
        try {
            i = t[n] = o.factory(void 0, s, t, r), e.firstCreatePass && n >= r.directiveStart && F1(n, s[n], e)
        } finally {
            l !== null && zt(l), pu(a), o.resolving = !1, bD()
        }
    }
    return i
}

function W1(t) {
    if (typeof t == "string") return t.charCodeAt(0) || 0;
    let e = t.hasOwnProperty(ga) ? t[ga] : void 0;
    return typeof e == "number" ? e >= 0 ? e & SD : H1 : e
}

function rb(t, e, n) {
    let r = 1 << t;
    return !!(n[e + (t >> MD)] & r)
}

function ib(t, e) {
    return !(t & ue.Self) && !(t & ue.Host && e)
}
var Ui = class {
    constructor(e, n) {
        this._tNode = e, this._lView = n
    }
    get(e, n, r) {
        return AD(this._tNode, this._lView, e, Nu(r), n)
    }
};

function H1() {
    return new Ui(Jt(), he())
}

function Xn(t) {
    return xa(() => {
        let e = t.prototype.constructor,
            n = e[ou] || Qp(e),
            r = Object.prototype,
            i = Object.getPrototypeOf(t.prototype).constructor;
        for (; i && i !== r;) {
            let s = i[ou] || Qp(i);
            if (s && s !== n) return s;
            i = Object.getPrototypeOf(i)
        }
        return s => new s
    })
}

function Qp(t) {
    return Ab(t) ? () => {
        let e = Qp(Pt(t));
        return e && e()
    } : ji(t)
}

function G1(t, e, n, r, i) {
    let s = t,
        o = e;
    for (; s !== null && o !== null && o[X] & 2048 && !(o[X] & 512);) {
        let a = ND(s, o, n, r | ue.Self, Yn);
        if (a !== Yn) return a;
        let c = s.parent;
        if (!c) {
            let l = o[tD];
            if (l) {
                let u = l.get(n, Yn, r);
                if (u !== Yn) return u
            }
            c = RD(o), o = o[fo]
        }
        s = c
    }
    return i
}

function RD(t) {
    let e = t[ee],
        n = e.type;
    return n === 2 ? e.declTNode : n === 1 ? t[Yt] : null
}

function sb(t, e = null, n = null, r) {
    let i = OD(t, e, n, r);
    return i.resolveInjectorInitializers(), i
}

function OD(t, e = null, n = null, r, i = new Set) {
    let s = [n || pn, GN(t)];
    return r = r || (typeof t == "object" ? void 0 : Lt(t)), new wa(s, e || Wg(), r || null, i)
}
var bt = (() => {
    let e = class e {
        static create(r, i) {
            if (Array.isArray(r)) return sb({
                name: ""
            }, i, r, ""); {
                let s = r.name ? ? "";
                return sb({
                    name: s
                }, r.parent, r.providers, s)
            }
        }
    };
    e.THROW_IF_NOT_FOUND = ya, e.NULL = new lu, e.\u0275prov = I({
        token: e,
        providedIn: "any",
        factory: () => C(Ub)
    }), e.__NG_ELEMENT_ID__ = -1;
    let t = e;
    return t
})();
var Z1 = "ngOriginalError";

function Mp(t) {
    return t[Z1]
}
var yn = class {
        constructor() {
            this._console = console
        }
        handleError(e) {
            let n = this._findOriginalError(e);
            this._console.error("ERROR", e), n && this._console.error("ORIGINAL ERROR", n)
        }
        _findOriginalError(e) {
            let n = e && Mp(e);
            for (; n && Mp(n);) n = Mp(n);
            return n || null
        }
    },
    FD = new R("", {
        providedIn: "root",
        factory: () => M(yn).handleError.bind(void 0)
    }),
    go = (() => {
        let e = class e {};
        e.__NG_ELEMENT_ID__ = Q1, e.__NG_ENV_ID__ = r => r;
        let t = e;
        return t
    })(),
    qp = class extends go {
        constructor(e) {
            super(), this._lView = e
        }
        onDestroy(e) {
            return uD(this._lView, e), () => v1(this._lView, e)
        }
    };

function Q1() {
    return new qp(he())
}

function q1() {
    return mo(Jt(), he())
}

function mo(t, e) {
    return new je(wn(t, e))
}
var je = (() => {
    let e = class e {
        constructor(r) {
            this.nativeElement = r
        }
    };
    e.__NG_ELEMENT_ID__ = q1;
    let t = e;
    return t
})();

function K1(t) {
    return t instanceof je ? t.nativeElement : t
}
var Kp = class extends Me {
    constructor(e = !1) {
        super(), this.destroyRef = void 0, this.__isAsync = e, eD() && (this.destroyRef = M(go, {
            optional: !0
        }) ? ? void 0)
    }
    emit(e) {
        let n = pe(null);
        try {
            super.next(e)
        } finally {
            pe(n)
        }
    }
    subscribe(e, n, r) {
        let i = e,
            s = n || (() => null),
            o = r;
        if (e && typeof e == "object") {
            let c = e;
            i = c.next ? .bind(c), s = c.error ? .bind(c), o = c.complete ? .bind(c)
        }
        this.__isAsync && (s = Ip(s), i && (i = Ip(i)), o && (o = Ip(o)));
        let a = super.subscribe({
            next: i,
            error: s,
            complete: o
        });
        return e instanceof Oe && e.add(a), a
    }
};

function Ip(t) {
    return e => {
        setTimeout(t, void 0, e)
    }
}
var oe = Kp;

function Y1() {
    return this._results[Symbol.iterator]()
}
var Yp = class t {
    get changes() {
        return this._changes ? ? = new oe
    }
    constructor(e = !1) {
        this._emitDistinctChangesOnly = e, this.dirty = !0, this._onDirty = void 0, this._results = [], this._changesDetected = !1, this._changes = void 0, this.length = 0, this.first = void 0, this.last = void 0;
        let n = t.prototype;
        n[Symbol.iterator] || (n[Symbol.iterator] = Y1)
    }
    get(e) {
        return this._results[e]
    }
    map(e) {
        return this._results.map(e)
    }
    filter(e) {
        return this._results.filter(e)
    }
    find(e) {
        return this._results.find(e)
    }
    reduce(e, n) {
        return this._results.reduce(e, n)
    }
    forEach(e) {
        this._results.forEach(e)
    }
    some(e) {
        return this._results.some(e)
    }
    toArray() {
        return this._results.slice()
    }
    toString() {
        return this._results.toString()
    }
    reset(e, n) {
        this.dirty = !1;
        let r = CN(e);
        (this._changesDetected = !EN(this._results, r, n)) && (this._results = r, this.length = r.length, this.last = r[this.length - 1], this.first = r[0])
    }
    notifyOnChanges() {
        this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this)
    }
    onDirty(e) {
        this._onDirty = e
    }
    setDirty() {
        this.dirty = !0, this._onDirty ? .()
    }
    destroy() {
        this._changes !== void 0 && (this._changes.complete(), this._changes.unsubscribe())
    }
};

function kD(t) {
    return (t.flags & 128) === 128
}
var PD = new Map,
    J1 = 0;

function X1() {
    return J1++
}

function eR(t) {
    PD.set(t[Fu], t)
}

function tR(t) {
    PD.delete(t[Fu])
}
var ob = "__ngContext__";

function Gi(t, e) {
    Vi(e) ? (t[ob] = e[Fu], eR(e)) : t[ob] = e
}

function LD(t) {
    return UD(t[ba])
}

function VD(t) {
    return UD(t[Fn])
}

function UD(t) {
    for (; t !== null && !Ir(t);) t = t[Fn];
    return t
}
var Jp;

function jD(t) {
    Jp = t
}

function nR() {
    if (Jp !== void 0) return Jp;
    if (typeof document < "u") return document;
    throw new S(210, !1)
}
var Lu = new R("", {
        providedIn: "root",
        factory: () => rR
    }),
    rR = "ng",
    sm = new R(""),
    st = new R("", {
        providedIn: "platform",
        factory: () => "unknown"
    });
var Oa = new R(""),
    om = new R("", {
        providedIn: "root",
        factory: () => nR().body ? .querySelector("[ngCspNonce]") ? .getAttribute("ngCspNonce") || null
    });
var iR = "h",
    sR = "b";
var oR = () => null;

function am(t, e, n = !1) {
    return oR(t, e, n)
}
var BD = !1,
    aR = new R("", {
        providedIn: "root",
        factory: () => BD
    });
var mu = class {
    constructor(e) {
        this.changingThisBreaksApplicationSecurity = e
    }
    toString() {
        return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Tb})`
    }
};

function Vu(t) {
    return t instanceof mu ? t.changingThisBreaksApplicationSecurity : t
}

function zD(t, e) {
    let n = cR(t);
    if (n != null && n !== e) {
        if (n === "ResourceURL" && e === "URL") return !0;
        throw new Error(`Required a safe ${e}, got a ${n} (see ${Tb})`)
    }
    return n === e
}

function cR(t) {
    return t instanceof mu && t.getTypeName() || null
}
var lR = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;

function $D(t) {
    return t = String(t), t.match(lR) ? t : "unsafe:" + t
}
var cm = function(t) {
    return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t
}(cm || {});

function ni(t) {
    let e = uR();
    return e ? e.sanitize(cm.URL, t) || "" : zD(t, "URL") ? Vu(t) : $D(Au(t))
}

function uR() {
    let t = he();
    return t && t[kn].sanitizer
}

function Fa(t) {
    return t.ownerDocument.defaultView
}

function WD(t) {
    return t instanceof Function ? t() : t
}

function dR(t) {
    return (t ? ? M(bt)).get(st) === "browser"
}
var Cr = function(t) {
        return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t
    }(Cr || {}),
    hR;

function lm(t, e) {
    return hR(t, e)
}

function Ys(t, e, n, r, i) {
    if (r != null) {
        let s, o = !1;
        Ir(r) ? s = r : Vi(r) && (o = !0, r = r[Mr]);
        let a = Jn(r);
        t === 0 && n !== null ? i == null ? qD(e, n, a) : yu(e, n, a, i || null, !0) : t === 1 && n !== null ? yu(e, n, a, i || null, !0) : t === 2 ? IR(e, a, o) : t === 3 && e.destroyNode(a), s != null && xR(e, t, s, n, i)
    }
}

function fR(t, e) {
    return t.createText(e)
}

function pR(t, e, n) {
    t.setValue(e, n)
}

function HD(t, e, n) {
    return t.createElement(e, n)
}

function gR(t, e) {
    GD(t, e), e[Mr] = null, e[Yt] = null
}

function mR(t, e, n, r, i, s) {
    r[Mr] = i, r[Yt] = e, ju(t, r, n, 1, i, s)
}

function GD(t, e) {
    e[kn].changeDetectionScheduler ? .notify(1), ju(t, e, e[Xe], 2, null, null)
}

function yR(t) {
    let e = t[ba];
    if (!e) return Tp(t[ee], t);
    for (; e;) {
        let n = null;
        if (Vi(e)) n = e[ba];
        else {
            let r = e[Tt];
            r && (n = r)
        }
        if (!n) {
            for (; e && !e[Fn] && e !== t;) Vi(e) && Tp(e[ee], e), e = e[wt];
            e === null && (e = t), Vi(e) && Tp(e[ee], e), n = e && e[Fn]
        }
        e = n
    }
}

function vR(t, e, n, r) {
    let i = Tt + r,
        s = n.length;
    r > 0 && (n[i - 1][Fn] = e), r < s - Tt ? (e[Fn] = n[i], Vb(n, Tt + r, e)) : (n.push(e), e[Fn] = null), e[wt] = n;
    let o = e[Na];
    o !== null && n !== o && wR(o, e);
    let a = e[Er];
    a !== null && a.insertView(t), Wp(e), e[X] |= 128
}

function wR(t, e) {
    let n = t[oo],
        i = e[wt][wt][mn];
    e[mn] !== i && (t[X] |= Gg.HasTransplantedViews), n === null ? t[oo] = [e] : n.push(e)
}

function ZD(t, e) {
    let n = t[oo],
        r = n.indexOf(e);
    n.splice(r, 1)
}

function Ca(t, e) {
    if (t.length <= Tt) return;
    let n = Tt + e,
        r = t[n];
    if (r) {
        let i = r[Na];
        i !== null && i !== t && ZD(i, r), e > 0 && (t[n - 1][Fn] = r[Fn]);
        let s = cu(t, Tt + e);
        gR(r[ee], r);
        let o = s[Er];
        o !== null && o.detachView(s[ee]), r[wt] = null, r[Fn] = null, r[X] &= -129
    }
    return r
}

function Uu(t, e) {
    if (!(e[X] & 256)) {
        let n = e[Xe];
        n.destroyNode && ju(t, e, n, 3, null, null), yR(e)
    }
}

function Tp(t, e) {
    if (e[X] & 256) return;
    let n = pe(null);
    try {
        e[X] &= -129, e[X] |= 256, e[Bi] && o_(e[Bi]), bR(t, e), _R(t, e), e[ee].type === 1 && e[Xe].destroy();
        let r = e[Na];
        if (r !== null && Ir(e[wt])) {
            r !== e[wt] && ZD(r, e);
            let i = e[Er];
            i !== null && i.detachView(t)
        }
        tR(e)
    } finally {
        pe(n)
    }
}

function _R(t, e) {
    let n = t.cleanup,
        r = e[_a];
    if (n !== null)
        for (let s = 0; s < n.length - 1; s += 2)
            if (typeof n[s] == "string") {
                let o = n[s + 3];
                o >= 0 ? r[o]() : r[-o].unsubscribe(), s += 2
            } else {
                let o = r[n[s + 1]];
                n[s].call(o)
            }
    r !== null && (e[_a] = null);
    let i = e[Yr];
    if (i !== null) {
        e[Yr] = null;
        for (let s = 0; s < i.length; s++) {
            let o = i[s];
            o()
        }
    }
}

function bR(t, e) {
    let n;
    if (t != null && (n = t.destroyHooks) != null)
        for (let r = 0; r < n.length; r += 2) {
            let i = e[n[r]];
            if (!(i instanceof Wi)) {
                let s = n[r + 1];
                if (Array.isArray(s))
                    for (let o = 0; o < s.length; o += 2) {
                        let a = i[s[o]],
                            c = s[o + 1];
                        Kn(4, a, c);
                        try {
                            c.call(a)
                        } finally {
                            Kn(5, a, c)
                        }
                    } else {
                        Kn(4, i, s);
                        try {
                            s.call(i)
                        } finally {
                            Kn(5, i, s)
                        }
                    }
            }
        }
}

function QD(t, e, n) {
    return DR(t, e.parent, n)
}

function DR(t, e, n) {
    let r = e;
    for (; r !== null && r.type & 40;) e = r, r = e.parent;
    if (r === null) return n[Mr]; {
        let {
            componentOffset: i
        } = r;
        if (i > -1) {
            let {
                encapsulation: s
            } = t.data[r.directiveStart + i];
            if (s === gn.None || s === gn.Emulated) return null
        }
        return wn(r, n)
    }
}

function yu(t, e, n, r, i) {
    t.insertBefore(e, n, r, i)
}

function qD(t, e, n) {
    t.appendChild(e, n)
}

function ab(t, e, n, r, i) {
    r !== null ? yu(t, e, n, r, i) : qD(t, e, n)
}

function ER(t, e, n, r) {
    t.removeChild(e, n, r)
}

function um(t, e) {
    return t.parentNode(e)
}

function CR(t, e) {
    return t.nextSibling(e)
}

function KD(t, e, n) {
    return MR(t, e, n)
}

function SR(t, e, n) {
    return t.type & 40 ? wn(t, n) : null
}
var MR = SR,
    cb;

function dm(t, e, n, r) {
    let i = QD(t, r, e),
        s = e[Xe],
        o = r.parent || e[Yt],
        a = KD(o, r, e);
    if (i != null)
        if (Array.isArray(n))
            for (let c = 0; c < n.length; c++) ab(s, i, n[c], a, !1);
        else ab(s, i, n, a, !1);
    cb !== void 0 && cb(s, r, e, n, i)
}

function iu(t, e) {
    if (e !== null) {
        let n = e.type;
        if (n & 3) return wn(e, t);
        if (n & 4) return Xp(-1, t[e.index]);
        if (n & 8) {
            let r = e.child;
            if (r !== null) return iu(t, r); {
                let i = t[e.index];
                return Ir(i) ? Xp(-1, i) : Jn(i)
            }
        } else {
            if (n & 32) return lm(e, t)() || Jn(t[e.index]); {
                let r = YD(t, e);
                if (r !== null) {
                    if (Array.isArray(r)) return r[0];
                    let i = Ea(t[mn]);
                    return iu(i, r)
                } else return iu(t, e.next)
            }
        }
    }
    return null
}

function YD(t, e) {
    if (e !== null) {
        let r = t[mn][Yt],
            i = e.projection;
        return r.projection[i]
    }
    return null
}

function Xp(t, e) {
    let n = Tt + t + 1;
    if (n < e.length) {
        let r = e[n],
            i = r[ee].firstChild;
        if (i !== null) return iu(r, i)
    }
    return e[zi]
}

function IR(t, e, n) {
    let r = um(t, e);
    r && ER(t, r, e, n)
}

function hm(t, e, n, r, i, s, o) {
    for (; n != null;) {
        let a = r[n.index],
            c = n.type;
        if (o && e === 0 && (a && Gi(Jn(a), r), n.flags |= 2), (n.flags & 32) !== 32)
            if (c & 8) hm(t, e, n.child, r, i, s, !1), Ys(e, t, i, a, s);
            else if (c & 32) {
            let l = lm(n, r),
                u;
            for (; u = l();) Ys(e, t, i, u, s);
            Ys(e, t, i, a, s)
        } else c & 16 ? JD(t, e, r, n, i, s) : Ys(e, t, i, a, s);
        n = o ? n.projectionNext : n.next
    }
}

function ju(t, e, n, r, i, s) {
    hm(n, r, t.firstChild, e, i, s, !1)
}

function TR(t, e, n) {
    let r = e[Xe],
        i = QD(t, n, e),
        s = n.parent || e[Yt],
        o = KD(s, n, e);
    JD(r, 0, e, n, i, o)
}

function JD(t, e, n, r, i, s) {
    let o = n[mn],
        c = o[Yt].projection[r.projection];
    if (Array.isArray(c))
        for (let l = 0; l < c.length; l++) {
            let u = c[l];
            Ys(e, t, i, u, s)
        } else {
            let l = c,
                u = o[wt];
            kD(r) && (l.flags |= 128), hm(t, e, l, u, i, s, !0)
        }
}

function xR(t, e, n, r, i) {
    let s = n[zi],
        o = Jn(n);
    s !== o && Ys(e, t, r, s, i);
    for (let a = Tt; a < n.length; a++) {
        let c = n[a];
        ju(c[ee], c, t, e, r, s)
    }
}

function AR(t, e, n, r, i) {
    if (e) i ? t.addClass(n, r) : t.removeClass(n, r);
    else {
        let s = r.indexOf("-") === -1 ? void 0 : Cr.DashCase;
        i == null ? t.removeStyle(n, r, s) : (typeof i == "string" && i.endsWith("!important") && (i = i.slice(0, -10), s |= Cr.Important), t.setStyle(n, r, i, s))
    }
}

function NR(t, e, n) {
    t.setAttribute(e, "style", n)
}

function XD(t, e, n) {
    n === "" ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n)
}

function eE(t, e, n) {
    let {
        mergedAttrs: r,
        classes: i,
        styles: s
    } = n;
    r !== null && Up(t, e, r), i !== null && XD(t, e, i), s !== null && NR(t, e, s)
}
var Tr = {};

function ae(t = 1) {
    tE(ut(), he(), qi() + t, !1)
}

function tE(t, e, n, r) {
    if (!r)
        if ((e[X] & 3) === 3) {
            let s = t.preOrderCheckHooks;
            s !== null && tu(e, s, n)
        } else {
            let s = t.preOrderHooks;
            s !== null && nu(e, s, 0, n)
        }
    $i(n)
}

function O(t, e = ue.Default) {
    let n = he();
    if (n === null) return C(t, e);
    let r = Jt();
    return AD(r, n, Pt(t), e)
}

function nE() {
    let t = "invalid";
    throw new Error(t)
}

function rE(t, e, n, r, i, s) {
    let o = pe(null);
    try {
        let a = null;
        i & Vt.SignalBased && (a = e[r][br]), a !== null && a.transformFn !== void 0 && (s = a.transformFn(s)), i & Vt.HasDecoratorInputTransform && (s = t.inputTransforms[r].call(e, s)), t.setInput !== null ? t.setInput(e, a, s, n, r) : iD(e, a, r, s)
    } finally {
        pe(o)
    }
}

function RR(t, e) {
    let n = t.hostBindingOpCodes;
    if (n !== null) try {
        for (let r = 0; r < n.length; r++) {
            let i = n[r];
            if (i < 0) $i(~i);
            else {
                let s = i,
                    o = n[++r],
                    a = n[++r];
                T1(o, s);
                let c = e[s];
                a(2, c)
            }
        }
    } finally {
        $i(-1)
    }
}

function Bu(t, e, n, r, i, s, o, a, c, l, u) {
    let d = e.blueprint.slice();
    return d[Mr] = i, d[X] = r | 4 | 128 | 8 | 64, (l !== null || t && t[X] & 2048) && (d[X] |= 2048), lD(d), d[wt] = d[fo] = t, d[It] = n, d[kn] = o || t && t[kn], d[Xe] = a || t && t[Xe], d[so] = c || t && t[so] || null, d[Yt] = s, d[Fu] = X1(), d[io] = u, d[tD] = l, d[mn] = e.type == 2 ? t[mn] : d, d
}

function ka(t, e, n, r, i) {
    let s = t.data[e];
    if (s === null) s = OR(t, e, n, r, i), I1() && (s.flags |= 32);
    else if (s.type & 64) {
        s.type = n, s.value = r, s.attrs = i;
        let o = C1();
        s.injectorIndex = o === null ? -1 : o.injectorIndex
    }
    return Ra(s, !0), s
}

function OR(t, e, n, r, i) {
    let s = fD(),
        o = pD(),
        a = o ? s : s && s.parent,
        c = t.data[e] = UR(t, a, n, e, r, i);
    return t.firstChild === null && (t.firstChild = c), s !== null && (o ? s.child == null && c.parent !== null && (s.child = c) : s.next === null && (s.next = c, c.prev = s)), c
}

function iE(t, e, n, r) {
    if (n === 0) return -1;
    let i = e.length;
    for (let s = 0; s < n; s++) e.push(r), t.blueprint.push(r), t.data.push(null);
    return i
}

function sE(t, e, n, r, i) {
    let s = qi(),
        o = r & 2;
    try {
        $i(-1), o && e.length > $t && tE(t, e, $t, !1), Kn(o ? 2 : 0, i), n(r, i)
    } finally {
        $i(s), Kn(o ? 3 : 1, i)
    }
}

function oE(t, e, n) {
    if (rD(e)) {
        let r = pe(null);
        try {
            let i = e.directiveStart,
                s = e.directiveEnd;
            for (let o = i; o < s; o++) {
                let a = t.data[o];
                if (a.contentQueries) {
                    let c = n[o];
                    a.contentQueries(1, c, o)
                }
            }
        } finally {
            pe(r)
        }
    }
}

function aE(t, e, n) {
    dD() && (HR(t, e, n, wn(n, e)), (n.flags & 64) === 64 && hE(t, e, n))
}

function cE(t, e, n = wn) {
    let r = e.localNames;
    if (r !== null) {
        let i = e.index + 1;
        for (let s = 0; s < r.length; s += 2) {
            let o = r[s + 1],
                a = o === -1 ? n(e, t) : t[o];
            t[i++] = a
        }
    }
}

function lE(t) {
    let e = t.tView;
    return e === null || e.incompleteFirstPass ? t.tView = fm(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts, t.id) : e
}

function fm(t, e, n, r, i, s, o, a, c, l, u) {
    let d = $t + r,
        h = d + i,
        f = FR(d, h),
        p = typeof l == "function" ? l() : l;
    return f[ee] = {
        type: t,
        blueprint: f,
        template: n,
        queries: null,
        viewQuery: a,
        declTNode: e,
        data: f.slice().fill(null, d),
        bindingStartIndex: d,
        expandoStartIndex: h,
        hostBindingOpCodes: null,
        firstCreatePass: !0,
        firstUpdatePass: !0,
        staticViewQueries: !1,
        staticContentQueries: !1,
        preOrderHooks: null,
        preOrderCheckHooks: null,
        contentHooks: null,
        contentCheckHooks: null,
        viewHooks: null,
        viewCheckHooks: null,
        destroyHooks: null,
        cleanup: null,
        contentQueries: null,
        components: null,
        directiveRegistry: typeof s == "function" ? s() : s,
        pipeRegistry: typeof o == "function" ? o() : o,
        firstChild: null,
        schemas: c,
        consts: p,
        incompleteFirstPass: !1,
        ssrId: u
    }
}

function FR(t, e) {
    let n = [];
    for (let r = 0; r < e; r++) n.push(r < t ? null : Tr);
    return n
}

function kR(t, e, n, r) {
    let s = r.get(aR, BD) || n === gn.ShadowDom,
        o = t.selectRootElement(e, s);
    return PR(o), o
}

function PR(t) {
    LR(t)
}
var LR = () => null;

function VR(t, e, n, r) {
    let i = gE(e);
    i.push(n), t.firstCreatePass && mE(t).push(r, i.length - 1)
}

function UR(t, e, n, r, i, s) {
    let o = e ? e.injectorIndex : -1,
        a = 0;
    return hD() && (a |= 128), {
        type: n,
        index: r,
        insertBeforeIndex: null,
        injectorIndex: o,
        directiveStart: -1,
        directiveEnd: -1,
        directiveStylingLast: -1,
        componentOffset: -1,
        propertyBindings: null,
        flags: a,
        providerIndexes: 0,
        value: i,
        attrs: s,
        mergedAttrs: null,
        localNames: null,
        initialInputs: void 0,
        inputs: null,
        outputs: null,
        tView: null,
        next: null,
        prev: null,
        projectionNext: null,
        child: null,
        parent: e,
        projection: null,
        styles: null,
        stylesWithoutHost: null,
        residualStyles: void 0,
        classes: null,
        classesWithoutHost: null,
        residualClasses: void 0,
        classBindings: 0,
        styleBindings: 0
    }
}

function lb(t, e, n, r, i) {
    for (let s in e) {
        if (!e.hasOwnProperty(s)) continue;
        let o = e[s];
        if (o === void 0) continue;
        r ? ? = {};
        let a, c = Vt.None;
        Array.isArray(o) ? (a = o[0], c = o[1]) : a = o;
        let l = s;
        if (i !== null) {
            if (!i.hasOwnProperty(s)) continue;
            l = i[s]
        }
        t === 0 ? ub(r, n, l, a, c) : ub(r, n, l, a)
    }
    return r
}

function ub(t, e, n, r, i) {
    let s;
    t.hasOwnProperty(n) ? (s = t[n]).push(e, r) : s = t[n] = [e, r], i !== void 0 && s.push(i)
}

function jR(t, e, n) {
    let r = e.directiveStart,
        i = e.directiveEnd,
        s = t.data,
        o = e.attrs,
        a = [],
        c = null,
        l = null;
    for (let u = r; u < i; u++) {
        let d = s[u],
            h = n ? n.get(d) : null,
            f = h ? h.inputs : null,
            p = h ? h.outputs : null;
        c = lb(0, d.inputs, u, c, f), l = lb(1, d.outputs, u, l, p);
        let g = c !== null && o !== null && !Bg(e) ? nO(c, u, o) : null;
        a.push(g)
    }
    c !== null && (c.hasOwnProperty("class") && (e.flags |= 8), c.hasOwnProperty("style") && (e.flags |= 16)), e.initialInputs = a, e.inputs = c, e.outputs = l
}

function BR(t) {
    return t === "class" ? "className" : t === "for" ? "htmlFor" : t === "formaction" ? "formAction" : t === "innerHtml" ? "innerHTML" : t === "readonly" ? "readOnly" : t === "tabindex" ? "tabIndex" : t
}

function pm(t, e, n, r, i, s, o, a) {
    let c = wn(e, n),
        l = e.inputs,
        u;
    !a && l != null && (u = l[r]) ? (gm(t, n, u, r, i), ku(e) && zR(n, e.index)) : e.type & 3 ? (r = BR(r), i = o != null ? o(i, e.value || "", r) : i, s.setProperty(c, r, i)) : e.type & 12
}

function zR(t, e) {
    let n = ti(e, t);
    n[X] & 16 || (n[X] |= 64)
}

function uE(t, e, n, r) {
    if (dD()) {
        let i = r === null ? null : {
                "": -1
            },
            s = ZR(t, n),
            o, a;
        s === null ? o = a = null : [o, a] = s, o !== null && dE(t, e, n, o, i, a), i && QR(n, r, i)
    }
    n.mergedAttrs = va(n.mergedAttrs, n.attrs)
}

function dE(t, e, n, r, i, s) {
    for (let l = 0; l < r.length; l++) Zp(gu(n, e), t, r[l].type);
    KR(n, t.data.length, r.length);
    for (let l = 0; l < r.length; l++) {
        let u = r[l];
        u.providersResolver && u.providersResolver(u)
    }
    let o = !1,
        a = !1,
        c = iE(t, e, r.length, null);
    for (let l = 0; l < r.length; l++) {
        let u = r[l];
        n.mergedAttrs = va(n.mergedAttrs, u.hostAttrs), YR(t, n, e, c, u), qR(c, u, i), u.contentQueries !== null && (n.flags |= 4), (u.hostBindings !== null || u.hostAttrs !== null || u.hostVars !== 0) && (n.flags |= 64);
        let d = u.type.prototype;
        !o && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((t.preOrderHooks ? ? = []).push(n.index), o = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((t.preOrderCheckHooks ? ? = []).push(n.index), a = !0), c++
    }
    jR(t, n, s)
}

function $R(t, e, n, r, i) {
    let s = i.hostBindings;
    if (s) {
        let o = t.hostBindingOpCodes;
        o === null && (o = t.hostBindingOpCodes = []);
        let a = ~e.index;
        WR(o) != a && o.push(a), o.push(n, r, s)
    }
}

function WR(t) {
    let e = t.length;
    for (; e > 0;) {
        let n = t[--e];
        if (typeof n == "number" && n < 0) return n
    }
    return 0
}

function HR(t, e, n, r) {
    let i = n.directiveStart,
        s = n.directiveEnd;
    ku(n) && JR(e, n, t.data[i + n.componentOffset]), t.firstCreatePass || gu(n, e), Gi(r, e);
    let o = n.initialInputs;
    for (let a = i; a < s; a++) {
        let c = t.data[a],
            l = Hi(e, t, a, n);
        if (Gi(l, e), o !== null && tO(e, a - i, l, c, n, o), Xr(c)) {
            let u = ti(n.index, e);
            u[It] = Hi(e, t, a, n)
        }
    }
}

function hE(t, e, n) {
    let r = n.directiveStart,
        i = n.directiveEnd,
        s = n.index,
        o = x1();
    try {
        $i(s);
        for (let a = r; a < i; a++) {
            let c = t.data[a],
                l = e[a];
            Hp(a), (c.hostBindings !== null || c.hostVars !== 0 || c.hostAttrs !== null) && GR(c, l)
        }
    } finally {
        $i(-1), Hp(o)
    }
}

function GR(t, e) {
    t.hostBindings !== null && t.hostBindings(1, e)
}

function ZR(t, e) {
    let n = t.directiveRegistry,
        r = null,
        i = null;
    if (n)
        for (let s = 0; s < n.length; s++) {
            let o = n[s];
            if ($b(e, o.selectors, !1))
                if (r || (r = []), Xr(o))
                    if (o.findHostDirectiveDefs !== null) {
                        let a = [];
                        i = i || new Map, o.findHostDirectiveDefs(o, a, i), r.unshift(...a, o);
                        let c = a.length;
                        eg(t, e, c)
                    } else r.unshift(o), eg(t, e, 0);
            else i = i || new Map, o.findHostDirectiveDefs ? .(o, r, i), r.push(o)
        }
    return r === null ? null : [r, i]
}

function eg(t, e, n) {
    e.componentOffset = n, (t.components ? ? = []).push(e.index)
}

function QR(t, e, n) {
    if (e) {
        let r = t.localNames = [];
        for (let i = 0; i < e.length; i += 2) {
            let s = n[e[i + 1]];
            if (s == null) throw new S(-301, !1);
            r.push(e[i], s)
        }
    }
}

function qR(t, e, n) {
    if (n) {
        if (e.exportAs)
            for (let r = 0; r < e.exportAs.length; r++) n[e.exportAs[r]] = t;
        Xr(e) && (n[""] = t)
    }
}

function KR(t, e, n) {
    t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e
}

function YR(t, e, n, r, i) {
    t.data[r] = i;
    let s = i.factory || (i.factory = ji(i.type, !0)),
        o = new Wi(s, Xr(i), O);
    t.blueprint[r] = o, n[r] = o, $R(t, e, r, iE(t, n, i.hostVars, Tr), i)
}

function JR(t, e, n) {
    let r = wn(e, t),
        i = lE(n),
        s = t[kn].rendererFactory,
        o = 16;
    n.signals ? o = 4096 : n.onPush && (o = 64);
    let a = zu(t, Bu(t, i, null, o, r, e, null, s.createRenderer(r, n), null, null, null));
    t[e.index] = a
}

function XR(t, e, n, r, i, s) {
    let o = wn(t, e);
    eO(e[Xe], o, s, t.value, n, r, i)
}

function eO(t, e, n, r, i, s, o) {
    if (s == null) t.removeAttribute(e, i, n);
    else {
        let a = o == null ? Au(s) : o(s, r || "", i);
        t.setAttribute(e, i, a, n)
    }
}

function tO(t, e, n, r, i, s) {
    let o = s[e];
    if (o !== null)
        for (let a = 0; a < o.length;) {
            let c = o[a++],
                l = o[a++],
                u = o[a++],
                d = o[a++];
            rE(r, n, c, l, u, d)
        }
}

function nO(t, e, n) {
    let r = null,
        i = 0;
    for (; i < n.length;) {
        let s = n[i];
        if (s === 0) {
            i += 4;
            continue
        } else if (s === 5) {
            i += 2;
            continue
        }
        if (typeof s == "number") break;
        if (t.hasOwnProperty(s)) {
            r === null && (r = []);
            let o = t[s];
            for (let a = 0; a < o.length; a += 3)
                if (o[a] === e) {
                    r.push(s, o[a + 1], o[a + 2], n[i + 1]);
                    break
                }
        }
        i += 2
    }
    return r
}

function fE(t, e, n, r) {
    return [t, !0, 0, e, null, r, null, n, null, null]
}

function pE(t, e) {
    let n = t.contentQueries;
    if (n !== null) {
        let r = pe(null);
        try {
            for (let i = 0; i < n.length; i += 2) {
                let s = n[i],
                    o = n[i + 1];
                if (o !== -1) {
                    let a = t.data[o];
                    Jg(s), a.contentQueries(2, e[o], o)
                }
            }
        } finally {
            pe(r)
        }
    }
}

function zu(t, e) {
    return t[ba] ? t[eb][Fn] = e : t[ba] = e, t[eb] = e, e
}

function tg(t, e, n) {
    Jg(0);
    let r = pe(null);
    try {
        e(t, n)
    } finally {
        pe(r)
    }
}

function gE(t) {
    return t[_a] || (t[_a] = [])
}

function mE(t) {
    return t.cleanup || (t.cleanup = [])
}

function yE(t, e) {
    let n = t[so],
        r = n ? n.get(yn, null) : null;
    r && r.handleError(e)
}

function gm(t, e, n, r, i) {
    for (let s = 0; s < n.length;) {
        let o = n[s++],
            a = n[s++],
            c = n[s++],
            l = e[o],
            u = t.data[o];
        rE(u, l, r, a, c, i)
    }
}

function rO(t, e, n) {
    let r = cD(e, t);
    pR(t[Xe], r, n)
}

function iO(t, e) {
    let n = ti(e, t),
        r = n[ee];
    sO(r, n);
    let i = n[Mr];
    i !== null && n[io] === null && (n[io] = am(i, n[so])), mm(r, n, n[It])
}

function sO(t, e) {
    for (let n = e.length; n < t.blueprint.length; n++) e.push(t.blueprint[n])
}

function mm(t, e, n) {
    Xg(e);
    try {
        let r = t.viewQuery;
        r !== null && tg(1, r, n);
        let i = t.template;
        i !== null && sE(t, e, i, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), e[Er] ? .finishViewCreation(t), t.staticContentQueries && pE(t, e), t.staticViewQueries && tg(2, t.viewQuery, n);
        let s = t.components;
        s !== null && oO(e, s)
    } catch (r) {
        throw t.firstCreatePass && (t.incompleteFirstPass = !0, t.firstCreatePass = !1), r
    } finally {
        e[X] &= -5, em()
    }
}

function oO(t, e) {
    for (let n = 0; n < e.length; n++) iO(t, e[n])
}

function $u(t, e, n, r) {
    let i = pe(null);
    try {
        let s = e.tView,
            a = t[X] & 4096 ? 4096 : 16,
            c = Bu(t, s, n, a, null, e, null, null, r ? .injector ? ? null, r ? .embeddedViewInjector ? ? null, r ? .dehydratedView ? ? null),
            l = t[e.index];
        c[Na] = l;
        let u = t[Er];
        return u !== null && (c[Er] = u.createEmbeddedView(s)), mm(s, c, n), c
    } finally {
        pe(i)
    }
}

function vE(t, e) {
    let n = Tt + e;
    if (n < t.length) return t[n]
}

function Sa(t, e) {
    return !e || e.firstChild === null || kD(t)
}

function Wu(t, e, n, r = !0) {
    let i = e[ee];
    if (vR(i, e, t, n), r) {
        let o = Xp(n, t),
            a = e[Xe],
            c = um(a, t[zi]);
        c !== null && mR(i, t[Yt], a, e, c, o)
    }
    let s = e[io];
    s !== null && s.firstChild !== null && (s.firstChild = null)
}

function wE(t, e) {
    let n = Ca(t, e);
    return n !== void 0 && Uu(n[ee], n), n
}

function vu(t, e, n, r, i = !1) {
    for (; n !== null;) {
        let s = e[n.index];
        s !== null && r.push(Jn(s)), Ir(s) && aO(s, r);
        let o = n.type;
        if (o & 8) vu(t, e, n.child, r);
        else if (o & 32) {
            let a = lm(n, e),
                c;
            for (; c = a();) r.push(c)
        } else if (o & 16) {
            let a = YD(e, n);
            if (Array.isArray(a)) r.push(...a);
            else {
                let c = Ea(e[mn]);
                vu(c[ee], c, a, r, !0)
            }
        }
        n = i ? n.projectionNext : n.next
    }
    return r
}

function aO(t, e) {
    for (let n = Tt; n < t.length; n++) {
        let r = t[n],
            i = r[ee].firstChild;
        i !== null && vu(r[ee], r, i, e)
    }
    t[zi] !== t[Mr] && e.push(t[zi])
}
var _E = [];

function cO(t) {
    return t[Bi] ? ? lO(t)
}

function lO(t) {
    let e = _E.pop() ? ? Object.create(dO);
    return e.lView = t, e
}

function uO(t) {
    t.lView[Bi] !== t && (t.lView = null, _E.push(t))
}
var dO = Q(_({}, vl), {
        consumerIsAlwaysLive: !0,
        consumerMarkedDirty: t => {
            Da(t.lView)
        },
        consumerOnSignalRead() {
            this.lView[Bi] = this
        }
    }),
    bE = 100;

function DE(t, e = !0, n = 0) {
    let r = t[kn],
        i = r.rendererFactory,
        s = !1;
    s || i.begin ? .();
    try {
        hO(t, n)
    } catch (o) {
        throw e && yE(t, o), o
    } finally {
        s || (i.end ? .(), r.inlineEffectRunner ? .flush())
    }
}

function hO(t, e) {
    ng(t, e);
    let n = 0;
    for (; Kg(t);) {
        if (n === bE) throw new S(103, !1);
        n++, ng(t, 1)
    }
}

function fO(t, e, n, r) {
    let i = e[X];
    if ((i & 256) === 256) return;
    let s = !1;
    !s && e[kn].inlineEffectRunner ? .flush(), Xg(e);
    let o = null,
        a = null;
    !s && pO(t) && (a = cO(e), o = Kf(a));
    try {
        lD(e), S1(t.bindingStartIndex), n !== null && sE(t, e, n, 2, r);
        let c = (i & 3) === 3;
        if (!s)
            if (c) {
                let d = t.preOrderCheckHooks;
                d !== null && tu(e, d, null)
            } else {
                let d = t.preOrderHooks;
                d !== null && nu(e, d, 0, null), Cp(e, 0)
            }
        if (gO(e), EE(e, 0), t.contentQueries !== null && pE(t, e), !s)
            if (c) {
                let d = t.contentCheckHooks;
                d !== null && tu(e, d)
            } else {
                let d = t.contentHooks;
                d !== null && nu(e, d, 1), Cp(e, 1)
            }
        RR(t, e);
        let l = t.components;
        l !== null && SE(e, l, 0);
        let u = t.viewQuery;
        if (u !== null && tg(2, u, r), !s)
            if (c) {
                let d = t.viewCheckHooks;
                d !== null && tu(e, d)
            } else {
                let d = t.viewHooks;
                d !== null && nu(e, d, 2), Cp(e, 2)
            }
        if (t.firstUpdatePass === !0 && (t.firstUpdatePass = !1), e[Ep]) {
            for (let d of e[Ep]) d();
            e[Ep] = null
        }
        s || (e[X] &= -73)
    } catch (c) {
        throw Da(e), c
    } finally {
        a !== null && (Yf(a, o), uO(a)), em()
    }
}

function pO(t) {
    return t.type !== 2
}

function EE(t, e) {
    for (let n = LD(t); n !== null; n = VD(n))
        for (let r = Tt; r < n.length; r++) {
            let i = n[r];
            CE(i, e)
        }
}

function gO(t) {
    for (let e = LD(t); e !== null; e = VD(e)) {
        if (!(e[X] & Gg.HasTransplantedViews)) continue;
        let n = e[oo];
        for (let r = 0; r < n.length; r++) {
            let i = n[r],
                s = i[wt];
            m1(i)
        }
    }
}

function mO(t, e, n) {
    let r = ti(e, t);
    CE(r, n)
}

function CE(t, e) {
    qg(t) && ng(t, e)
}

function ng(t, e) {
    let r = t[ee],
        i = t[X],
        s = t[Bi],
        o = !!(e === 0 && i & 16);
    if (o || = !!(i & 64 && e === 0), o || = !!(i & 1024), o || = !!(s ? .dirty && Jf(s)), s && (s.dirty = !1), t[X] &= -9217, o) fO(r, t, r.template, t[It]);
    else if (i & 8192) {
        EE(t, 1);
        let a = r.components;
        a !== null && SE(t, a, 1)
    }
}

function SE(t, e, n) {
    for (let r = 0; r < e.length; r++) mO(t, e[r], n)
}

function ym(t) {
    for (t[kn].changeDetectionScheduler ? .notify(); t;) {
        t[X] |= 64;
        let e = Ea(t);
        if (s1(t) && !e) return t;
        t = e
    }
    return null
}
var Zi = class {
        get rootNodes() {
            let e = this._lView,
                n = e[ee];
            return vu(n, e, n.firstChild, [])
        }
        constructor(e, n, r = !0) {
            this._lView = e, this._cdRefInjectingView = n, this.notifyErrorHandler = r, this._appRef = null, this._attachedToViewContainer = !1
        }
        get context() {
            return this._lView[It]
        }
        set context(e) {
            this._lView[It] = e
        }
        get destroyed() {
            return (this._lView[X] & 256) === 256
        }
        destroy() {
            if (this._appRef) this._appRef.detachView(this);
            else if (this._attachedToViewContainer) {
                let e = this._lView[wt];
                if (Ir(e)) {
                    let n = e[uu],
                        r = n ? n.indexOf(this) : -1;
                    r > -1 && (Ca(e, r), cu(n, r))
                }
                this._attachedToViewContainer = !1
            }
            Uu(this._lView[ee], this._lView)
        }
        onDestroy(e) {
            uD(this._lView, e)
        }
        markForCheck() {
            ym(this._cdRefInjectingView || this._lView)
        }
        detach() {
            this._lView[X] &= -129
        }
        reattach() {
            Wp(this._lView), this._lView[X] |= 128
        }
        detectChanges() {
            this._lView[X] |= 1024, DE(this._lView, this.notifyErrorHandler)
        }
        checkNoChanges() {}
        attachToViewContainerRef() {
            if (this._appRef) throw new S(902, !1);
            this._attachedToViewContainer = !0
        }
        detachFromAppRef() {
            this._appRef = null, GD(this._lView[ee], this._lView)
        }
        attachToAppRef(e) {
            if (this._attachedToViewContainer) throw new S(902, !1);
            this._appRef = e, Wp(this._lView)
        }
    },
    vn = (() => {
        let e = class e {};
        e.__NG_ELEMENT_ID__ = wO;
        let t = e;
        return t
    })(),
    yO = vn,
    vO = class extends yO {
        constructor(e, n, r) {
            super(), this._declarationLView = e, this._declarationTContainer = n, this.elementRef = r
        }
        get ssrId() {
            return this._declarationTContainer.tView ? .ssrId || null
        }
        createEmbeddedView(e, n) {
            return this.createEmbeddedViewImpl(e, n)
        }
        createEmbeddedViewImpl(e, n, r) {
            let i = $u(this._declarationLView, this._declarationTContainer, e, {
                embeddedViewInjector: n,
                dehydratedView: r
            });
            return new Zi(i)
        }
    };

function wO() {
    return vm(Jt(), he())
}

function vm(t, e) {
    return t.type & 4 ? new vO(e, t, mo(t, e)) : null
}
var Bq = new RegExp(`^(\\d+)*(${sR}|${iR})*(.*)`);
var _O = () => null;

function Ma(t, e) {
    return _O(t, e)
}
var ao = class {},
    rg = class {},
    wu = class {};

function bO(t) {
    let e = Error(`No component factory found for ${Lt(t)}.`);
    return e[DO] = t, e
}
var DO = "ngComponent";
var ig = class {
        resolveComponentFactory(e) {
            throw bO(e)
        }
    },
    yo = (() => {
        let e = class e {};
        e.NULL = new ig;
        let t = e;
        return t
    })(),
    Pn = class {},
    Wt = (() => {
        let e = class e {
            constructor() {
                this.destroyNode = null
            }
        };
        e.__NG_ELEMENT_ID__ = () => EO();
        let t = e;
        return t
    })();

function EO() {
    let t = he(),
        e = Jt(),
        n = ti(e.index, t);
    return (Vi(n) ? n : t)[Xe]
}
var CO = (() => {
        let e = class e {};
        e.\u0275prov = I({
            token: e,
            providedIn: "root",
            factory: () => null
        });
        let t = e;
        return t
    })(),
    xp = {};
var db = new Set;

function xr(t) {
    db.has(t) || (db.add(t), performance ? .mark ? .("mark_feature_usage", {
        detail: {
            feature: t
        }
    }))
}

function hb(...t) {}

function SO() {
    let t = typeof Kt.requestAnimationFrame == "function",
        e = Kt[t ? "requestAnimationFrame" : "setTimeout"],
        n = Kt[t ? "cancelAnimationFrame" : "clearTimeout"];
    if (typeof Zone < "u" && e && n) {
        let r = e[Zone.__symbol__("OriginalDelegate")];
        r && (e = r);
        let i = n[Zone.__symbol__("OriginalDelegate")];
        i && (n = i)
    }
    return {
        nativeRequestAnimationFrame: e,
        nativeCancelAnimationFrame: n
    }
}
var ye = class t {
        constructor({
            enableLongStackTrace: e = !1,
            shouldCoalesceEventChangeDetection: n = !1,
            shouldCoalesceRunChangeDetection: r = !1
        }) {
            if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new oe(!1), this.onMicrotaskEmpty = new oe(!1), this.onStable = new oe(!1), this.onError = new oe(!1), typeof Zone > "u") throw new S(908, !1);
            Zone.assertZonePatched();
            let i = this;
            i._nesting = 0, i._outer = i._inner = Zone.current, Zone.TaskTrackingZoneSpec && (i._inner = i._inner.fork(new Zone.TaskTrackingZoneSpec)), e && Zone.longStackTraceZoneSpec && (i._inner = i._inner.fork(Zone.longStackTraceZoneSpec)), i.shouldCoalesceEventChangeDetection = !r && n, i.shouldCoalesceRunChangeDetection = r, i.lastRequestAnimationFrameId = -1, i.nativeRequestAnimationFrame = SO().nativeRequestAnimationFrame, TO(i)
        }
        static isInAngularZone() {
            return typeof Zone < "u" && Zone.current.get("isAngularZone") === !0
        }
        static assertInAngularZone() {
            if (!t.isInAngularZone()) throw new S(909, !1)
        }
        static assertNotInAngularZone() {
            if (t.isInAngularZone()) throw new S(909, !1)
        }
        run(e, n, r) {
            return this._inner.run(e, n, r)
        }
        runTask(e, n, r, i) {
            let s = this._inner,
                o = s.scheduleEventTask("NgZoneEvent: " + i, e, MO, hb, hb);
            try {
                return s.runTask(o, n, r)
            } finally {
                s.cancelTask(o)
            }
        }
        runGuarded(e, n, r) {
            return this._inner.runGuarded(e, n, r)
        }
        runOutsideAngular(e) {
            return this._outer.run(e)
        }
    },
    MO = {};

function wm(t) {
    if (t._nesting == 0 && !t.hasPendingMicrotasks && !t.isStable) try {
        t._nesting++, t.onMicrotaskEmpty.emit(null)
    } finally {
        if (t._nesting--, !t.hasPendingMicrotasks) try {
            t.runOutsideAngular(() => t.onStable.emit(null))
        } finally {
            t.isStable = !0
        }
    }
}

function IO(t) {
    t.isCheckStableRunning || t.lastRequestAnimationFrameId !== -1 || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(Kt, () => {
        t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
            t.lastRequestAnimationFrameId = -1, sg(t), t.isCheckStableRunning = !0, wm(t), t.isCheckStableRunning = !1
        }, void 0, () => {}, () => {})), t.fakeTopEventTask.invoke()
    }), sg(t))
}

function TO(t) {
    let e = () => {
        IO(t)
    };
    t._inner = t._inner.fork({
        name: "angular",
        properties: {
            isAngularZone: !0
        },
        onInvokeTask: (n, r, i, s, o, a) => {
            if (xO(a)) return n.invokeTask(i, s, o, a);
            try {
                return fb(t), n.invokeTask(i, s, o, a)
            } finally {
                (t.shouldCoalesceEventChangeDetection && s.type === "eventTask" || t.shouldCoalesceRunChangeDetection) && e(), pb(t)
            }
        },
        onInvoke: (n, r, i, s, o, a, c) => {
            try {
                return fb(t), n.invoke(i, s, o, a, c)
            } finally {
                t.shouldCoalesceRunChangeDetection && e(), pb(t)
            }
        },
        onHasTask: (n, r, i, s) => {
            n.hasTask(i, s), r === i && (s.change == "microTask" ? (t._hasPendingMicrotasks = s.microTask, sg(t), wm(t)) : s.change == "macroTask" && (t.hasPendingMacrotasks = s.macroTask))
        },
        onHandleError: (n, r, i, s) => (n.handleError(i, s), t.runOutsideAngular(() => t.onError.emit(s)), !1)
    })
}

function sg(t) {
    t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && t.lastRequestAnimationFrameId !== -1 ? t.hasPendingMicrotasks = !0 : t.hasPendingMicrotasks = !1
}

function fb(t) {
    t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null))
}

function pb(t) {
    t._nesting--, wm(t)
}
var og = class {
    constructor() {
        this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new oe, this.onMicrotaskEmpty = new oe, this.onStable = new oe, this.onError = new oe
    }
    run(e, n, r) {
        return e.apply(n, r)
    }
    runGuarded(e, n, r) {
        return e.apply(n, r)
    }
    runOutsideAngular(e) {
        return e()
    }
    runTask(e, n, r, i) {
        return e.apply(n, r)
    }
};

function xO(t) {
    return !Array.isArray(t) || t.length !== 1 ? !1 : t[0].data ? .__ignore_ng_zone__ === !0
}

function AO(t = "zone.js", e) {
    return t === "noop" ? new og : t === "zone.js" ? new ye(e) : t
}
var Js = function(t) {
        return t[t.EarlyRead = 0] = "EarlyRead", t[t.Write = 1] = "Write", t[t.MixedReadWrite = 2] = "MixedReadWrite", t[t.Read = 3] = "Read", t
    }(Js || {}),
    NO = {
        destroy() {}
    };

function _m(t, e) {
    !e && Hg(_m);
    let n = e ? .injector ? ? M(bt);
    if (!dR(n)) return NO;
    xr("NgAfterNextRender");
    let r = n.get(bm),
        i = r.handler ? ? = new cg,
        s = e ? .phase ? ? Js.MixedReadWrite,
        o = () => {
            i.unregister(c), a()
        },
        a = n.get(go).onDestroy(o),
        c = Ln(n, () => new ag(s, () => {
            o(), t()
        }));
    return i.register(c), {
        destroy: o
    }
}
var ag = class {
        constructor(e, n) {
            this.phase = e, this.callbackFn = n, this.zone = M(ye), this.errorHandler = M(yn, {
                optional: !0
            }), M(ao, {
                optional: !0
            }) ? .notify(1)
        }
        invoke() {
            try {
                this.zone.runOutsideAngular(this.callbackFn)
            } catch (e) {
                this.errorHandler ? .handleError(e)
            }
        }
    },
    cg = class {
        constructor() {
            this.executingCallbacks = !1, this.buckets = {
                [Js.EarlyRead]: new Set,
                [Js.Write]: new Set,
                [Js.MixedReadWrite]: new Set,
                [Js.Read]: new Set
            }, this.deferredCallbacks = new Set
        }
        register(e) {
            (this.executingCallbacks ? this.deferredCallbacks : this.buckets[e.phase]).add(e)
        }
        unregister(e) {
            this.buckets[e.phase].delete(e), this.deferredCallbacks.delete(e)
        }
        execute() {
            this.executingCallbacks = !0;
            for (let e of Object.values(this.buckets))
                for (let n of e) n.invoke();
            this.executingCallbacks = !1;
            for (let e of this.deferredCallbacks) this.buckets[e.phase].add(e);
            this.deferredCallbacks.clear()
        }
        destroy() {
            for (let e of Object.values(this.buckets)) e.clear();
            this.deferredCallbacks.clear()
        }
    },
    bm = (() => {
        let e = class e {
            constructor() {
                this.handler = null, this.internalCallbacks = []
            }
            execute() {
                this.executeInternalCallbacks(), this.handler ? .execute()
            }
            executeInternalCallbacks() {
                let r = [...this.internalCallbacks];
                this.internalCallbacks.length = 0;
                for (let i of r) i()
            }
            ngOnDestroy() {
                this.handler ? .destroy(), this.handler = null, this.internalCallbacks.length = 0
            }
        };
        e.\u0275prov = I({
            token: e,
            providedIn: "root",
            factory: () => new e
        });
        let t = e;
        return t
    })();

function lg(t, e, n) {
    let r = n ? t.styles : null,
        i = n ? t.classes : null,
        s = 0;
    if (e !== null)
        for (let o = 0; o < e.length; o++) {
            let a = e[o];
            if (typeof a == "number") s = a;
            else if (s == 1) i = W_(i, a);
            else if (s == 2) {
                let c = a,
                    l = e[++o];
                r = W_(r, c + ": " + l + ";")
            }
        }
    n ? t.styles = r : t.stylesWithoutHost = r, n ? t.classes = i : t.classesWithoutHost = i
}
var _u = class extends yo {
    constructor(e) {
        super(), this.ngModule = e
    }
    resolveComponentFactory(e) {
        let n = Jr(e);
        return new co(n, this.ngModule)
    }
};

function gb(t) {
    let e = [];
    for (let n in t) {
        if (!t.hasOwnProperty(n)) continue;
        let r = t[n];
        r !== void 0 && e.push({
            propName: Array.isArray(r) ? r[0] : r,
            templateName: n
        })
    }
    return e
}

function RO(t) {
    let e = t.toLowerCase();
    return e === "svg" ? l1 : e === "math" ? u1 : null
}
var ug = class {
        constructor(e, n) {
            this.injector = e, this.parentInjector = n
        }
        get(e, n, r) {
            r = Nu(r);
            let i = this.injector.get(e, xp, r);
            return i !== xp || n === xp ? i : this.parentInjector.get(e, n, r)
        }
    },
    co = class extends wu {
        get inputs() {
            let e = this.componentDef,
                n = e.inputTransforms,
                r = gb(e.inputs);
            if (n !== null)
                for (let i of r) n.hasOwnProperty(i.propName) && (i.transform = n[i.propName]);
            return r
        }
        get outputs() {
            return gb(this.componentDef.outputs)
        }
        constructor(e, n) {
            super(), this.componentDef = e, this.ngModule = n, this.componentType = e.type, this.selector = BN(e.selectors), this.ngContentSelectors = e.ngContentSelectors ? e.ngContentSelectors : [], this.isBoundToModule = !!n
        }
        create(e, n, r, i) {
            let s = pe(null);
            try {
                i = i || this.ngModule;
                let o = i instanceof Ut ? i : i ? .injector;
                o && this.componentDef.getStandaloneInjector !== null && (o = this.componentDef.getStandaloneInjector(o) || o);
                let a = o ? new ug(e, o) : e,
                    c = a.get(Pn, null);
                if (c === null) throw new S(407, !1);
                let l = a.get(CO, null),
                    u = a.get(bm, null),
                    d = a.get(ao, null),
                    h = {
                        rendererFactory: c,
                        sanitizer: l,
                        inlineEffectRunner: null,
                        afterRenderEventManager: u,
                        changeDetectionScheduler: d
                    },
                    f = c.createRenderer(null, this.componentDef),
                    p = this.componentDef.selectors[0][0] || "div",
                    g = r ? kR(f, r, this.componentDef.encapsulation, a) : HD(f, p, RO(p)),
                    m = 512;
                this.componentDef.signals ? m |= 4096 : this.componentDef.onPush || (m |= 16);
                let y = null;
                g !== null && (y = am(g, a, !0));
                let E = fm(0, null, null, 1, 0, null, null, null, null, null, null),
                    T = Bu(null, E, null, m, null, null, h, f, a, null, y);
                Xg(T);
                let w, N;
                try {
                    let L = this.componentDef,
                        D, j = null;
                    L.findHostDirectiveDefs ? (D = [], j = new Map, L.findHostDirectiveDefs(L, D, j), D.push(L)) : D = [L];
                    let Y = OO(T, g),
                        H = FO(Y, g, L, D, T, h, f);
                    N = Qg(E, $t), g && LO(f, L, g, r), n !== void 0 && VO(N, this.ngContentSelectors, n), w = PO(H, L, D, j, T, [UO]), mm(E, T, null)
                } finally {
                    em()
                }
                return new dg(this.componentType, w, mo(N, T), T, N)
            } finally {
                pe(s)
            }
        }
    },
    dg = class extends rg {
        constructor(e, n, r, i, s) {
            super(), this.location = r, this._rootLView = i, this._tNode = s, this.previousInputValues = null, this.instance = n, this.hostView = this.changeDetectorRef = new Zi(i, void 0, !1), this.componentType = e
        }
        setInput(e, n) {
            let r = this._tNode.inputs,
                i;
            if (r !== null && (i = r[e])) {
                if (this.previousInputValues ? ? = new Map, this.previousInputValues.has(e) && Object.is(this.previousInputValues.get(e), n)) return;
                let s = this._rootLView;
                gm(s[ee], s, i, e, n), this.previousInputValues.set(e, n);
                let o = ti(this._tNode.index, s);
                ym(o)
            }
        }
        get injector() {
            return new Ui(this._tNode, this._rootLView)
        }
        destroy() {
            this.hostView.destroy()
        }
        onDestroy(e) {
            this.hostView.onDestroy(e)
        }
    };

function OO(t, e) {
    let n = t[ee],
        r = $t;
    return t[r] = e, ka(n, r, 2, "#host", null)
}

function FO(t, e, n, r, i, s, o) {
    let a = i[ee];
    kO(r, t, e, o);
    let c = null;
    e !== null && (c = am(e, i[so]));
    let l = s.rendererFactory.createRenderer(e, n),
        u = 16;
    n.signals ? u = 4096 : n.onPush && (u = 64);
    let d = Bu(i, lE(n), null, u, i[t.index], t, s, l, null, null, c);
    return a.firstCreatePass && eg(a, t, r.length - 1), zu(i, d), i[t.index] = d
}

function kO(t, e, n, r) {
    for (let i of t) e.mergedAttrs = va(e.mergedAttrs, i.hostAttrs);
    e.mergedAttrs !== null && (lg(e, e.mergedAttrs, !0), n !== null && eE(r, n, e))
}

function PO(t, e, n, r, i, s) {
    let o = Jt(),
        a = i[ee],
        c = wn(o, i);
    dE(a, i, o, n, null, r);
    for (let u = 0; u < n.length; u++) {
        let d = o.directiveStart + u,
            h = Hi(i, a, d, o);
        Gi(h, i)
    }
    hE(a, i, o), c && Gi(c, i);
    let l = Hi(i, a, o.directiveStart + o.componentOffset, o);
    if (t[It] = i[It] = l, s !== null)
        for (let u of s) u(l, e);
    return oE(a, o, i), l
}

function LO(t, e, n, r) {
    if (r) Up(t, n, ["ng-version", "17.3.1"]);
    else {
        let {
            attrs: i,
            classes: s
        } = zN(e.selectors[0]);
        i && Up(t, n, i), s && s.length > 0 && XD(t, n, s.join(" "))
    }
}

function VO(t, e, n) {
    let r = t.projection = [];
    for (let i = 0; i < e.length; i++) {
        let s = n[i];
        r.push(s != null ? Array.from(s) : null)
    }
}

function UO() {
    let t = Jt();
    rm(he()[ee], t)
}
var Un = (() => {
    let e = class e {};
    e.__NG_ELEMENT_ID__ = jO;
    let t = e;
    return t
})();

function jO() {
    let t = Jt();
    return IE(t, he())
}
var BO = Un,
    ME = class extends BO {
        constructor(e, n, r) {
            super(), this._lContainer = e, this._hostTNode = n, this._hostLView = r
        }
        get element() {
            return mo(this._hostTNode, this._hostLView)
        }
        get injector() {
            return new Ui(this._hostTNode, this._hostLView)
        }
        get parentInjector() {
            let e = im(this._hostTNode, this._hostLView);
            if (CD(e)) {
                let n = fu(e, this._hostLView),
                    r = hu(e),
                    i = n[ee].data[r + 8];
                return new Ui(i, n)
            } else return new Ui(null, this._hostLView)
        }
        clear() {
            for (; this.length > 0;) this.remove(this.length - 1)
        }
        get(e) {
            let n = mb(this._lContainer);
            return n !== null && n[e] || null
        }
        get length() {
            return this._lContainer.length - Tt
        }
        createEmbeddedView(e, n, r) {
            let i, s;
            typeof r == "number" ? i = r : r != null && (i = r.index, s = r.injector);
            let o = Ma(this._lContainer, e.ssrId),
                a = e.createEmbeddedViewImpl(n || {}, s, o);
            return this.insertImpl(a, i, Sa(this._hostTNode, o)), a
        }
        createComponent(e, n, r, i, s) {
            let o = e && !i1(e),
                a;
            if (o) a = n;
            else {
                let p = n || {};
                a = p.index, r = p.injector, i = p.projectableNodes, s = p.environmentInjector || p.ngModuleRef
            }
            let c = o ? e : new co(Jr(e)),
                l = r || this.parentInjector;
            if (!s && c.ngModule == null) {
                let g = (o ? l : this.parentInjector).get(Ut, null);
                g && (s = g)
            }
            let u = Jr(c.componentType ? ? {}),
                d = Ma(this._lContainer, u ? .id ? ? null),
                h = d ? .firstChild ? ? null,
                f = c.create(l, i, h, s);
            return this.insertImpl(f.hostView, a, Sa(this._hostTNode, d)), f
        }
        insert(e, n) {
            return this.insertImpl(e, n, !0)
        }
        insertImpl(e, n, r) {
            let i = e._lView;
            if (g1(i)) {
                let a = this.indexOf(e);
                if (a !== -1) this.detach(a);
                else {
                    let c = i[wt],
                        l = new ME(c, c[Yt], c[wt]);
                    l.detach(l.indexOf(e))
                }
            }
            let s = this._adjustIndex(n),
                o = this._lContainer;
            return Wu(o, i, s, r), e.attachToViewContainerRef(), Vb(Ap(o), s, e), e
        }
        move(e, n) {
            return this.insert(e, n)
        }
        indexOf(e) {
            let n = mb(this._lContainer);
            return n !== null ? n.indexOf(e) : -1
        }
        remove(e) {
            let n = this._adjustIndex(e, -1),
                r = Ca(this._lContainer, n);
            r && (cu(Ap(this._lContainer), n), Uu(r[ee], r))
        }
        detach(e) {
            let n = this._adjustIndex(e, -1),
                r = Ca(this._lContainer, n);
            return r && cu(Ap(this._lContainer), n) != null ? new Zi(r) : null
        }
        _adjustIndex(e, n = 0) {
            return e ? ? this.length + n
        }
    };

function mb(t) {
    return t[uu]
}

function Ap(t) {
    return t[uu] || (t[uu] = [])
}

function IE(t, e) {
    let n, r = e[t.index];
    return Ir(r) ? n = r : (n = fE(r, e, null, t), e[t.index] = n, zu(e, n)), $O(n, e, t, r), new ME(n, t, e)
}

function zO(t, e) {
    let n = t[Xe],
        r = n.createComment(""),
        i = wn(e, t),
        s = um(n, i);
    return yu(n, s, r, CR(n, i), !1), r
}
var $O = GO,
    WO = () => !1;

function HO(t, e, n) {
    return WO(t, e, n)
}

function GO(t, e, n, r) {
    if (t[zi]) return;
    let i;
    n.type & 8 ? i = Jn(r) : i = zO(e, n), t[zi] = i
}
var hg = class t {
        constructor(e) {
            this.queryList = e, this.matches = null
        }
        clone() {
            return new t(this.queryList)
        }
        setDirty() {
            this.queryList.setDirty()
        }
    },
    fg = class t {
        constructor(e = []) {
            this.queries = e
        }
        createEmbeddedView(e) {
            let n = e.queries;
            if (n !== null) {
                let r = e.contentQueries !== null ? e.contentQueries[0] : n.length,
                    i = [];
                for (let s = 0; s < r; s++) {
                    let o = n.getByIndex(s),
                        a = this.queries[o.indexInDeclarationView];
                    i.push(a.clone())
                }
                return new t(i)
            }
            return null
        }
        insertView(e) {
            this.dirtyQueriesWithMatches(e)
        }
        detachView(e) {
            this.dirtyQueriesWithMatches(e)
        }
        finishViewCreation(e) {
            this.dirtyQueriesWithMatches(e)
        }
        dirtyQueriesWithMatches(e) {
            for (let n = 0; n < this.queries.length; n++) Dm(e, n).matches !== null && this.queries[n].setDirty()
        }
    },
    pg = class {
        constructor(e, n, r = null) {
            this.flags = n, this.read = r, typeof e == "string" ? this.predicate = eF(e) : this.predicate = e
        }
    },
    gg = class t {
        constructor(e = []) {
            this.queries = e
        }
        elementStart(e, n) {
            for (let r = 0; r < this.queries.length; r++) this.queries[r].elementStart(e, n)
        }
        elementEnd(e) {
            for (let n = 0; n < this.queries.length; n++) this.queries[n].elementEnd(e)
        }
        embeddedTView(e) {
            let n = null;
            for (let r = 0; r < this.length; r++) {
                let i = n !== null ? n.length : 0,
                    s = this.getByIndex(r).embeddedTView(e, i);
                s && (s.indexInDeclarationView = r, n !== null ? n.push(s) : n = [s])
            }
            return n !== null ? new t(n) : null
        }
        template(e, n) {
            for (let r = 0; r < this.queries.length; r++) this.queries[r].template(e, n)
        }
        getByIndex(e) {
            return this.queries[e]
        }
        get length() {
            return this.queries.length
        }
        track(e) {
            this.queries.push(e)
        }
    },
    mg = class t {
        constructor(e, n = -1) {
            this.metadata = e, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = n
        }
        elementStart(e, n) {
            this.isApplyingToNode(n) && this.matchTNode(e, n)
        }
        elementEnd(e) {
            this._declarationNodeIndex === e.index && (this._appliesToNextNode = !1)
        }
        template(e, n) {
            this.elementStart(e, n)
        }
        embeddedTView(e, n) {
            return this.isApplyingToNode(e) ? (this.crossesNgTemplate = !0, this.addMatch(-e.index, n), new t(this.metadata)) : null
        }
        isApplyingToNode(e) {
            if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
                let n = this._declarationNodeIndex,
                    r = e.parent;
                for (; r !== null && r.type & 8 && r.index !== n;) r = r.parent;
                return n === (r !== null ? r.index : -1)
            }
            return this._appliesToNextNode
        }
        matchTNode(e, n) {
            let r = this.metadata.predicate;
            if (Array.isArray(r))
                for (let i = 0; i < r.length; i++) {
                    let s = r[i];
                    this.matchTNodeWithReadOption(e, n, ZO(n, s)), this.matchTNodeWithReadOption(e, n, ru(n, e, s, !1, !1))
                } else r === vn ? n.type & 4 && this.matchTNodeWithReadOption(e, n, -1) : this.matchTNodeWithReadOption(e, n, ru(n, e, r, !1, !1))
        }
        matchTNodeWithReadOption(e, n, r) {
            if (r !== null) {
                let i = this.metadata.read;
                if (i !== null)
                    if (i === je || i === Un || i === vn && n.type & 4) this.addMatch(n.index, -2);
                    else {
                        let s = ru(n, e, i, !1, !1);
                        s !== null && this.addMatch(n.index, s)
                    }
                else this.addMatch(n.index, r)
            }
        }
        addMatch(e, n) {
            this.matches === null ? this.matches = [e, n] : this.matches.push(e, n)
        }
    };

function ZO(t, e) {
    let n = t.localNames;
    if (n !== null) {
        for (let r = 0; r < n.length; r += 2)
            if (n[r] === e) return n[r + 1]
    }
    return null
}

function QO(t, e) {
    return t.type & 11 ? mo(t, e) : t.type & 4 ? vm(t, e) : null
}

function qO(t, e, n, r) {
    return n === -1 ? QO(e, t) : n === -2 ? KO(t, e, r) : Hi(t, t[ee], n, e)
}

function KO(t, e, n) {
    if (n === je) return mo(e, t);
    if (n === vn) return vm(e, t);
    if (n === Un) return IE(e, t)
}

function TE(t, e, n, r) {
    let i = e[Er].queries[r];
    if (i.matches === null) {
        let s = t.data,
            o = n.matches,
            a = [];
        for (let c = 0; o !== null && c < o.length; c += 2) {
            let l = o[c];
            if (l < 0) a.push(null);
            else {
                let u = s[l];
                a.push(qO(e, u, o[c + 1], n.metadata.read))
            }
        }
        i.matches = a
    }
    return i.matches
}

function yg(t, e, n, r) {
    let i = t.queries.getByIndex(n),
        s = i.matches;
    if (s !== null) {
        let o = TE(t, e, i, n);
        for (let a = 0; a < s.length; a += 2) {
            let c = s[a];
            if (c > 0) r.push(o[a / 2]);
            else {
                let l = s[a + 1],
                    u = e[-c];
                for (let d = Tt; d < u.length; d++) {
                    let h = u[d];
                    h[Na] === h[wt] && yg(h[ee], h, l, r)
                }
                if (u[oo] !== null) {
                    let d = u[oo];
                    for (let h = 0; h < d.length; h++) {
                        let f = d[h];
                        yg(f[ee], f, l, r)
                    }
                }
            }
        }
    }
    return r
}

function YO(t, e) {
    return t[Er].queries[e].queryList
}

function JO(t, e, n) {
    let r = new Yp((n & 4) === 4);
    return VR(t, e, r, r.destroy), (e[Er] ? ? = new fg).queries.push(new hg(r)) - 1
}

function XO(t, e, n) {
    let r = ut();
    return r.firstCreatePass && (tF(r, new pg(t, e, n), -1), (e & 2) === 2 && (r.staticViewQueries = !0)), JO(r, he(), e)
}

function eF(t) {
    return t.split(",").map(e => e.trim())
}

function tF(t, e, n) {
    t.queries === null && (t.queries = new gg), t.queries.track(new mg(e, n))
}

function Dm(t, e) {
    return t.queries.getByIndex(e)
}

function nF(t, e) {
    let n = t[ee],
        r = Dm(n, e);
    return r.crossesNgTemplate ? yg(n, t, e, []) : TE(n, t, r, e)
}

function rF(t) {
    return typeof t == "function" && t[br] !== void 0
}

function Hu(t, e) {
    xr("NgSignals");
    let n = f_(t),
        r = n[br];
    return e ? .equal && (r.equal = e.equal), n.set = i => Xf(r, i), n.update = i => p_(r, i), n.asReadonly = iF.bind(n), n
}

function iF() {
    let t = this[br];
    if (t.readonlyFn === void 0) {
        let e = () => this();
        e[br] = t, t.readonlyFn = e
    }
    return t.readonlyFn
}

function xE(t) {
    return rF(t) && typeof t.set == "function"
}

function sF(t) {
    let e = [],
        n = new Map;

    function r(i) {
        let s = n.get(i);
        if (!s) {
            let o = t(i);
            n.set(i, s = o.then(lF))
        }
        return s
    }
    return bu.forEach((i, s) => {
        let o = [];
        i.templateUrl && o.push(r(i.templateUrl).then(l => {
            i.template = l
        }));
        let a = typeof i.styles == "string" ? [i.styles] : i.styles || [];
        if (i.styles = a, i.styleUrl && i.styleUrls ? .length) throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");
        if (i.styleUrls ? .length) {
            let l = i.styles.length,
                u = i.styleUrls;
            i.styleUrls.forEach((d, h) => {
                a.push(""), o.push(r(d).then(f => {
                    a[l + h] = f, u.splice(u.indexOf(d), 1), u.length == 0 && (i.styleUrls = void 0)
                }))
            })
        } else i.styleUrl && o.push(r(i.styleUrl).then(l => {
            a.push(l), i.styleUrl = void 0
        }));
        let c = Promise.all(o).then(() => uF(s));
        e.push(c)
    }), aF(), Promise.all(e).then(() => {})
}
var bu = new Map,
    oF = new Set;

function aF() {
    let t = bu;
    return bu = new Map, t
}

function cF() {
    return bu.size === 0
}

function lF(t) {
    return typeof t == "string" ? t : t.text()
}

function uF(t) {
    oF.delete(t)
}

function dF(t) {
    return Object.getPrototypeOf(t.prototype).constructor
}

function Ki(t) {
    let e = dF(t.type),
        n = !0,
        r = [t];
    for (; e;) {
        let i;
        if (Xr(t)) i = e.\u0275cmp || e.\u0275dir;
        else {
            if (e.\u0275cmp) throw new S(903, !1);
            i = e.\u0275dir
        }
        if (i) {
            if (n) {
                r.push(i);
                let o = t;
                o.inputs = Yl(t.inputs), o.inputTransforms = Yl(t.inputTransforms), o.declaredInputs = Yl(t.declaredInputs), o.outputs = Yl(t.outputs);
                let a = i.hostBindings;
                a && mF(t, a);
                let c = i.viewQuery,
                    l = i.contentQueries;
                if (c && pF(t, c), l && gF(t, l), hF(t, i), iN(t.outputs, i.outputs), Xr(i) && i.data.animation) {
                    let u = t.data;
                    u.animation = (u.animation || []).concat(i.data.animation)
                }
            }
            let s = i.features;
            if (s)
                for (let o = 0; o < s.length; o++) {
                    let a = s[o];
                    a && a.ngInherit && a(t), a === Ki && (n = !1)
                }
        }
        e = Object.getPrototypeOf(e)
    }
    fF(r)
}

function hF(t, e) {
    for (let n in e.inputs) {
        if (!e.inputs.hasOwnProperty(n) || t.inputs.hasOwnProperty(n)) continue;
        let r = e.inputs[n];
        if (r !== void 0 && (t.inputs[n] = r, t.declaredInputs[n] = e.declaredInputs[n], e.inputTransforms !== null)) {
            let i = Array.isArray(r) ? r[0] : r;
            if (!e.inputTransforms.hasOwnProperty(i)) continue;
            t.inputTransforms ? ? = {}, t.inputTransforms[i] = e.inputTransforms[i]
        }
    }
}

function fF(t) {
    let e = 0,
        n = null;
    for (let r = t.length - 1; r >= 0; r--) {
        let i = t[r];
        i.hostVars = e += i.hostVars, i.hostAttrs = va(i.hostAttrs, n = va(n, i.hostAttrs))
    }
}

function Yl(t) {
    return t === to ? {} : t === pn ? [] : t
}

function pF(t, e) {
    let n = t.viewQuery;
    n ? t.viewQuery = (r, i) => {
        e(r, i), n(r, i)
    } : t.viewQuery = e
}

function gF(t, e) {
    let n = t.contentQueries;
    n ? t.contentQueries = (r, i, s) => {
        e(r, i, s), n(r, i, s)
    } : t.contentQueries = e
}

function mF(t, e) {
    let n = t.hostBindings;
    n ? t.hostBindings = (r, i) => {
        e(r, i), n(r, i)
    } : t.hostBindings = e
}
var ei = class {},
    Ia = class {};
var Du = class extends ei {
        constructor(e, n, r) {
            super(), this._parent = n, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new _u(this);
            let i = Zb(e);
            this._bootstrapComponents = WD(i.bootstrap), this._r3Injector = OD(e, n, [{
                provide: ei,
                useValue: this
            }, {
                provide: yo,
                useValue: this.componentFactoryResolver
            }, ...r], Lt(e), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(e)
        }
        get injector() {
            return this._r3Injector
        }
        destroy() {
            let e = this._r3Injector;
            !e.destroyed && e.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null
        }
        onDestroy(e) {
            this.destroyCbs.push(e)
        }
    },
    Eu = class extends Ia {
        constructor(e) {
            super(), this.moduleType = e
        }
        create(e) {
            return new Du(this.moduleType, e, [])
        }
    };

function yF(t, e, n) {
    return new Du(t, e, n)
}
var vg = class extends ei {
    constructor(e) {
        super(), this.componentFactoryResolver = new _u(this), this.instance = null;
        let n = new wa([...e.providers, {
            provide: ei,
            useValue: this
        }, {
            provide: yo,
            useValue: this.componentFactoryResolver
        }], e.parent || Wg(), e.debugName, new Set(["environment"]));
        this.injector = n, e.runEnvironmentInitializers && n.resolveInjectorInitializers()
    }
    destroy() {
        this.injector.destroy()
    }
    onDestroy(e) {
        this.injector.onDestroy(e)
    }
};

function Gu(t, e, n = null) {
    return new vg({
        providers: t,
        parent: e,
        debugName: n,
        runEnvironmentInitializers: !0
    }).injector
}
var Yi = (() => {
    let e = class e {
        constructor() {
            this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new Ze(!1)
        }
        get _hasPendingTasks() {
            return this.hasPendingTasks.value
        }
        add() {
            this._hasPendingTasks || this.hasPendingTasks.next(!0);
            let r = this.taskId++;
            return this.pendingTasks.add(r), r
        }
        remove(r) {
            this.pendingTasks.delete(r), this.pendingTasks.size === 0 && this._hasPendingTasks && this.hasPendingTasks.next(!1)
        }
        ngOnDestroy() {
            this.pendingTasks.clear(), this._hasPendingTasks && this.hasPendingTasks.next(!1)
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
})();

function AE(t) {
    return Em(t) ? Array.isArray(t) || !(t instanceof Map) && Symbol.iterator in t : !1
}

function vF(t, e) {
    if (Array.isArray(t))
        for (let n = 0; n < t.length; n++) e(t[n]);
    else {
        let n = t[Symbol.iterator](),
            r;
        for (; !(r = n.next()).done;) e(r.value)
    }
}

function Em(t) {
    return t !== null && (typeof t == "function" || typeof t == "object")
}

function NE(t, e, n) {
    return t[e] = n
}

function wF(t, e) {
    return t[e]
}

function ri(t, e, n) {
    let r = t[e];
    return Object.is(r, n) ? !1 : (t[e] = n, !0)
}

function _F(t) {
    return (t.flags & 32) === 32
}

function bF(t, e, n, r, i, s, o, a, c) {
    let l = e.consts,
        u = ka(e, t, 4, o || null, du(l, a));
    uE(e, n, u, du(l, c)), rm(e, u);
    let d = u.tView = fm(2, u, r, i, s, e.directiveRegistry, e.pipeRegistry, null, e.schemas, l, null);
    return e.queries !== null && (e.queries.template(e, u), d.queries = e.queries.embeddedTView(u)), u
}

function _t(t, e, n, r, i, s, o, a) {
    let c = he(),
        l = ut(),
        u = t + $t,
        d = l.firstCreatePass ? bF(u, l, c, e, n, r, i, s, o) : l.data[u];
    Ra(d, !1);
    let h = DF(l, c, d, t);
    tm() && dm(l, c, h, d), Gi(h, c);
    let f = fE(h, c, h, d);
    return c[u] = f, zu(c, f), HO(f, d, c), Zg(d) && aE(l, c, d), o != null && cE(c, d, a), _t
}
var DF = EF;

function EF(t, e, n, r) {
    return nm(!0), e[Xe].createComment("")
}

function vo(t, e, n, r) {
    let i = he(),
        s = po();
    if (ri(i, s, e)) {
        let o = ut(),
            a = Pu();
        XR(a, i, t, e, n, r)
    }
    return vo
}

function RE(t, e, n, r) {
    return ri(t, po(), n) ? e + Au(n) + r : Tr
}

function Jl(t, e) {
    return t << 17 | e << 2
}

function Qi(t) {
    return t >> 17 & 32767
}

function CF(t) {
    return (t & 2) == 2
}

function SF(t, e) {
    return t & 131071 | e << 17
}

function wg(t) {
    return t | 2
}

function lo(t) {
    return (t & 131068) >> 2
}

function Np(t, e) {
    return t & -131069 | e << 2
}

function MF(t) {
    return (t & 1) === 1
}

function _g(t) {
    return t | 1
}

function IF(t, e, n, r, i, s) {
    let o = s ? e.classBindings : e.styleBindings,
        a = Qi(o),
        c = lo(o);
    t[r] = n;
    let l = !1,
        u;
    if (Array.isArray(n)) {
        let d = n;
        u = d[1], (u === null || Aa(d, u) > 0) && (l = !0)
    } else u = n;
    if (i)
        if (c !== 0) {
            let h = Qi(t[a + 1]);
            t[r + 1] = Jl(h, a), h !== 0 && (t[h + 1] = Np(t[h + 1], r)), t[a + 1] = SF(t[a + 1], r)
        } else t[r + 1] = Jl(a, 0), a !== 0 && (t[a + 1] = Np(t[a + 1], r)), a = r;
    else t[r + 1] = Jl(c, 0), a === 0 ? a = r : t[c + 1] = Np(t[c + 1], r), c = r;
    l && (t[r + 1] = wg(t[r + 1])), yb(t, u, r, !0), yb(t, u, r, !1), TF(e, u, t, r, s), o = Jl(a, c), s ? e.classBindings = o : e.styleBindings = o
}

function TF(t, e, n, r, i) {
    let s = i ? t.residualClasses : t.residualStyles;
    s != null && typeof e == "string" && Aa(s, e) >= 0 && (n[r + 1] = _g(n[r + 1]))
}

function yb(t, e, n, r) {
    let i = t[n + 1],
        s = e === null,
        o = r ? Qi(i) : lo(i),
        a = !1;
    for (; o !== 0 && (a === !1 || s);) {
        let c = t[o],
            l = t[o + 1];
        xF(c, e) && (a = !0, t[o + 1] = r ? _g(l) : wg(l)), o = r ? Qi(l) : lo(l)
    }
    a && (t[n + 1] = r ? wg(i) : _g(i))
}

function xF(t, e) {
    return t === null || e == null || (Array.isArray(t) ? t[1] : t) === e ? !0 : Array.isArray(t) && typeof e == "string" ? Aa(t, e) >= 0 : !1
}

function Ke(t, e, n) {
    let r = he(),
        i = po();
    if (ri(r, i, e)) {
        let s = ut(),
            o = Pu();
        pm(s, o, r, t, e, r[Xe], n, !1)
    }
    return Ke
}

function vb(t, e, n, r, i) {
    let s = e.inputs,
        o = i ? "class" : "style";
    gm(t, n, s[o], o, r)
}

function wo(t, e) {
    return AF(t, e, null, !0), wo
}

function AF(t, e, n, r) {
    let i = he(),
        s = ut(),
        o = M1(2);
    if (s.firstUpdatePass && RF(s, t, o, r), e !== Tr && ri(i, o, e)) {
        let a = s.data[qi()];
        LF(s, a, i, i[Xe], t, i[o + 1] = VF(e, n), r, o)
    }
}

function NF(t, e) {
    return e >= t.expandoStartIndex
}

function RF(t, e, n, r) {
    let i = t.data;
    if (i[n + 1] === null) {
        let s = i[qi()],
            o = NF(t, n);
        UF(s, r) && e === null && !o && (e = !1), e = OF(i, s, e, r), IF(i, s, e, n, o, r)
    }
}

function OF(t, e, n, r) {
    let i = A1(t),
        s = r ? e.residualClasses : e.residualStyles;
    if (i === null)(r ? e.classBindings : e.styleBindings) === 0 && (n = Rp(null, t, e, n, r), n = Ta(n, e.attrs, r), s = null);
    else {
        let o = e.directiveStylingLast;
        if (o === -1 || t[o] !== i)
            if (n = Rp(i, t, e, n, r), s === null) {
                let c = FF(t, e, r);
                c !== void 0 && Array.isArray(c) && (c = Rp(null, t, e, c[1], r), c = Ta(c, e.attrs, r), kF(t, e, r, c))
            } else s = PF(t, e, r)
    }
    return s !== void 0 && (r ? e.residualClasses = s : e.residualStyles = s), n
}

function FF(t, e, n) {
    let r = n ? e.classBindings : e.styleBindings;
    if (lo(r) !== 0) return t[Qi(r)]
}

function kF(t, e, n, r) {
    let i = n ? e.classBindings : e.styleBindings;
    t[Qi(i)] = r
}

function PF(t, e, n) {
    let r, i = e.directiveEnd;
    for (let s = 1 + e.directiveStylingLast; s < i; s++) {
        let o = t[s].hostAttrs;
        r = Ta(r, o, n)
    }
    return Ta(r, e.attrs, n)
}

function Rp(t, e, n, r, i) {
    let s = null,
        o = n.directiveEnd,
        a = n.directiveStylingLast;
    for (a === -1 ? a = n.directiveStart : a++; a < o && (s = e[a], r = Ta(r, s.hostAttrs, i), s !== t);) a++;
    return t !== null && (n.directiveStylingLast = a), r
}

function Ta(t, e, n) {
    let r = n ? 1 : 2,
        i = -1;
    if (e !== null)
        for (let s = 0; s < e.length; s++) {
            let o = e[s];
            typeof o == "number" ? i = o : i === r && (Array.isArray(t) || (t = t === void 0 ? [] : ["", t]), IN(t, o, n ? !0 : e[++s]))
        }
    return t === void 0 ? null : t
}

function LF(t, e, n, r, i, s, o, a) {
    if (!(e.type & 3)) return;
    let c = t.data,
        l = c[a + 1],
        u = MF(l) ? wb(c, e, n, i, lo(l), o) : void 0;
    if (!Cu(u)) {
        Cu(s) || CF(l) && (s = wb(c, null, n, i, a, o));
        let d = cD(qi(), n);
        AR(r, o, d, i, s)
    }
}

function wb(t, e, n, r, i, s) {
    let o = e === null,
        a;
    for (; i > 0;) {
        let c = t[i],
            l = Array.isArray(c),
            u = l ? c[1] : c,
            d = u === null,
            h = n[i + 1];
        h === Tr && (h = d ? pn : void 0);
        let f = d ? bp(h, r) : u === r ? h : void 0;
        if (l && !Cu(f) && (f = bp(c, r)), Cu(f) && (a = f, o)) return a;
        let p = t[i + 1];
        i = o ? Qi(p) : lo(p)
    }
    if (e !== null) {
        let c = s ? e.residualClasses : e.residualStyles;
        c != null && (a = bp(c, r))
    }
    return a
}

function Cu(t) {
    return t !== void 0
}

function VF(t, e) {
    return t == null || t === "" || (typeof e == "string" ? t = t + e : typeof t == "object" && (t = Lt(Vu(t)))), t
}

function UF(t, e) {
    return (t.flags & (e ? 8 : 16)) !== 0
}
var bg = class {
    destroy(e) {}
    updateValue(e, n) {}
    swap(e, n) {
        let r = Math.min(e, n),
            i = Math.max(e, n),
            s = this.detach(i);
        if (i - r > 1) {
            let o = this.detach(r);
            this.attach(r, s), this.attach(i, o)
        } else this.attach(r, s)
    }
    move(e, n) {
        this.attach(n, this.detach(e))
    }
};

function Op(t, e, n, r, i) {
    return t === n && Object.is(e, r) ? 1 : Object.is(i(t, e), i(n, r)) ? -1 : 0
}

function jF(t, e, n) {
    let r, i, s = 0,
        o = t.length - 1;
    if (Array.isArray(e)) {
        let a = e.length - 1;
        for (; s <= o && s <= a;) {
            let c = t.at(s),
                l = e[s],
                u = Op(s, c, s, l, n);
            if (u !== 0) {
                u < 0 && t.updateValue(s, l), s++;
                continue
            }
            let d = t.at(o),
                h = e[a],
                f = Op(o, d, a, h, n);
            if (f !== 0) {
                f < 0 && t.updateValue(o, h), o--, a--;
                continue
            }
            let p = n(s, c),
                g = n(o, d),
                m = n(s, l);
            if (Object.is(m, g)) {
                let y = n(a, h);
                Object.is(y, p) ? (t.swap(s, o), t.updateValue(o, h), a--, o--) : t.move(o, s), t.updateValue(s, l), s++;
                continue
            }
            if (r ? ? = new Su, i ? ? = bb(t, s, o, n), Dg(t, r, s, m)) t.updateValue(s, l), s++, o++;
            else if (i.has(m)) r.set(p, t.detach(s)), o--;
            else {
                let y = t.create(s, e[s]);
                t.attach(s, y), s++, o++
            }
        }
        for (; s <= a;) _b(t, r, n, s, e[s]), s++
    } else if (e != null) {
        let a = e[Symbol.iterator](),
            c = a.next();
        for (; !c.done && s <= o;) {
            let l = t.at(s),
                u = c.value,
                d = Op(s, l, s, u, n);
            if (d !== 0) d < 0 && t.updateValue(s, u), s++, c = a.next();
            else {
                r ? ? = new Su, i ? ? = bb(t, s, o, n);
                let h = n(s, u);
                if (Dg(t, r, s, h)) t.updateValue(s, u), s++, o++, c = a.next();
                else if (!i.has(h)) t.attach(s, t.create(s, u)), s++, o++, c = a.next();
                else {
                    let f = n(s, l);
                    r.set(f, t.detach(s)), o--
                }
            }
        }
        for (; !c.done;) _b(t, r, n, t.length, c.value), c = a.next()
    }
    for (; s <= o;) t.destroy(t.detach(o--));
    r ? .forEach(a => {
        t.destroy(a)
    })
}

function Dg(t, e, n, r) {
    return e !== void 0 && e.has(r) ? (t.attach(n, e.get(r)), e.delete(r), !0) : !1
}

function _b(t, e, n, r, i) {
    if (Dg(t, e, r, n(r, i))) t.updateValue(r, i);
    else {
        let s = t.create(r, i);
        t.attach(r, s)
    }
}

function bb(t, e, n, r) {
    let i = new Set;
    for (let s = e; s <= n; s++) i.add(r(s, t.at(s)));
    return i
}
var Su = class {
    constructor() {
        this.kvMap = new Map, this._vMap = void 0
    }
    has(e) {
        return this.kvMap.has(e)
    }
    delete(e) {
        if (!this.has(e)) return !1;
        let n = this.kvMap.get(e);
        return this._vMap !== void 0 && this._vMap.has(n) ? (this.kvMap.set(e, this._vMap.get(n)), this._vMap.delete(n)) : this.kvMap.delete(e), !0
    }
    get(e) {
        return this.kvMap.get(e)
    }
    set(e, n) {
        if (this.kvMap.has(e)) {
            let r = this.kvMap.get(e);
            this._vMap === void 0 && (this._vMap = new Map);
            let i = this._vMap;
            for (; i.has(r);) r = i.get(r);
            i.set(r, n)
        } else this.kvMap.set(e, n)
    }
    forEach(e) {
        for (let [n, r] of this.kvMap)
            if (e(r, n), this._vMap !== void 0) {
                let i = this._vMap;
                for (; i.has(r);) r = i.get(r), e(r, n)
            }
    }
};

function ii(t, e, n) {
    xr("NgControlFlow");
    let r = he(),
        i = po(),
        s = Mg(r, $t + t),
        o = 0;
    if (ri(r, i, e)) {
        let a = pe(null);
        try {
            if (wE(s, o), e !== -1) {
                let c = Ig(r[ee], $t + e),
                    l = Ma(s, c.tView.ssrId),
                    u = $u(r, c, n, {
                        dehydratedView: l
                    });
                Wu(s, u, o, Sa(c, l))
            }
        } finally {
            pe(a)
        }
    } else {
        let a = vE(s, o);
        a !== void 0 && (a[It] = n)
    }
}
var Eg = class {
    constructor(e, n, r) {
        this.lContainer = e, this.$implicit = n, this.$index = r
    }
    get $count() {
        return this.lContainer.length - Tt
    }
};

function OE(t) {
    return t
}
var Cg = class {
    constructor(e, n, r) {
        this.hasEmptyBlock = e, this.trackByFn = n, this.liveCollection = r
    }
};

function FE(t, e, n, r, i, s, o, a, c, l, u, d, h) {
    xr("NgControlFlow");
    let f = c !== void 0,
        p = he(),
        g = a ? o.bind(p[mn][It]) : o,
        m = new Cg(f, g);
    p[$t + t] = m, _t(t + 1, e, n, r, i, s), f && _t(t + 2, c, l, u, d, h)
}
var Sg = class extends bg {
    constructor(e, n, r) {
        super(), this.lContainer = e, this.hostLView = n, this.templateTNode = r, this.needsIndexUpdate = !1
    }
    get length() {
        return this.lContainer.length - Tt
    }
    at(e) {
        return this.getLView(e)[It].$implicit
    }
    attach(e, n) {
        let r = n[io];
        this.needsIndexUpdate || = e !== this.length, Wu(this.lContainer, n, e, Sa(this.templateTNode, r))
    }
    detach(e) {
        return this.needsIndexUpdate || = e !== this.length - 1, BF(this.lContainer, e)
    }
    create(e, n) {
        let r = Ma(this.lContainer, this.templateTNode.tView.ssrId);
        return $u(this.hostLView, this.templateTNode, new Eg(this.lContainer, n, e), {
            dehydratedView: r
        })
    }
    destroy(e) {
        Uu(e[ee], e)
    }
    updateValue(e, n) {
        this.getLView(e)[It].$implicit = n
    }
    reset() {
        this.needsIndexUpdate = !1
    }
    updateIndexes() {
        if (this.needsIndexUpdate)
            for (let e = 0; e < this.length; e++) this.getLView(e)[It].$index = e
    }
    getLView(e) {
        return zF(this.lContainer, e)
    }
};

function kE(t) {
    let e = pe(null),
        n = qi();
    try {
        let r = he(),
            i = r[ee],
            s = r[n];
        if (s.liveCollection === void 0) {
            let a = n + 1,
                c = Mg(r, a),
                l = Ig(i, a);
            s.liveCollection = new Sg(c, r, l)
        } else s.liveCollection.reset();
        let o = s.liveCollection;
        if (jF(o, t, s.trackByFn), o.updateIndexes(), s.hasEmptyBlock) {
            let a = po(),
                c = o.length === 0;
            if (ri(r, a, c)) {
                let l = n + 2,
                    u = Mg(r, l);
                if (c) {
                    let d = Ig(i, l),
                        h = Ma(u, d.tView.ssrId),
                        f = $u(r, d, void 0, {
                            dehydratedView: h
                        });
                    Wu(u, f, 0, Sa(d, h))
                } else wE(u, 0)
            }
        }
    } finally {
        pe(e)
    }
}

function Mg(t, e) {
    return t[e]
}

function BF(t, e) {
    return Ca(t, e)
}

function zF(t, e) {
    return vE(t, e)
}

function Ig(t, e) {
    return Qg(t, e)
}

function $F(t, e, n, r, i, s) {
    let o = e.consts,
        a = du(o, i),
        c = ka(e, t, 2, r, a);
    return uE(e, n, c, du(o, s)), c.attrs !== null && lg(c, c.attrs, !1), c.mergedAttrs !== null && lg(c, c.mergedAttrs, !0), e.queries !== null && e.queries.elementStart(e, c), c
}

function P(t, e, n, r) {
    let i = he(),
        s = ut(),
        o = $t + t,
        a = i[Xe],
        c = s.firstCreatePass ? $F(o, s, i, e, n, r) : s.data[o],
        l = WF(s, i, c, a, e, t);
    i[o] = l;
    let u = Zg(c);
    return Ra(c, !0), eE(a, l, c), !_F(c) && tm() && dm(s, i, l, c), w1() === 0 && Gi(l, i), _1(), u && (aE(s, i, c), oE(s, c, i)), r !== null && cE(i, c), P
}

function B() {
    let t = Jt();
    pD() ? gD() : (t = t.parent, Ra(t, !1));
    let e = t;
    D1(e) && E1(), b1();
    let n = ut();
    return n.firstCreatePass && (rm(n, t), rD(t) && n.queries.elementEnd(t)), e.classesWithoutHost != null && L1(e) && vb(n, e, he(), e.classesWithoutHost, !0), e.stylesWithoutHost != null && V1(e) && vb(n, e, he(), e.stylesWithoutHost, !1), B
}

function fe(t, e, n, r) {
    return P(t, e, n, r), B(), fe
}
var WF = (t, e, n, r, i, s) => (nm(!0), HD(r, i, O1()));

function Xt() {
    return he()
}
var Mu = "en-US";
var HF = Mu;

function GF(t) {
    typeof t == "string" && (HF = t.toLowerCase().replace(/_/g, "-"))
}

function we(t, e, n, r) {
    let i = he(),
        s = ut(),
        o = Jt();
    return PE(s, i, i[Xe], o, t, e, r), we
}

function ZF(t, e, n, r) {
    let i = t.cleanup;
    if (i != null)
        for (let s = 0; s < i.length - 1; s += 2) {
            let o = i[s];
            if (o === n && i[s + 1] === r) {
                let a = e[_a],
                    c = i[s + 2];
                return a.length > c ? a[c] : null
            }
            typeof o == "string" && (s += 2)
        }
    return null
}

function PE(t, e, n, r, i, s, o) {
    let a = Zg(r),
        l = t.firstCreatePass && mE(t),
        u = e[It],
        d = gE(e),
        h = !0;
    if (r.type & 3 || o) {
        let g = wn(r, e),
            m = o ? o(g) : g,
            y = d.length,
            E = o ? w => o(Jn(w[r.index])) : r.index,
            T = null;
        if (!o && a && (T = ZF(t, e, i, r.index)), T !== null) {
            let w = T.__ngLastListenerFn__ || T;
            w.__ngNextListenerFn__ = s, T.__ngLastListenerFn__ = s, h = !1
        } else {
            s = Eb(r, e, u, s, !1);
            let w = n.listen(m, i, s);
            d.push(s, w), l && l.push(i, E, y, y + 1)
        }
    } else s = Eb(r, e, u, s, !1);
    let f = r.outputs,
        p;
    if (h && f !== null && (p = f[i])) {
        let g = p.length;
        if (g)
            for (let m = 0; m < g; m += 2) {
                let y = p[m],
                    E = p[m + 1],
                    N = e[y][E].subscribe(s),
                    L = d.length;
                d.push(s, N), l && l.push(i, r.index, L, -(L + 1))
            }
    }
}

function Db(t, e, n, r) {
    let i = pe(null);
    try {
        return Kn(6, e, n), n(r) !== !1
    } catch (s) {
        return yE(t, s), !1
    } finally {
        Kn(7, e, n), pe(i)
    }
}

function Eb(t, e, n, r, i) {
    return function s(o) {
        if (o === Function) return r;
        let a = t.componentOffset > -1 ? ti(t.index, e) : e;
        ym(a);
        let c = Db(e, n, r, o),
            l = s.__ngNextListenerFn__;
        for (; l;) c = Db(e, n, l, o) && c, l = l.__ngNextListenerFn__;
        return i && c === !1 && o.preventDefault(), c
    }
}

function Ne(t = 1) {
    return R1(t)
}

function QF(t, e) {
    let n = null,
        r = PN(t);
    for (let i = 0; i < e.length; i++) {
        let s = e[i];
        if (s === "*") {
            n = i;
            continue
        }
        if (r === null ? $b(t, s, !0) : UN(r, s)) return i
    }
    return n
}

function Zu(t) {
    let e = he()[mn][Yt];
    if (!e.projection) {
        let n = t ? t.length : 1,
            r = e.projection = SN(n, null),
            i = r.slice(),
            s = e.child;
        for (; s !== null;) {
            let o = t ? QF(s, t) : 0;
            o !== null && (i[o] ? i[o].projectionNext = s : r[o] = s, i[o] = s), s = s.next
        }
    }
}

function Qu(t, e = 0, n) {
    let r = he(),
        i = ut(),
        s = ka(i, $t + t, 16, null, n || null);
    s.projection === null && (s.projection = e), gD(), (!r[io] || hD()) && (s.flags & 32) !== 32 && TR(i, r, s)
}

function si(t, e, n) {
    return oi(t, "", e, "", n), si
}

function oi(t, e, n, r, i) {
    let s = he(),
        o = RE(s, e, n, r);
    if (o !== Tr) {
        let a = ut(),
            c = Pu();
        pm(a, c, s, t, o, s[Xe], i, !1)
    }
    return oi
}

function LE(t, e, n) {
    XO(t, e, n)
}

function qu(t) {
    let e = he(),
        n = ut(),
        r = mD();
    Jg(r + 1);
    let i = Dm(n, r);
    if (t.dirty && p1(e) === ((i.metadata.flags & 2) === 2)) {
        if (i.matches === null) t.reset([]);
        else {
            let s = nF(e, r);
            t.reset(s, K1), t.notifyOnChanges()
        }
        return !0
    }
    return !1
}

function Ku() {
    return YO(he(), mD())
}

function qF(t, e, n, r) {
    n >= t.data.length && (t.data[n] = null, t.blueprint[n] = null), e[n] = r
}

function re(t, e = "") {
    let n = he(),
        r = ut(),
        i = t + $t,
        s = r.firstCreatePass ? ka(r, i, 1, e, null) : r.data[i],
        o = KF(r, n, s, e, t);
    n[i] = o, tm() && dm(r, n, o, s), Ra(s, !1)
}
var KF = (t, e, n, r, i) => (nm(!0), fR(e[Xe], r));

function jn(t) {
    return _o("", t, ""), jn
}

function _o(t, e, n) {
    let r = he(),
        i = RE(r, t, e, n);
    return i !== Tr && rO(r, qi(), i), _o
}

function Yu(t, e, n) {
    xE(e) && (e = e());
    let r = he(),
        i = po();
    if (ri(r, i, e)) {
        let s = ut(),
            o = Pu();
        pm(s, o, r, t, e, r[Xe], n, !1)
    }
    return Yu
}

function Cm(t, e) {
    let n = xE(t);
    return n && t.set(e), n
}

function Ju(t, e) {
    let n = he(),
        r = ut(),
        i = Jt();
    return PE(r, n, n[Xe], i, t, e), Ju
}

function YF(t, e, n) {
    let r = ut();
    if (r.firstCreatePass) {
        let i = Xr(t);
        Tg(n, r.data, r.blueprint, i, !0), Tg(e, r.data, r.blueprint, i, !1)
    }
}

function Tg(t, e, n, r, i) {
    if (t = Pt(t), Array.isArray(t))
        for (let s = 0; s < t.length; s++) Tg(t[s], e, n, r, i);
    else {
        let s = ut(),
            o = he(),
            a = Jt(),
            c = ro(t) ? t : Pt(t.provide),
            l = Xb(t),
            u = a.providerIndexes & 1048575,
            d = a.directiveStart,
            h = a.providerIndexes >> 20;
        if (ro(t) || !t.multi) {
            let f = new Wi(l, i, O),
                p = kp(c, e, i ? u : u + h, d);
            p === -1 ? (Zp(gu(a, o), s, c), Fp(s, t, e.length), e.push(c), a.directiveStart++, a.directiveEnd++, i && (a.providerIndexes += 1048576), n.push(f), o.push(f)) : (n[p] = f, o[p] = f)
        } else {
            let f = kp(c, e, u + h, d),
                p = kp(c, e, u, u + h),
                g = f >= 0 && n[f],
                m = p >= 0 && n[p];
            if (i && !m || !i && !g) {
                Zp(gu(a, o), s, c);
                let y = ek(i ? XF : JF, n.length, i, r, l);
                !i && m && (n[p].providerFactory = y), Fp(s, t, e.length, 0), e.push(c), a.directiveStart++, a.directiveEnd++, i && (a.providerIndexes += 1048576), n.push(y), o.push(y)
            } else {
                let y = VE(n[i ? p : f], l, !i && r);
                Fp(s, t, f > -1 ? f : p, y)
            }!i && r && m && n[p].componentProviders++
        }
    }
}

function Fp(t, e, n, r) {
    let i = ro(e),
        s = KN(e);
    if (i || s) {
        let c = (s ? Pt(e.useClass) : e).prototype.ngOnDestroy;
        if (c) {
            let l = t.destroyHooks || (t.destroyHooks = []);
            if (!i && e.multi) {
                let u = l.indexOf(n);
                u === -1 ? l.push(n, [r, c]) : l[u + 1].push(r, c)
            } else l.push(n, c)
        }
    }
}

function VE(t, e, n) {
    return n && t.componentProviders++, t.multi.push(e) - 1
}

function kp(t, e, n, r) {
    for (let i = n; i < r; i++)
        if (e[i] === t) return i;
    return -1
}

function JF(t, e, n, r) {
    return xg(this.multi, [])
}

function XF(t, e, n, r) {
    let i = this.multi,
        s;
    if (this.providerFactory) {
        let o = this.providerFactory.componentProviders,
            a = Hi(n, n[ee], this.providerFactory.index, r);
        s = a.slice(0, o), xg(i, s);
        for (let c = o; c < a.length; c++) s.push(a[c])
    } else s = [], xg(i, s);
    return s
}

function xg(t, e) {
    for (let n = 0; n < t.length; n++) {
        let r = t[n];
        e.push(r())
    }
    return e
}

function ek(t, e, n, r, i) {
    let s = new Wi(t, n, O);
    return s.multi = [], s.index = e, s.componentProviders = 0, VE(s, i, r && !n), s
}

function Ji(t, e = []) {
    return n => {
        n.providersResolver = (r, i) => YF(r, i ? i(t) : t, e)
    }
}
var tk = (() => {
    let e = class e {
        constructor(r) {
            this._injector = r, this.cachedInjectors = new Map
        }
        getOrCreateStandaloneInjector(r) {
            if (!r.standalone) return null;
            if (!this.cachedInjectors.has(r)) {
                let i = Kb(!1, r.type),
                    s = i.length > 0 ? Gu([i], this._injector, `Standalone[${r.type.name}]`) : null;
                this.cachedInjectors.set(r, s)
            }
            return this.cachedInjectors.get(r)
        }
        ngOnDestroy() {
            try {
                for (let r of this.cachedInjectors.values()) r !== null && r.destroy()
            } finally {
                this.cachedInjectors.clear()
            }
        }
    };
    e.\u0275prov = I({
        token: e,
        providedIn: "environment",
        factory: () => new e(C(Ut))
    });
    let t = e;
    return t
})();

function UE(t) {
    xr("NgStandalone"), t.getStandaloneInjector = e => e.get(tk).getOrCreateStandaloneInjector(t)
}

function Xu(t, e, n) {
    let r = Yg() + t,
        i = he();
    return i[r] === Tr ? NE(i, r, n ? e.call(n) : e()) : wF(i, r)
}

function Ar(t, e, n, r) {
    return jE(he(), Yg(), t, e, n, r)
}

function nk(t, e) {
    let n = t[e];
    return n === Tr ? void 0 : n
}

function jE(t, e, n, r, i, s) {
    let o = e + n;
    return ri(t, o, i) ? NE(t, o + 1, s ? r.call(s, i) : r(i)) : nk(t, o + 1)
}

function ed(t, e) {
    let n = ut(),
        r, i = t + $t;
    n.firstCreatePass ? (r = rk(e, n.pipeRegistry), n.data[i] = r, r.onDestroy && (n.destroyHooks ? ? = []).push(i, r.onDestroy)) : r = n.data[i];
    let s = r.factory || (r.factory = ji(r.type, !0)),
        o, a = zt(O);
    try {
        let c = pu(!1),
            l = s();
        return pu(c), qF(n, he(), i, l), l
    } finally {
        zt(a)
    }
}

function rk(t, e) {
    if (e)
        for (let n = e.length - 1; n >= 0; n--) {
            let r = e[n];
            if (t === r.name) return r
        }
}

function td(t, e, n) {
    let r = t + $t,
        i = he(),
        s = f1(i, r);
    return ik(i, r) ? jE(i, Yg(), e, s.transform, n, s) : s.transform(n)
}

function ik(t, e) {
    return t[ee].data[e].pure
}
var Xl = null;

function sk(t) {
    Xl !== null && (t.defaultEncapsulation !== Xl.defaultEncapsulation || t.preserveWhitespaces !== Xl.preserveWhitespaces) || (Xl = t)
}
var nd = (() => {
    let e = class e {
        log(r) {
            console.log(r)
        }
        warn(r) {
            console.warn(r)
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac,
        providedIn: "platform"
    });
    let t = e;
    return t
})();
var Sm = new R(""),
    Pa = new R(""),
    rd = (() => {
        let e = class e {
            constructor(r, i, s) {
                this._ngZone = r, this.registry = i, this._pendingCount = 0, this._isZoneStable = !0, this._callbacks = [], this.taskTrackingZone = null, Mm || (ok(s), s.addToWindow(i)), this._watchAngularEvents(), r.run(() => {
                    this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone")
                })
            }
            _watchAngularEvents() {
                this._ngZone.onUnstable.subscribe({
                    next: () => {
                        this._isZoneStable = !1
                    }
                }), this._ngZone.runOutsideAngular(() => {
                    this._ngZone.onStable.subscribe({
                        next: () => {
                            ye.assertNotInAngularZone(), queueMicrotask(() => {
                                this._isZoneStable = !0, this._runCallbacksIfReady()
                            })
                        }
                    })
                })
            }
            increasePendingRequestCount() {
                return this._pendingCount += 1, this._pendingCount
            }
            decreasePendingRequestCount() {
                if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
                return this._runCallbacksIfReady(), this._pendingCount
            }
            isStable() {
                return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks
            }
            _runCallbacksIfReady() {
                if (this.isStable()) queueMicrotask(() => {
                    for (; this._callbacks.length !== 0;) {
                        let r = this._callbacks.pop();
                        clearTimeout(r.timeoutId), r.doneCb()
                    }
                });
                else {
                    let r = this.getPendingTasks();
                    this._callbacks = this._callbacks.filter(i => i.updateCb && i.updateCb(r) ? (clearTimeout(i.timeoutId), !1) : !0)
                }
            }
            getPendingTasks() {
                return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(r => ({
                    source: r.source,
                    creationLocation: r.creationLocation,
                    data: r.data
                })) : []
            }
            addCallback(r, i, s) {
                let o = -1;
                i && i > 0 && (o = setTimeout(() => {
                    this._callbacks = this._callbacks.filter(a => a.timeoutId !== o), r()
                }, i)), this._callbacks.push({
                    doneCb: r,
                    timeoutId: o,
                    updateCb: s
                })
            }
            whenStable(r, i, s) {
                if (s && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
                this.addCallback(r, i, s), this._runCallbacksIfReady()
            }
            getPendingRequestCount() {
                return this._pendingCount
            }
            registerApplication(r) {
                this.registry.registerApplication(r, this)
            }
            unregisterApplication(r) {
                this.registry.unregisterApplication(r)
            }
            findProviders(r, i, s) {
                return []
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(ye), C(id), C(Pa))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    id = (() => {
        let e = class e {
            constructor() {
                this._applications = new Map
            }
            registerApplication(r, i) {
                this._applications.set(r, i)
            }
            unregisterApplication(r) {
                this._applications.delete(r)
            }
            unregisterAllApplications() {
                this._applications.clear()
            }
            getTestability(r) {
                return this._applications.get(r) || null
            }
            getAllTestabilities() {
                return Array.from(this._applications.values())
            }
            getAllRootElements() {
                return Array.from(this._applications.keys())
            }
            findTestabilityInTree(r, i = !0) {
                return Mm ? .findTestabilityInTree(this, r, i) ? ? null
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "platform"
        });
        let t = e;
        return t
    })();

function ok(t) {
    Mm = t
}
var Mm;

function Xi(t) {
    return !!t && typeof t.then == "function"
}

function BE(t) {
    return !!t && typeof t.subscribe == "function"
}
var sd = new R(""),
    zE = (() => {
        let e = class e {
            constructor() {
                this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, i) => {
                    this.resolve = r, this.reject = i
                }), this.appInits = M(sd, {
                    optional: !0
                }) ? ? []
            }
            runInitializers() {
                if (this.initialized) return;
                let r = [];
                for (let s of this.appInits) {
                    let o = s();
                    if (Xi(o)) r.push(o);
                    else if (BE(o)) {
                        let a = new Promise((c, l) => {
                            o.subscribe({
                                complete: c,
                                error: l
                            })
                        });
                        r.push(a)
                    }
                }
                let i = () => {
                    this.done = !0, this.resolve()
                };
                Promise.all(r).then(() => {
                    i()
                }).catch(s => {
                    this.reject(s)
                }), r.length === 0 && i(), this.initialized = !0
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    od = new R("");

function ak() {
    h_(() => {
        throw new S(600, !1)
    })
}

function ck(t) {
    return t.isBoundToModule
}

function lk(t, e, n) {
    try {
        let r = n();
        return Xi(r) ? r.catch(i => {
            throw e.runOutsideAngular(() => t.handleError(i)), i
        }) : r
    } catch (r) {
        throw e.runOutsideAngular(() => t.handleError(r)), r
    }
}

function $E(t, e) {
    return Array.isArray(e) ? e.reduce($E, t) : _(_({}, t), e)
}
var Nr = (() => {
    let e = class e {
        constructor() {
            this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = M(FD), this.afterRenderEffectManager = M(bm), this.externalTestViews = new Set, this.beforeRender = new Me, this.afterTick = new Me, this.componentTypes = [], this.components = [], this.isStable = M(Yi).hasPendingTasks.pipe(Z(r => !r)), this._injector = M(Ut)
        }
        get destroyed() {
            return this._destroyed
        }
        get injector() {
            return this._injector
        }
        bootstrap(r, i) {
            let s = r instanceof wu;
            if (!this._injector.get(zE).done) {
                let f = !s && Gb(r),
                    p = !1;
                throw new S(405, p)
            }
            let a;
            s ? a = r : a = this._injector.get(yo).resolveComponentFactory(r), this.componentTypes.push(a.componentType);
            let c = ck(a) ? void 0 : this._injector.get(ei),
                l = i || a.selector,
                u = a.create(bt.NULL, [], l, c),
                d = u.location.nativeElement,
                h = u.injector.get(Sm, null);
            return h ? .registerApplication(d), u.onDestroy(() => {
                this.detachView(u.hostView), su(this.components, u), h ? .unregisterApplication(d)
            }), this._loadComponent(u), u
        }
        tick() {
            this._tick(!0)
        }
        _tick(r) {
            if (this._runningTick) throw new S(101, !1);
            let i = pe(null);
            try {
                this._runningTick = !0, this.detectChangesInAttachedViews(r)
            } catch (s) {
                this.internalErrorHandler(s)
            } finally {
                this.afterTick.next(), this._runningTick = !1, pe(i)
            }
        }
        detectChangesInAttachedViews(r) {
            let i = 0,
                s = this.afterRenderEffectManager;
            for (;;) {
                if (i === bE) throw new S(103, !1);
                if (r) {
                    let o = i === 0;
                    this.beforeRender.next(o);
                    for (let {
                            _lView: a,
                            notifyErrorHandler: c
                        } of this._views) uk(a, o, c)
                }
                if (i++, s.executeInternalCallbacks(), ![...this.externalTestViews.keys(), ...this._views].some(({
                        _lView: o
                    }) => Ag(o)) && (s.execute(), ![...this.externalTestViews.keys(), ...this._views].some(({
                        _lView: o
                    }) => Ag(o)))) break
            }
        }
        attachView(r) {
            let i = r;
            this._views.push(i), i.attachToAppRef(this)
        }
        detachView(r) {
            let i = r;
            su(this._views, i), i.detachFromAppRef()
        }
        _loadComponent(r) {
            this.attachView(r.hostView), this.tick(), this.components.push(r);
            let i = this._injector.get(od, []);
            [...this._bootstrapListeners, ...i].forEach(s => s(r))
        }
        ngOnDestroy() {
            if (!this._destroyed) try {
                this._destroyListeners.forEach(r => r()), this._views.slice().forEach(r => r.destroy())
            } finally {
                this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = []
            }
        }
        onDestroy(r) {
            return this._destroyListeners.push(r), () => su(this._destroyListeners, r)
        }
        destroy() {
            if (this._destroyed) throw new S(406, !1);
            let r = this._injector;
            r.destroy && !r.destroyed && r.destroy()
        }
        get viewCount() {
            return this._views.length
        }
        warnIfDestroyed() {}
    };
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
})();

function su(t, e) {
    let n = t.indexOf(e);
    n > -1 && t.splice(n, 1)
}

function uk(t, e, n) {
    !e && !Ag(t) || dk(t, n, e)
}

function Ag(t) {
    return Kg(t)
}

function dk(t, e, n) {
    let r;
    n ? (r = 0, t[X] |= 1024) : t[X] & 64 ? r = 0 : r = 1, DE(t, e, r)
}
var Ng = class {
        constructor(e, n) {
            this.ngModuleFactory = e, this.componentFactories = n
        }
    },
    ad = (() => {
        let e = class e {
            compileModuleSync(r) {
                return new Eu(r)
            }
            compileModuleAsync(r) {
                return Promise.resolve(this.compileModuleSync(r))
            }
            compileModuleAndAllComponentsSync(r) {
                let i = this.compileModuleSync(r),
                    s = Zb(r),
                    o = WD(s.declarations).reduce((a, c) => {
                        let l = Jr(c);
                        return l && a.push(new co(l)), a
                    }, []);
                return new Ng(i, o)
            }
            compileModuleAndAllComponentsAsync(r) {
                return Promise.resolve(this.compileModuleAndAllComponentsSync(r))
            }
            clearCache() {}
            clearCacheFor(r) {}
            getModuleId(r) {}
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    hk = new R("");

function fk(t, e, n) {
    let r = new Eu(n);
    return Promise.resolve(r)
}

function Cb(t) {
    for (let e = t.length - 1; e >= 0; e--)
        if (t[e] !== void 0) return t[e]
}
var pk = (() => {
    let e = class e {
        constructor() {
            this.zone = M(ye), this.applicationRef = M(Nr)
        }
        initialize() {
            this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
                next: () => {
                    this.zone.run(() => {
                        this.applicationRef.tick()
                    })
                }
            }))
        }
        ngOnDestroy() {
            this._onMicrotaskEmptySubscription ? .unsubscribe()
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
})();

function gk(t) {
    return [{
        provide: ye,
        useFactory: t
    }, {
        provide: no,
        multi: !0,
        useFactory: () => {
            let e = M(pk, {
                optional: !0
            });
            return () => e.initialize()
        }
    }, {
        provide: no,
        multi: !0,
        useFactory: () => {
            let e = M(vk);
            return () => {
                e.initialize()
            }
        }
    }, {
        provide: FD,
        useFactory: mk
    }]
}

function mk() {
    let t = M(ye),
        e = M(yn);
    return n => t.runOutsideAngular(() => e.handleError(n))
}

function yk(t) {
    return {
        enableLongStackTrace: !1,
        shouldCoalesceEventChangeDetection: t ? .eventCoalescing ? ? !1,
        shouldCoalesceRunChangeDetection: t ? .runCoalescing ? ? !1
    }
}
var vk = (() => {
    let e = class e {
        constructor() {
            this.subscription = new Oe, this.initialized = !1, this.zone = M(ye), this.pendingTasks = M(Yi)
        }
        initialize() {
            if (this.initialized) return;
            this.initialized = !0;
            let r = null;
            !this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (r = this.pendingTasks.add()), this.zone.runOutsideAngular(() => {
                this.subscription.add(this.zone.onStable.subscribe(() => {
                    ye.assertNotInAngularZone(), queueMicrotask(() => {
                        r !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (this.pendingTasks.remove(r), r = null)
                    })
                }))
            }), this.subscription.add(this.zone.onUnstable.subscribe(() => {
                ye.assertInAngularZone(), r ? ? = this.pendingTasks.add()
            }))
        }
        ngOnDestroy() {
            this.subscription.unsubscribe()
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
})();

function wk() {
    return typeof $localize < "u" && $localize.locale || Mu
}
var Im = new R("", {
    providedIn: "root",
    factory: () => M(Im, ue.Optional | ue.SkipSelf) || wk()
});
var WE = new R(""),
    HE = (() => {
        let e = class e {
            constructor(r) {
                this._injector = r, this._modules = [], this._destroyListeners = [], this._destroyed = !1
            }
            bootstrapModuleFactory(r, i) {
                let s = AO(i ? .ngZone, yk({
                    eventCoalescing: i ? .ngZoneEventCoalescing,
                    runCoalescing: i ? .ngZoneRunCoalescing
                }));
                return s.run(() => {
                    let o = yF(r.moduleType, this.injector, gk(() => s)),
                        a = o.injector.get(yn, null);
                    return s.runOutsideAngular(() => {
                        let c = s.onError.subscribe({
                            next: l => {
                                a.handleError(l)
                            }
                        });
                        o.onDestroy(() => {
                            su(this._modules, o), c.unsubscribe()
                        })
                    }), lk(a, s, () => {
                        let c = o.injector.get(zE);
                        return c.runInitializers(), c.donePromise.then(() => {
                            let l = o.injector.get(Im, Mu);
                            return GF(l || Mu), this._moduleDoBootstrap(o), o
                        })
                    })
                })
            }
            bootstrapModule(r, i = []) {
                let s = $E({}, i);
                return fk(this.injector, s, r).then(o => this.bootstrapModuleFactory(o, s))
            }
            _moduleDoBootstrap(r) {
                let i = r.injector.get(Nr);
                if (r._bootstrapComponents.length > 0) r._bootstrapComponents.forEach(s => i.bootstrap(s));
                else if (r.instance.ngDoBootstrap) r.instance.ngDoBootstrap(i);
                else throw new S(-403, !1);
                this._modules.push(r)
            }
            onDestroy(r) {
                this._destroyListeners.push(r)
            }
            get injector() {
                return this._injector
            }
            destroy() {
                if (this._destroyed) throw new S(404, !1);
                this._modules.slice().forEach(i => i.destroy()), this._destroyListeners.forEach(i => i());
                let r = this._injector.get(WE, null);
                r && (r.forEach(i => i()), r.clear()), this._destroyed = !0
            }
            get destroyed() {
                return this._destroyed
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(bt))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "platform"
        });
        let t = e;
        return t
    })(),
    ma = null,
    GE = new R("");

function _k(t) {
    if (ma && !ma.get(GE, !1)) throw new S(400, !1);
    ak(), ma = t;
    let e = t.get(HE);
    return Ek(t), e
}

function Tm(t, e, n = []) {
    let r = `Platform: ${e}`,
        i = new R(r);
    return (s = []) => {
        let o = ZE();
        if (!o || o.injector.get(GE, !1)) {
            let a = [...n, ...s, {
                provide: i,
                useValue: !0
            }];
            t ? t(a) : _k(bk(a, r))
        }
        return Dk(i)
    }
}

function bk(t = [], e) {
    return bt.create({
        name: e,
        providers: [{
            provide: Ou,
            useValue: "platform"
        }, {
            provide: WE,
            useValue: new Set([() => ma = null])
        }, ...t]
    })
}

function Dk(t) {
    let e = ZE();
    if (!e) throw new S(401, !1);
    return e
}

function ZE() {
    return ma ? .get(HE) ? ? null
}

function Ek(t) {
    t.get(sm, null) ? .forEach(n => n())
}

function cd() {
    return !1
}
var xt = (() => {
    let e = class e {};
    e.__NG_ELEMENT_ID__ = Ck;
    let t = e;
    return t
})();

function Ck(t) {
    return Sk(Jt(), he(), (t & 16) === 16)
}

function Sk(t, e, n) {
    if (ku(t) && !n) {
        let r = ti(t.index, e);
        return new Zi(r, r)
    } else if (t.type & 47) {
        let r = e[mn];
        return new Zi(r, e)
    }
    return null
}
var Rg = class {
        constructor() {}
        supports(e) {
            return AE(e)
        }
        create(e) {
            return new Og(e)
        }
    },
    Mk = (t, e) => e,
    Og = class {
        constructor(e) {
            this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = e || Mk
        }
        forEachItem(e) {
            let n;
            for (n = this._itHead; n !== null; n = n._next) e(n)
        }
        forEachOperation(e) {
            let n = this._itHead,
                r = this._removalsHead,
                i = 0,
                s = null;
            for (; n || r;) {
                let o = !r || n && n.currentIndex < Sb(r, i, s) ? n : r,
                    a = Sb(o, i, s),
                    c = o.currentIndex;
                if (o === r) i--, r = r._nextRemoved;
                else if (n = n._next, o.previousIndex == null) i++;
                else {
                    s || (s = []);
                    let l = a - i,
                        u = c - i;
                    if (l != u) {
                        for (let h = 0; h < l; h++) {
                            let f = h < s.length ? s[h] : s[h] = 0,
                                p = f + h;
                            u <= p && p < l && (s[h] = f + 1)
                        }
                        let d = o.previousIndex;
                        s[d] = u - l
                    }
                }
                a !== c && e(o, a, c)
            }
        }
        forEachPreviousItem(e) {
            let n;
            for (n = this._previousItHead; n !== null; n = n._nextPrevious) e(n)
        }
        forEachAddedItem(e) {
            let n;
            for (n = this._additionsHead; n !== null; n = n._nextAdded) e(n)
        }
        forEachMovedItem(e) {
            let n;
            for (n = this._movesHead; n !== null; n = n._nextMoved) e(n)
        }
        forEachRemovedItem(e) {
            let n;
            for (n = this._removalsHead; n !== null; n = n._nextRemoved) e(n)
        }
        forEachIdentityChange(e) {
            let n;
            for (n = this._identityChangesHead; n !== null; n = n._nextIdentityChange) e(n)
        }
        diff(e) {
            if (e == null && (e = []), !AE(e)) throw new S(900, !1);
            return this.check(e) ? this : null
        }
        onDestroy() {}
        check(e) {
            this._reset();
            let n = this._itHead,
                r = !1,
                i, s, o;
            if (Array.isArray(e)) {
                this.length = e.length;
                for (let a = 0; a < this.length; a++) s = e[a], o = this._trackByFn(a, s), n === null || !Object.is(n.trackById, o) ? (n = this._mismatch(n, s, o, a), r = !0) : (r && (n = this._verifyReinsertion(n, s, o, a)), Object.is(n.item, s) || this._addIdentityChange(n, s)), n = n._next
            } else i = 0, vF(e, a => {
                o = this._trackByFn(i, a), n === null || !Object.is(n.trackById, o) ? (n = this._mismatch(n, a, o, i), r = !0) : (r && (n = this._verifyReinsertion(n, a, o, i)), Object.is(n.item, a) || this._addIdentityChange(n, a)), n = n._next, i++
            }), this.length = i;
            return this._truncate(n), this.collection = e, this.isDirty
        }
        get isDirty() {
            return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null
        }
        _reset() {
            if (this.isDirty) {
                let e;
                for (e = this._previousItHead = this._itHead; e !== null; e = e._next) e._nextPrevious = e._next;
                for (e = this._additionsHead; e !== null; e = e._nextAdded) e.previousIndex = e.currentIndex;
                for (this._additionsHead = this._additionsTail = null, e = this._movesHead; e !== null; e = e._nextMoved) e.previousIndex = e.currentIndex;
                this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null
            }
        }
        _mismatch(e, n, r, i) {
            let s;
            return e === null ? s = this._itTail : (s = e._prev, this._remove(e)), e = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(r, null), e !== null ? (Object.is(e.item, n) || this._addIdentityChange(e, n), this._reinsertAfter(e, s, i)) : (e = this._linkedRecords === null ? null : this._linkedRecords.get(r, i), e !== null ? (Object.is(e.item, n) || this._addIdentityChange(e, n), this._moveAfter(e, s, i)) : e = this._addAfter(new Fg(n, r), s, i)), e
        }
        _verifyReinsertion(e, n, r, i) {
            let s = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(r, null);
            return s !== null ? e = this._reinsertAfter(s, e._prev, i) : e.currentIndex != i && (e.currentIndex = i, this._addToMoves(e, i)), e
        }
        _truncate(e) {
            for (; e !== null;) {
                let n = e._next;
                this._addToRemovals(this._unlink(e)), e = n
            }
            this._unlinkedRecords !== null && this._unlinkedRecords.clear(), this._additionsTail !== null && (this._additionsTail._nextAdded = null), this._movesTail !== null && (this._movesTail._nextMoved = null), this._itTail !== null && (this._itTail._next = null), this._removalsTail !== null && (this._removalsTail._nextRemoved = null), this._identityChangesTail !== null && (this._identityChangesTail._nextIdentityChange = null)
        }
        _reinsertAfter(e, n, r) {
            this._unlinkedRecords !== null && this._unlinkedRecords.remove(e);
            let i = e._prevRemoved,
                s = e._nextRemoved;
            return i === null ? this._removalsHead = s : i._nextRemoved = s, s === null ? this._removalsTail = i : s._prevRemoved = i, this._insertAfter(e, n, r), this._addToMoves(e, r), e
        }
        _moveAfter(e, n, r) {
            return this._unlink(e), this._insertAfter(e, n, r), this._addToMoves(e, r), e
        }
        _addAfter(e, n, r) {
            return this._insertAfter(e, n, r), this._additionsTail === null ? this._additionsTail = this._additionsHead = e : this._additionsTail = this._additionsTail._nextAdded = e, e
        }
        _insertAfter(e, n, r) {
            let i = n === null ? this._itHead : n._next;
            return e._next = i, e._prev = n, i === null ? this._itTail = e : i._prev = e, n === null ? this._itHead = e : n._next = e, this._linkedRecords === null && (this._linkedRecords = new Iu), this._linkedRecords.put(e), e.currentIndex = r, e
        }
        _remove(e) {
            return this._addToRemovals(this._unlink(e))
        }
        _unlink(e) {
            this._linkedRecords !== null && this._linkedRecords.remove(e);
            let n = e._prev,
                r = e._next;
            return n === null ? this._itHead = r : n._next = r, r === null ? this._itTail = n : r._prev = n, e
        }
        _addToMoves(e, n) {
            return e.previousIndex === n || (this._movesTail === null ? this._movesTail = this._movesHead = e : this._movesTail = this._movesTail._nextMoved = e), e
        }
        _addToRemovals(e) {
            return this._unlinkedRecords === null && (this._unlinkedRecords = new Iu), this._unlinkedRecords.put(e), e.currentIndex = null, e._nextRemoved = null, this._removalsTail === null ? (this._removalsTail = this._removalsHead = e, e._prevRemoved = null) : (e._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = e), e
        }
        _addIdentityChange(e, n) {
            return e.item = n, this._identityChangesTail === null ? this._identityChangesTail = this._identityChangesHead = e : this._identityChangesTail = this._identityChangesTail._nextIdentityChange = e, e
        }
    },
    Fg = class {
        constructor(e, n) {
            this.item = e, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null
        }
    },
    kg = class {
        constructor() {
            this._head = null, this._tail = null
        }
        add(e) {
            this._head === null ? (this._head = this._tail = e, e._nextDup = null, e._prevDup = null) : (this._tail._nextDup = e, e._prevDup = this._tail, e._nextDup = null, this._tail = e)
        }
        get(e, n) {
            let r;
            for (r = this._head; r !== null; r = r._nextDup)
                if ((n === null || n <= r.currentIndex) && Object.is(r.trackById, e)) return r;
            return null
        }
        remove(e) {
            let n = e._prevDup,
                r = e._nextDup;
            return n === null ? this._head = r : n._nextDup = r, r === null ? this._tail = n : r._prevDup = n, this._head === null
        }
    },
    Iu = class {
        constructor() {
            this.map = new Map
        }
        put(e) {
            let n = e.trackById,
                r = this.map.get(n);
            r || (r = new kg, this.map.set(n, r)), r.add(e)
        }
        get(e, n) {
            let r = e,
                i = this.map.get(r);
            return i ? i.get(e, n) : null
        }
        remove(e) {
            let n = e.trackById;
            return this.map.get(n).remove(e) && this.map.delete(n), e
        }
        get isEmpty() {
            return this.map.size === 0
        }
        clear() {
            this.map.clear()
        }
    };

function Sb(t, e, n) {
    let r = t.previousIndex;
    if (r === null) return r;
    let i = 0;
    return n && r < n.length && (i = n[r]), r + e + i
}
var Pg = class {
        constructor() {}
        supports(e) {
            return e instanceof Map || Em(e)
        }
        create() {
            return new Lg
        }
    },
    Lg = class {
        constructor() {
            this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null
        }
        get isDirty() {
            return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null
        }
        forEachItem(e) {
            let n;
            for (n = this._mapHead; n !== null; n = n._next) e(n)
        }
        forEachPreviousItem(e) {
            let n;
            for (n = this._previousMapHead; n !== null; n = n._nextPrevious) e(n)
        }
        forEachChangedItem(e) {
            let n;
            for (n = this._changesHead; n !== null; n = n._nextChanged) e(n)
        }
        forEachAddedItem(e) {
            let n;
            for (n = this._additionsHead; n !== null; n = n._nextAdded) e(n)
        }
        forEachRemovedItem(e) {
            let n;
            for (n = this._removalsHead; n !== null; n = n._nextRemoved) e(n)
        }
        diff(e) {
            if (!e) e = new Map;
            else if (!(e instanceof Map || Em(e))) throw new S(900, !1);
            return this.check(e) ? this : null
        }
        onDestroy() {}
        check(e) {
            this._reset();
            let n = this._mapHead;
            if (this._appendAfter = null, this._forEach(e, (r, i) => {
                    if (n && n.key === i) this._maybeAddToChanges(n, r), this._appendAfter = n, n = n._next;
                    else {
                        let s = this._getOrCreateRecordForKey(i, r);
                        n = this._insertBeforeOrAppend(n, s)
                    }
                }), n) {
                n._prev && (n._prev._next = null), this._removalsHead = n;
                for (let r = n; r !== null; r = r._nextRemoved) r === this._mapHead && (this._mapHead = null), this._records.delete(r.key), r._nextRemoved = r._next, r.previousValue = r.currentValue, r.currentValue = null, r._prev = null, r._next = null
            }
            return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty
        }
        _insertBeforeOrAppend(e, n) {
            if (e) {
                let r = e._prev;
                return n._next = e, n._prev = r, e._prev = n, r && (r._next = n), e === this._mapHead && (this._mapHead = n), this._appendAfter = e, e
            }
            return this._appendAfter ? (this._appendAfter._next = n, n._prev = this._appendAfter) : this._mapHead = n, this._appendAfter = n, null
        }
        _getOrCreateRecordForKey(e, n) {
            if (this._records.has(e)) {
                let i = this._records.get(e);
                this._maybeAddToChanges(i, n);
                let s = i._prev,
                    o = i._next;
                return s && (s._next = o), o && (o._prev = s), i._next = null, i._prev = null, i
            }
            let r = new Vg(e);
            return this._records.set(e, r), r.currentValue = n, this._addToAdditions(r), r
        }
        _reset() {
            if (this.isDirty) {
                let e;
                for (this._previousMapHead = this._mapHead, e = this._previousMapHead; e !== null; e = e._next) e._nextPrevious = e._next;
                for (e = this._changesHead; e !== null; e = e._nextChanged) e.previousValue = e.currentValue;
                for (e = this._additionsHead; e != null; e = e._nextAdded) e.previousValue = e.currentValue;
                this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null
            }
        }
        _maybeAddToChanges(e, n) {
            Object.is(n, e.currentValue) || (e.previousValue = e.currentValue, e.currentValue = n, this._addToChanges(e))
        }
        _addToAdditions(e) {
            this._additionsHead === null ? this._additionsHead = this._additionsTail = e : (this._additionsTail._nextAdded = e, this._additionsTail = e)
        }
        _addToChanges(e) {
            this._changesHead === null ? this._changesHead = this._changesTail = e : (this._changesTail._nextChanged = e, this._changesTail = e)
        }
        _forEach(e, n) {
            e instanceof Map ? e.forEach(n) : Object.keys(e).forEach(r => n(e[r], r))
        }
    },
    Vg = class {
        constructor(e) {
            this.key = e, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null
        }
    };

function Mb() {
    return new xm([new Rg])
}
var xm = (() => {
    let e = class e {
        constructor(r) {
            this.factories = r
        }
        static create(r, i) {
            if (i != null) {
                let s = i.factories.slice();
                r = r.concat(s)
            }
            return new e(r)
        }
        static extend(r) {
            return {
                provide: e,
                useFactory: i => e.create(r, i || Mb()),
                deps: [
                    [e, new ho, new Sr]
                ]
            }
        }
        find(r) {
            let i = this.factories.find(s => s.supports(r));
            if (i != null) return i;
            throw new S(901, !1)
        }
    };
    e.\u0275prov = I({
        token: e,
        providedIn: "root",
        factory: Mb
    });
    let t = e;
    return t
})();

function Ib() {
    return new ld([new Pg])
}
var ld = (() => {
    let e = class e {
        constructor(r) {
            this.factories = r
        }
        static create(r, i) {
            if (i) {
                let s = i.factories.slice();
                r = r.concat(s)
            }
            return new e(r)
        }
        static extend(r) {
            return {
                provide: e,
                useFactory: i => e.create(r, i || Ib()),
                deps: [
                    [e, new ho, new Sr]
                ]
            }
        }
        find(r) {
            let i = this.factories.find(s => s.supports(r));
            if (i) return i;
            throw new S(901, !1)
        }
    };
    e.\u0275prov = I({
        token: e,
        providedIn: "root",
        factory: Ib
    });
    let t = e;
    return t
})();
var QE = Tm(null, "core", []),
    qE = (() => {
        let e = class e {
            constructor(r) {}
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(Nr))
        }, e.\u0275mod = xe({
            type: e
        }), e.\u0275inj = Te({});
        let t = e;
        return t
    })();

function ud(t) {
    return typeof t == "boolean" ? t : t != null && t !== "false"
}

function dd(t, e) {
    xr("NgSignals");
    let n = l_(t);
    return e ? .equal && (n[br].equal = e.equal), n
}

function KE(t) {
    let e = Jr(t);
    if (!e) return null;
    let n = new co(e);
    return {
        get selector() {
            return n.selector
        },
        get type() {
            return n.componentType
        },
        get inputs() {
            return n.inputs
        },
        get outputs() {
            return n.outputs
        },
        get ngContentSelectors() {
            return n.ngContentSelectors
        },
        get isStandalone() {
            return e.standalone
        },
        get isSignal() {
            return e.signals
        }
    }
}
var rC = null;

function er() {
    return rC
}

function iC(t) {
    rC ? ? = t
}
var hd = class {};
var ke = new R(""),
    Pm = (() => {
        let e = class e {
            historyGo(r) {
                throw new Error("")
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: () => M(xk),
            providedIn: "platform"
        });
        let t = e;
        return t
    })(),
    sC = new R(""),
    xk = (() => {
        let e = class e extends Pm {
            constructor() {
                super(), this._doc = M(ke), this._location = window.location, this._history = window.history
            }
            getBaseHrefFromDOM() {
                return er().getBaseHref(this._doc)
            }
            onPopState(r) {
                let i = er().getGlobalEventTarget(this._doc, "window");
                return i.addEventListener("popstate", r, !1), () => i.removeEventListener("popstate", r)
            }
            onHashChange(r) {
                let i = er().getGlobalEventTarget(this._doc, "window");
                return i.addEventListener("hashchange", r, !1), () => i.removeEventListener("hashchange", r)
            }
            get href() {
                return this._location.href
            }
            get protocol() {
                return this._location.protocol
            }
            get hostname() {
                return this._location.hostname
            }
            get port() {
                return this._location.port
            }
            get pathname() {
                return this._location.pathname
            }
            get search() {
                return this._location.search
            }
            get hash() {
                return this._location.hash
            }
            set pathname(r) {
                this._location.pathname = r
            }
            pushState(r, i, s) {
                this._history.pushState(r, i, s)
            }
            replaceState(r, i, s) {
                this._history.replaceState(r, i, s)
            }
            forward() {
                this._history.forward()
            }
            back() {
                this._history.back()
            }
            historyGo(r = 0) {
                this._history.go(r)
            }
            getState() {
                return this._history.state
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: () => new e,
            providedIn: "platform"
        });
        let t = e;
        return t
    })();

function Lm(t, e) {
    if (t.length == 0) return e;
    if (e.length == 0) return t;
    let n = 0;
    return t.endsWith("/") && n++, e.startsWith("/") && n++, n == 2 ? t + e.substring(1) : n == 1 ? t + e : t + "/" + e
}

function YE(t) {
    let e = t.match(/#|\?|$/),
        n = e && e.index || t.length,
        r = n - (t[n - 1] === "/" ? 1 : 0);
    return t.slice(0, r) + t.slice(n)
}

function Rr(t) {
    return t && t[0] !== "?" ? "?" + t : t
}
var es = (() => {
        let e = class e {
            historyGo(r) {
                throw new Error("")
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: () => M(Vm),
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    oC = new R(""),
    Vm = (() => {
        let e = class e extends es {
            constructor(r, i) {
                super(), this._platformLocation = r, this._removeListenerFns = [], this._baseHref = i ? ? this._platformLocation.getBaseHrefFromDOM() ? ? M(ke).location ? .origin ? ? ""
            }
            ngOnDestroy() {
                for (; this._removeListenerFns.length;) this._removeListenerFns.pop()()
            }
            onPopState(r) {
                this._removeListenerFns.push(this._platformLocation.onPopState(r), this._platformLocation.onHashChange(r))
            }
            getBaseHref() {
                return this._baseHref
            }
            prepareExternalUrl(r) {
                return Lm(this._baseHref, r)
            }
            path(r = !1) {
                let i = this._platformLocation.pathname + Rr(this._platformLocation.search),
                    s = this._platformLocation.hash;
                return s && r ? `${i}${s}` : i
            }
            pushState(r, i, s, o) {
                let a = this.prepareExternalUrl(s + Rr(o));
                this._platformLocation.pushState(r, i, a)
            }
            replaceState(r, i, s, o) {
                let a = this.prepareExternalUrl(s + Rr(o));
                this._platformLocation.replaceState(r, i, a)
            }
            forward() {
                this._platformLocation.forward()
            }
            back() {
                this._platformLocation.back()
            }
            getState() {
                return this._platformLocation.getState()
            }
            historyGo(r = 0) {
                this._platformLocation.historyGo ? .(r)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(Pm), C(oC, 8))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    aC = (() => {
        let e = class e extends es {
            constructor(r, i) {
                super(), this._platformLocation = r, this._baseHref = "", this._removeListenerFns = [], i != null && (this._baseHref = i)
            }
            ngOnDestroy() {
                for (; this._removeListenerFns.length;) this._removeListenerFns.pop()()
            }
            onPopState(r) {
                this._removeListenerFns.push(this._platformLocation.onPopState(r), this._platformLocation.onHashChange(r))
            }
            getBaseHref() {
                return this._baseHref
            }
            path(r = !1) {
                let i = this._platformLocation.hash ? ? "#";
                return i.length > 0 ? i.substring(1) : i
            }
            prepareExternalUrl(r) {
                let i = Lm(this._baseHref, r);
                return i.length > 0 ? "#" + i : i
            }
            pushState(r, i, s, o) {
                let a = this.prepareExternalUrl(s + Rr(o));
                a.length == 0 && (a = this._platformLocation.pathname), this._platformLocation.pushState(r, i, a)
            }
            replaceState(r, i, s, o) {
                let a = this.prepareExternalUrl(s + Rr(o));
                a.length == 0 && (a = this._platformLocation.pathname), this._platformLocation.replaceState(r, i, a)
            }
            forward() {
                this._platformLocation.forward()
            }
            back() {
                this._platformLocation.back()
            }
            getState() {
                return this._platformLocation.getState()
            }
            historyGo(r = 0) {
                this._platformLocation.historyGo ? .(r)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(Pm), C(oC, 8))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    ai = (() => {
        let e = class e {
            constructor(r) {
                this._subject = new oe, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = r;
                let i = this._locationStrategy.getBaseHref();
                this._basePath = Rk(YE(JE(i))), this._locationStrategy.onPopState(s => {
                    this._subject.emit({
                        url: this.path(!0),
                        pop: !0,
                        state: s.state,
                        type: s.type
                    })
                })
            }
            ngOnDestroy() {
                this._urlChangeSubscription ? .unsubscribe(), this._urlChangeListeners = []
            }
            path(r = !1) {
                return this.normalize(this._locationStrategy.path(r))
            }
            getState() {
                return this._locationStrategy.getState()
            }
            isCurrentPathEqualTo(r, i = "") {
                return this.path() == this.normalize(r + Rr(i))
            }
            normalize(r) {
                return e.stripTrailingSlash(Nk(this._basePath, JE(r)))
            }
            prepareExternalUrl(r) {
                return r && r[0] !== "/" && (r = "/" + r), this._locationStrategy.prepareExternalUrl(r)
            }
            go(r, i = "", s = null) {
                this._locationStrategy.pushState(s, "", r, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(r + Rr(i)), s)
            }
            replaceState(r, i = "", s = null) {
                this._locationStrategy.replaceState(s, "", r, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(r + Rr(i)), s)
            }
            forward() {
                this._locationStrategy.forward()
            }
            back() {
                this._locationStrategy.back()
            }
            historyGo(r = 0) {
                this._locationStrategy.historyGo ? .(r)
            }
            onUrlChange(r) {
                return this._urlChangeListeners.push(r), this._urlChangeSubscription ? ? = this.subscribe(i => {
                    this._notifyUrlChangeListeners(i.url, i.state)
                }), () => {
                    let i = this._urlChangeListeners.indexOf(r);
                    this._urlChangeListeners.splice(i, 1), this._urlChangeListeners.length === 0 && (this._urlChangeSubscription ? .unsubscribe(), this._urlChangeSubscription = null)
                }
            }
            _notifyUrlChangeListeners(r = "", i) {
                this._urlChangeListeners.forEach(s => s(r, i))
            }
            subscribe(r, i, s) {
                return this._subject.subscribe({
                    next: r,
                    error: i,
                    complete: s
                })
            }
        };
        e.normalizeQueryParams = Rr, e.joinWithSlash = Lm, e.stripTrailingSlash = YE, e.\u0275fac = function(i) {
            return new(i || e)(C(es))
        }, e.\u0275prov = I({
            token: e,
            factory: () => Ak(),
            providedIn: "root"
        });
        let t = e;
        return t
    })();

function Ak() {
    return new ai(C(es))
}

function Nk(t, e) {
    if (!t || !e.startsWith(t)) return e;
    let n = e.substring(t.length);
    return n === "" || ["/", ";", "?", "#"].includes(n[0]) ? n : e
}

function JE(t) {
    return t.replace(/\/index.html$/, "")
}

function Rk(t) {
    if (new RegExp("^(https?:)?//").test(t)) {
        let [, n] = t.split(/\/\/[^\/]+/);
        return n
    }
    return t
}

function fd(t, e) {
    e = encodeURIComponent(e);
    for (let n of t.split(";")) {
        let r = n.indexOf("="),
            [i, s] = r == -1 ? [n, ""] : [n.slice(0, r), n.slice(r + 1)];
        if (i.trim() === e) return decodeURIComponent(s)
    }
    return null
}
var Am = /\s+/,
    XE = [],
    Do = (() => {
        let e = class e {
            constructor(r, i) {
                this._ngEl = r, this._renderer = i, this.initialClasses = XE, this.stateMap = new Map
            }
            set klass(r) {
                this.initialClasses = r != null ? r.trim().split(Am) : XE
            }
            set ngClass(r) {
                this.rawClass = typeof r == "string" ? r.trim().split(Am) : r
            }
            ngDoCheck() {
                for (let i of this.initialClasses) this._updateState(i, !0);
                let r = this.rawClass;
                if (Array.isArray(r) || r instanceof Set)
                    for (let i of r) this._updateState(i, !0);
                else if (r != null)
                    for (let i of Object.keys(r)) this._updateState(i, !!r[i]);
                this._applyStateDiff()
            }
            _updateState(r, i) {
                let s = this.stateMap.get(r);
                s !== void 0 ? (s.enabled !== i && (s.changed = !0, s.enabled = i), s.touched = !0) : this.stateMap.set(r, {
                    enabled: i,
                    changed: !0,
                    touched: !0
                })
            }
            _applyStateDiff() {
                for (let r of this.stateMap) {
                    let i = r[0],
                        s = r[1];
                    s.changed ? (this._toggleClass(i, s.enabled), s.changed = !1) : s.touched || (s.enabled && this._toggleClass(i, !1), this.stateMap.delete(i)), s.touched = !1
                }
            }
            _toggleClass(r, i) {
                r = r.trim(), r.length > 0 && r.split(Am).forEach(s => {
                    i ? this._renderer.addClass(this._ngEl.nativeElement, s) : this._renderer.removeClass(this._ngEl.nativeElement, s)
                })
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(O(je), O(Wt))
        }, e.\u0275dir = et({
            type: e,
            selectors: [
                ["", "ngClass", ""]
            ],
            inputs: {
                klass: [Vt.None, "class", "klass"],
                ngClass: "ngClass"
            },
            standalone: !0
        });
        let t = e;
        return t
    })();
var Nm = class {
        constructor(e, n, r, i) {
            this.$implicit = e, this.ngForOf = n, this.index = r, this.count = i
        }
        get first() {
            return this.index === 0
        }
        get last() {
            return this.index === this.count - 1
        }
        get even() {
            return this.index % 2 === 0
        }
        get odd() {
            return !this.even
        }
    },
    cC = (() => {
        let e = class e {
            set ngForOf(r) {
                this._ngForOf = r, this._ngForOfDirty = !0
            }
            set ngForTrackBy(r) {
                this._trackByFn = r
            }
            get ngForTrackBy() {
                return this._trackByFn
            }
            constructor(r, i, s) {
                this._viewContainer = r, this._template = i, this._differs = s, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null
            }
            set ngForTemplate(r) {
                r && (this._template = r)
            }
            ngDoCheck() {
                if (this._ngForOfDirty) {
                    this._ngForOfDirty = !1;
                    let r = this._ngForOf;
                    if (!this._differ && r)
                        if (0) try {} catch {} else this._differ = this._differs.find(r).create(this.ngForTrackBy)
                }
                if (this._differ) {
                    let r = this._differ.diff(this._ngForOf);
                    r && this._applyChanges(r)
                }
            }
            _applyChanges(r) {
                let i = this._viewContainer;
                r.forEachOperation((s, o, a) => {
                    if (s.previousIndex == null) i.createEmbeddedView(this._template, new Nm(s.item, this._ngForOf, -1, -1), a === null ? void 0 : a);
                    else if (a == null) i.remove(o === null ? void 0 : o);
                    else if (o !== null) {
                        let c = i.get(o);
                        i.move(c, a), eC(c, s)
                    }
                });
                for (let s = 0, o = i.length; s < o; s++) {
                    let c = i.get(s).context;
                    c.index = s, c.count = o, c.ngForOf = this._ngForOf
                }
                r.forEachIdentityChange(s => {
                    let o = i.get(s.currentIndex);
                    eC(o, s)
                })
            }
            static ngTemplateContextGuard(r, i) {
                return !0
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(O(Un), O(vn), O(xm))
        }, e.\u0275dir = et({
            type: e,
            selectors: [
                ["", "ngFor", "", "ngForOf", ""]
            ],
            inputs: {
                ngForOf: "ngForOf",
                ngForTrackBy: "ngForTrackBy",
                ngForTemplate: "ngForTemplate"
            },
            standalone: !0
        });
        let t = e;
        return t
    })();

function eC(t, e) {
    t.context.$implicit = e.item
}
var lC = (() => {
        let e = class e {
            constructor(r, i) {
                this._viewContainer = r, this._context = new Rm, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = i
            }
            set ngIf(r) {
                this._context.$implicit = this._context.ngIf = r, this._updateView()
            }
            set ngIfThen(r) {
                tC("ngIfThen", r), this._thenTemplateRef = r, this._thenViewRef = null, this._updateView()
            }
            set ngIfElse(r) {
                tC("ngIfElse", r), this._elseTemplateRef = r, this._elseViewRef = null, this._updateView()
            }
            _updateView() {
                this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)))
            }
            static ngTemplateContextGuard(r, i) {
                return !0
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(O(Un), O(vn))
        }, e.\u0275dir = et({
            type: e,
            selectors: [
                ["", "ngIf", ""]
            ],
            inputs: {
                ngIf: "ngIf",
                ngIfThen: "ngIfThen",
                ngIfElse: "ngIfElse"
            },
            standalone: !0
        });
        let t = e;
        return t
    })(),
    Rm = class {
        constructor() {
            this.$implicit = null, this.ngIf = null
        }
    };

function tC(t, e) {
    if (!!!(!e || e.createEmbeddedView)) throw new Error(`${t} must be a TemplateRef, but received '${Lt(e)}'.`)
}
var ci = (() => {
        let e = class e {};
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275mod = xe({
            type: e
        }), e.\u0275inj = Te({});
        let t = e;
        return t
    })(),
    Um = "browser",
    Ok = "server";

function ts(t) {
    return t === Um
}

function jm(t) {
    return t === Ok
}
var uC = (() => {
        let e = class e {};
        e.\u0275prov = I({
            token: e,
            providedIn: "root",
            factory: () => ts(M(st)) ? new Om(M(ke), window) : new Fm
        });
        let t = e;
        return t
    })(),
    Om = class {
        constructor(e, n) {
            this.document = e, this.window = n, this.offset = () => [0, 0]
        }
        setOffset(e) {
            Array.isArray(e) ? this.offset = () => e : this.offset = e
        }
        getScrollPosition() {
            return [this.window.scrollX, this.window.scrollY]
        }
        scrollToPosition(e) {
            this.window.scrollTo(e[0], e[1])
        }
        scrollToAnchor(e) {
            let n = Fk(this.document, e);
            n && (this.scrollToElement(n), n.focus())
        }
        setHistoryScrollRestoration(e) {
            this.window.history.scrollRestoration = e
        }
        scrollToElement(e) {
            let n = e.getBoundingClientRect(),
                r = n.left + this.window.pageXOffset,
                i = n.top + this.window.pageYOffset,
                s = this.offset();
            this.window.scrollTo(r - s[0], i - s[1])
        }
    };

function Fk(t, e) {
    let n = t.getElementById(e) || t.getElementsByName(e)[0];
    if (n) return n;
    if (typeof t.createTreeWalker == "function" && t.body && typeof t.body.attachShadow == "function") {
        let r = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT),
            i = r.currentNode;
        for (; i;) {
            let s = i.shadowRoot;
            if (s) {
                let o = s.getElementById(e) || s.querySelector(`[name="${e}"]`);
                if (o) return o
            }
            i = r.nextNode()
        }
    }
    return null
}
var Fm = class {
        setOffset(e) {}
        getScrollPosition() {
            return [0, 0]
        }
        scrollToPosition(e) {}
        scrollToAnchor(e) {}
        setHistoryScrollRestoration(e) {}
    },
    bo = class {};
var Va = class {},
    md = class {},
    ns = class t {
        constructor(e) {
            this.normalizedNames = new Map, this.lazyUpdate = null, e ? typeof e == "string" ? this.lazyInit = () => {
                this.headers = new Map, e.split(`
`).forEach(n => {
                    let r = n.indexOf(":");
                    if (r > 0) {
                        let i = n.slice(0, r),
                            s = i.toLowerCase(),
                            o = n.slice(r + 1).trim();
                        this.maybeSetNormalizedName(i, s), this.headers.has(s) ? this.headers.get(s).push(o) : this.headers.set(s, [o])
                    }
                })
            } : typeof Headers < "u" && e instanceof Headers ? (this.headers = new Map, e.forEach((n, r) => {
                this.setHeaderEntries(r, n)
            })) : this.lazyInit = () => {
                this.headers = new Map, Object.entries(e).forEach(([n, r]) => {
                    this.setHeaderEntries(n, r)
                })
            } : this.headers = new Map
        }
        has(e) {
            return this.init(), this.headers.has(e.toLowerCase())
        }
        get(e) {
            this.init();
            let n = this.headers.get(e.toLowerCase());
            return n && n.length > 0 ? n[0] : null
        }
        keys() {
            return this.init(), Array.from(this.normalizedNames.values())
        }
        getAll(e) {
            return this.init(), this.headers.get(e.toLowerCase()) || null
        }
        append(e, n) {
            return this.clone({
                name: e,
                value: n,
                op: "a"
            })
        }
        set(e, n) {
            return this.clone({
                name: e,
                value: n,
                op: "s"
            })
        }
        delete(e, n) {
            return this.clone({
                name: e,
                value: n,
                op: "d"
            })
        }
        maybeSetNormalizedName(e, n) {
            this.normalizedNames.has(n) || this.normalizedNames.set(n, e)
        }
        init() {
            this.lazyInit && (this.lazyInit instanceof t ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(e => this.applyUpdate(e)), this.lazyUpdate = null))
        }
        copyFrom(e) {
            e.init(), Array.from(e.headers.keys()).forEach(n => {
                this.headers.set(n, e.headers.get(n)), this.normalizedNames.set(n, e.normalizedNames.get(n))
            })
        }
        clone(e) {
            let n = new t;
            return n.lazyInit = this.lazyInit && this.lazyInit instanceof t ? this.lazyInit : this, n.lazyUpdate = (this.lazyUpdate || []).concat([e]), n
        }
        applyUpdate(e) {
            let n = e.name.toLowerCase();
            switch (e.op) {
                case "a":
                case "s":
                    let r = e.value;
                    if (typeof r == "string" && (r = [r]), r.length === 0) return;
                    this.maybeSetNormalizedName(e.name, n);
                    let i = (e.op === "a" ? this.headers.get(n) : void 0) || [];
                    i.push(...r), this.headers.set(n, i);
                    break;
                case "d":
                    let s = e.value;
                    if (!s) this.headers.delete(n), this.normalizedNames.delete(n);
                    else {
                        let o = this.headers.get(n);
                        if (!o) return;
                        o = o.filter(a => s.indexOf(a) === -1), o.length === 0 ? (this.headers.delete(n), this.normalizedNames.delete(n)) : this.headers.set(n, o)
                    }
                    break
            }
        }
        setHeaderEntries(e, n) {
            let r = (Array.isArray(n) ? n : [n]).map(s => s.toString()),
                i = e.toLowerCase();
            this.headers.set(i, r), this.maybeSetNormalizedName(e, i)
        }
        forEach(e) {
            this.init(), Array.from(this.normalizedNames.keys()).forEach(n => e(this.normalizedNames.get(n), this.headers.get(n)))
        }
    };
var zm = class {
    encodeKey(e) {
        return dC(e)
    }
    encodeValue(e) {
        return dC(e)
    }
    decodeKey(e) {
        return decodeURIComponent(e)
    }
    decodeValue(e) {
        return decodeURIComponent(e)
    }
};

function Lk(t, e) {
    let n = new Map;
    return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(i => {
        let s = i.indexOf("="),
            [o, a] = s == -1 ? [e.decodeKey(i), ""] : [e.decodeKey(i.slice(0, s)), e.decodeValue(i.slice(s + 1))],
            c = n.get(o) || [];
        c.push(a), n.set(o, c)
    }), n
}
var Vk = /%(\d[a-f0-9])/gi,
    Uk = {
        40: "@",
        "3A": ":",
        24: "$",
        "2C": ",",
        "3B": ";",
        "3D": "=",
        "3F": "?",
        "2F": "/"
    };

function dC(t) {
    return encodeURIComponent(t).replace(Vk, (e, n) => Uk[n] ? ? e)
}

function gd(t) {
    return `${t}`
}
var li = class t {
    constructor(e = {}) {
        if (this.updates = null, this.cloneFrom = null, this.encoder = e.encoder || new zm, e.fromString) {
            if (e.fromObject) throw new Error("Cannot specify both fromString and fromObject.");
            this.map = Lk(e.fromString, this.encoder)
        } else e.fromObject ? (this.map = new Map, Object.keys(e.fromObject).forEach(n => {
            let r = e.fromObject[n],
                i = Array.isArray(r) ? r.map(gd) : [gd(r)];
            this.map.set(n, i)
        })) : this.map = null
    }
    has(e) {
        return this.init(), this.map.has(e)
    }
    get(e) {
        this.init();
        let n = this.map.get(e);
        return n ? n[0] : null
    }
    getAll(e) {
        return this.init(), this.map.get(e) || null
    }
    keys() {
        return this.init(), Array.from(this.map.keys())
    }
    append(e, n) {
        return this.clone({
            param: e,
            value: n,
            op: "a"
        })
    }
    appendAll(e) {
        let n = [];
        return Object.keys(e).forEach(r => {
            let i = e[r];
            Array.isArray(i) ? i.forEach(s => {
                n.push({
                    param: r,
                    value: s,
                    op: "a"
                })
            }) : n.push({
                param: r,
                value: i,
                op: "a"
            })
        }), this.clone(n)
    }
    set(e, n) {
        return this.clone({
            param: e,
            value: n,
            op: "s"
        })
    }
    delete(e, n) {
        return this.clone({
            param: e,
            value: n,
            op: "d"
        })
    }
    toString() {
        return this.init(), this.keys().map(e => {
            let n = this.encoder.encodeKey(e);
            return this.map.get(e).map(r => n + "=" + this.encoder.encodeValue(r)).join("&")
        }).filter(e => e !== "").join("&")
    }
    clone(e) {
        let n = new t({
            encoder: this.encoder
        });
        return n.cloneFrom = this.cloneFrom || this, n.updates = (this.updates || []).concat(e), n
    }
    init() {
        this.map === null && (this.map = new Map), this.cloneFrom !== null && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(e => this.map.set(e, this.cloneFrom.map.get(e))), this.updates.forEach(e => {
            switch (e.op) {
                case "a":
                case "s":
                    let n = (e.op === "a" ? this.map.get(e.param) : void 0) || [];
                    n.push(gd(e.value)), this.map.set(e.param, n);
                    break;
                case "d":
                    if (e.value !== void 0) {
                        let r = this.map.get(e.param) || [],
                            i = r.indexOf(gd(e.value));
                        i !== -1 && r.splice(i, 1), r.length > 0 ? this.map.set(e.param, r) : this.map.delete(e.param)
                    } else {
                        this.map.delete(e.param);
                        break
                    }
            }
        }), this.cloneFrom = this.updates = null)
    }
};
var $m = class {
    constructor() {
        this.map = new Map
    }
    set(e, n) {
        return this.map.set(e, n), this
    }
    get(e) {
        return this.map.has(e) || this.map.set(e, e.defaultValue()), this.map.get(e)
    }
    delete(e) {
        return this.map.delete(e), this
    }
    has(e) {
        return this.map.has(e)
    }
    keys() {
        return this.map.keys()
    }
};

function jk(t) {
    switch (t) {
        case "DELETE":
        case "GET":
        case "HEAD":
        case "OPTIONS":
        case "JSONP":
            return !1;
        default:
            return !0
    }
}

function hC(t) {
    return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer
}

function fC(t) {
    return typeof Blob < "u" && t instanceof Blob
}

function pC(t) {
    return typeof FormData < "u" && t instanceof FormData
}

function Bk(t) {
    return typeof URLSearchParams < "u" && t instanceof URLSearchParams
}
var La = class t {
        constructor(e, n, r, i) {
            this.url = n, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = e.toUpperCase();
            let s;
            if (jk(this.method) || i ? (this.body = r !== void 0 ? r : null, s = i) : s = r, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.context && (this.context = s.context), s.params && (this.params = s.params), this.transferCache = s.transferCache), this.headers ? ? = new ns, this.context ? ? = new $m, !this.params) this.params = new li, this.urlWithParams = n;
            else {
                let o = this.params.toString();
                if (o.length === 0) this.urlWithParams = n;
                else {
                    let a = n.indexOf("?"),
                        c = a === -1 ? "?" : a < n.length - 1 ? "&" : "";
                    this.urlWithParams = n + c + o
                }
            }
        }
        serializeBody() {
            return this.body === null ? null : hC(this.body) || fC(this.body) || pC(this.body) || Bk(this.body) || typeof this.body == "string" ? this.body : this.body instanceof li ? this.body.toString() : typeof this.body == "object" || typeof this.body == "boolean" || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString()
        }
        detectContentTypeHeader() {
            return this.body === null || pC(this.body) ? null : fC(this.body) ? this.body.type || null : hC(this.body) ? null : typeof this.body == "string" ? "text/plain" : this.body instanceof li ? "application/x-www-form-urlencoded;charset=UTF-8" : typeof this.body == "object" || typeof this.body == "number" || typeof this.body == "boolean" ? "application/json" : null
        }
        clone(e = {}) {
            let n = e.method || this.method,
                r = e.url || this.url,
                i = e.responseType || this.responseType,
                s = e.body !== void 0 ? e.body : this.body,
                o = e.withCredentials !== void 0 ? e.withCredentials : this.withCredentials,
                a = e.reportProgress !== void 0 ? e.reportProgress : this.reportProgress,
                c = e.headers || this.headers,
                l = e.params || this.params,
                u = e.context ? ? this.context;
            return e.setHeaders !== void 0 && (c = Object.keys(e.setHeaders).reduce((d, h) => d.set(h, e.setHeaders[h]), c)), e.setParams && (l = Object.keys(e.setParams).reduce((d, h) => d.set(h, e.setParams[h]), l)), new t(n, r, s, {
                params: l,
                headers: c,
                context: u,
                reportProgress: a,
                responseType: i,
                withCredentials: o
            })
        }
    },
    Eo = function(t) {
        return t[t.Sent = 0] = "Sent", t[t.UploadProgress = 1] = "UploadProgress", t[t.ResponseHeader = 2] = "ResponseHeader", t[t.DownloadProgress = 3] = "DownloadProgress", t[t.Response = 4] = "Response", t[t.User = 5] = "User", t
    }(Eo || {}),
    Ua = class {
        constructor(e, n = wd.Ok, r = "OK") {
            this.headers = e.headers || new ns, this.status = e.status !== void 0 ? e.status : n, this.statusText = e.statusText || r, this.url = e.url || null, this.ok = this.status >= 200 && this.status < 300
        }
    },
    Wm = class t extends Ua {
        constructor(e = {}) {
            super(e), this.type = Eo.ResponseHeader
        }
        clone(e = {}) {
            return new t({
                headers: e.headers || this.headers,
                status: e.status !== void 0 ? e.status : this.status,
                statusText: e.statusText || this.statusText,
                url: e.url || this.url || void 0
            })
        }
    },
    yd = class t extends Ua {
        constructor(e = {}) {
            super(e), this.type = Eo.Response, this.body = e.body !== void 0 ? e.body : null
        }
        clone(e = {}) {
            return new t({
                body: e.body !== void 0 ? e.body : this.body,
                headers: e.headers || this.headers,
                status: e.status !== void 0 ? e.status : this.status,
                statusText: e.statusText || this.statusText,
                url: e.url || this.url || void 0
            })
        }
    },
    vd = class extends Ua {
        constructor(e) {
            super(e, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.status >= 200 && this.status < 300 ? this.message = `Http failure during parsing for ${e.url||"(unknown url)"}` : this.message = `Http failure response for ${e.url||"(unknown url)"}: ${e.status} ${e.statusText}`, this.error = e.error || null
        }
    },
    wd = function(t) {
        return t[t.Continue = 100] = "Continue", t[t.SwitchingProtocols = 101] = "SwitchingProtocols", t[t.Processing = 102] = "Processing", t[t.EarlyHints = 103] = "EarlyHints", t[t.Ok = 200] = "Ok", t[t.Created = 201] = "Created", t[t.Accepted = 202] = "Accepted", t[t.NonAuthoritativeInformation = 203] = "NonAuthoritativeInformation", t[t.NoContent = 204] = "NoContent", t[t.ResetContent = 205] = "ResetContent", t[t.PartialContent = 206] = "PartialContent", t[t.MultiStatus = 207] = "MultiStatus", t[t.AlreadyReported = 208] = "AlreadyReported", t[t.ImUsed = 226] = "ImUsed", t[t.MultipleChoices = 300] = "MultipleChoices", t[t.MovedPermanently = 301] = "MovedPermanently", t[t.Found = 302] = "Found", t[t.SeeOther = 303] = "SeeOther", t[t.NotModified = 304] = "NotModified", t[t.UseProxy = 305] = "UseProxy", t[t.Unused = 306] = "Unused", t[t.TemporaryRedirect = 307] = "TemporaryRedirect", t[t.PermanentRedirect = 308] = "PermanentRedirect", t[t.BadRequest = 400] = "BadRequest", t[t.Unauthorized = 401] = "Unauthorized", t[t.PaymentRequired = 402] = "PaymentRequired", t[t.Forbidden = 403] = "Forbidden", t[t.NotFound = 404] = "NotFound", t[t.MethodNotAllowed = 405] = "MethodNotAllowed", t[t.NotAcceptable = 406] = "NotAcceptable", t[t.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired", t[t.RequestTimeout = 408] = "RequestTimeout", t[t.Conflict = 409] = "Conflict", t[t.Gone = 410] = "Gone", t[t.LengthRequired = 411] = "LengthRequired", t[t.PreconditionFailed = 412] = "PreconditionFailed", t[t.PayloadTooLarge = 413] = "PayloadTooLarge", t[t.UriTooLong = 414] = "UriTooLong", t[t.UnsupportedMediaType = 415] = "UnsupportedMediaType", t[t.RangeNotSatisfiable = 416] = "RangeNotSatisfiable", t[t.ExpectationFailed = 417] = "ExpectationFailed", t[t.ImATeapot = 418] = "ImATeapot", t[t.MisdirectedRequest = 421] = "MisdirectedRequest", t[t.UnprocessableEntity = 422] = "UnprocessableEntity", t[t.Locked = 423] = "Locked", t[t.FailedDependency = 424] = "FailedDependency", t[t.TooEarly = 425] = "TooEarly", t[t.UpgradeRequired = 426] = "UpgradeRequired", t[t.PreconditionRequired = 428] = "PreconditionRequired", t[t.TooManyRequests = 429] = "TooManyRequests", t[t.RequestHeaderFieldsTooLarge = 431] = "RequestHeaderFieldsTooLarge", t[t.UnavailableForLegalReasons = 451] = "UnavailableForLegalReasons", t[t.InternalServerError = 500] = "InternalServerError", t[t.NotImplemented = 501] = "NotImplemented", t[t.BadGateway = 502] = "BadGateway", t[t.ServiceUnavailable = 503] = "ServiceUnavailable", t[t.GatewayTimeout = 504] = "GatewayTimeout", t[t.HttpVersionNotSupported = 505] = "HttpVersionNotSupported", t[t.VariantAlsoNegotiates = 506] = "VariantAlsoNegotiates", t[t.InsufficientStorage = 507] = "InsufficientStorage", t[t.LoopDetected = 508] = "LoopDetected", t[t.NotExtended = 510] = "NotExtended", t[t.NetworkAuthenticationRequired = 511] = "NetworkAuthenticationRequired", t
    }(wd || {});

function Bm(t, e) {
    return {
        body: e,
        headers: t.headers,
        context: t.context,
        observe: t.observe,
        params: t.params,
        reportProgress: t.reportProgress,
        responseType: t.responseType,
        withCredentials: t.withCredentials,
        transferCache: t.transferCache
    }
}
var rs = (() => {
    let e = class e {
        constructor(r) {
            this.handler = r
        }
        request(r, i, s = {}) {
            let o;
            if (r instanceof La) o = r;
            else {
                let l;
                s.headers instanceof ns ? l = s.headers : l = new ns(s.headers);
                let u;
                s.params && (s.params instanceof li ? u = s.params : u = new li({
                    fromObject: s.params
                })), o = new La(r, i, s.body !== void 0 ? s.body : null, {
                    headers: l,
                    context: s.context,
                    params: u,
                    reportProgress: s.reportProgress,
                    responseType: s.responseType || "json",
                    withCredentials: s.withCredentials,
                    transferCache: s.transferCache
                })
            }
            let a = k(o).pipe(nt(l => this.handler.handle(l)));
            if (r instanceof La || s.observe === "events") return a;
            let c = a.pipe(Fe(l => l instanceof yd));
            switch (s.observe || "body") {
                case "body":
                    switch (o.responseType) {
                        case "arraybuffer":
                            return c.pipe(Z(l => {
                                if (l.body !== null && !(l.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer.");
                                return l.body
                            }));
                        case "blob":
                            return c.pipe(Z(l => {
                                if (l.body !== null && !(l.body instanceof Blob)) throw new Error("Response is not a Blob.");
                                return l.body
                            }));
                        case "text":
                            return c.pipe(Z(l => {
                                if (l.body !== null && typeof l.body != "string") throw new Error("Response is not a string.");
                                return l.body
                            }));
                        case "json":
                        default:
                            return c.pipe(Z(l => l.body))
                    }
                case "response":
                    return c;
                default:
                    throw new Error(`Unreachable: unhandled observe type ${s.observe}}`)
            }
        }
        delete(r, i = {}) {
            return this.request("DELETE", r, i)
        }
        get(r, i = {}) {
            return this.request("GET", r, i)
        }
        head(r, i = {}) {
            return this.request("HEAD", r, i)
        }
        jsonp(r, i) {
            return this.request("JSONP", r, {
                params: new li().append(i, "JSONP_CALLBACK"),
                observe: "body",
                responseType: "json"
            })
        }
        options(r, i = {}) {
            return this.request("OPTIONS", r, i)
        }
        patch(r, i, s = {}) {
            return this.request("PATCH", r, Bm(s, i))
        }
        post(r, i, s = {}) {
            return this.request("POST", r, Bm(s, i))
        }
        put(r, i, s = {}) {
            return this.request("PUT", r, Bm(s, i))
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)(C(Va))
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
})();

function vC(t, e) {
    return e(t)
}

function zk(t, e) {
    return (n, r) => e.intercept(n, {
        handle: i => t(i, r)
    })
}

function $k(t, e, n) {
    return (r, i) => Ln(n, () => e(r, s => t(s, i)))
}
var Wk = new R(""),
    Hm = new R(""),
    Hk = new R(""),
    Gk = new R("");

function Zk() {
    let t = null;
    return (e, n) => {
        t === null && (t = (M(Wk, {
            optional: !0
        }) ? ? []).reduceRight(zk, vC));
        let r = M(Yi),
            i = r.add();
        return t(e, n).pipe(Ft(() => r.remove(i)))
    }
}
var gC = (() => {
    let e = class e extends Va {
        constructor(r, i) {
            super(), this.backend = r, this.injector = i, this.chain = null, this.pendingTasks = M(Yi);
            let s = M(Gk, {
                optional: !0
            });
            this.backend = s ? ? r
        }
        handle(r) {
            if (this.chain === null) {
                let s = Array.from(new Set([...this.injector.get(Hm), ...this.injector.get(Hk, [])]));
                this.chain = s.reduceRight((o, a) => $k(o, a, this.injector), vC)
            }
            let i = this.pendingTasks.add();
            return this.chain(r, s => this.backend.handle(s)).pipe(Ft(() => this.pendingTasks.remove(i)))
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)(C(md), C(Ut))
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
})();
var Qk = /^\)\]\}',?\n/;

function qk(t) {
    return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null
}
var mC = (() => {
        let e = class e {
            constructor(r) {
                this.xhrFactory = r
            }
            handle(r) {
                if (r.method === "JSONP") throw new S(-2800, !1);
                let i = this.xhrFactory;
                return (i.\u0275loadImpl ? le(i.\u0275loadImpl()) : k(null)).pipe(Je(() => new ie(o => {
                    let a = i.build();
                    if (a.open(r.method, r.urlWithParams), r.withCredentials && (a.withCredentials = !0), r.headers.forEach((m, y) => a.setRequestHeader(m, y.join(","))), r.headers.has("Accept") || a.setRequestHeader("Accept", "application/json, text/plain, */*"), !r.headers.has("Content-Type")) {
                        let m = r.detectContentTypeHeader();
                        m !== null && a.setRequestHeader("Content-Type", m)
                    }
                    if (r.responseType) {
                        let m = r.responseType.toLowerCase();
                        a.responseType = m !== "json" ? m : "text"
                    }
                    let c = r.serializeBody(),
                        l = null,
                        u = () => {
                            if (l !== null) return l;
                            let m = a.statusText || "OK",
                                y = new ns(a.getAllResponseHeaders()),
                                E = qk(a) || r.url;
                            return l = new Wm({
                                headers: y,
                                status: a.status,
                                statusText: m,
                                url: E
                            }), l
                        },
                        d = () => {
                            let {
                                headers: m,
                                status: y,
                                statusText: E,
                                url: T
                            } = u(), w = null;
                            y !== wd.NoContent && (w = typeof a.response > "u" ? a.responseText : a.response), y === 0 && (y = w ? wd.Ok : 0);
                            let N = y >= 200 && y < 300;
                            if (r.responseType === "json" && typeof w == "string") {
                                let L = w;
                                w = w.replace(Qk, "");
                                try {
                                    w = w !== "" ? JSON.parse(w) : null
                                } catch (D) {
                                    w = L, N && (N = !1, w = {
                                        error: D,
                                        text: w
                                    })
                                }
                            }
                            N ? (o.next(new yd({
                                body: w,
                                headers: m,
                                status: y,
                                statusText: E,
                                url: T || void 0
                            })), o.complete()) : o.error(new vd({
                                error: w,
                                headers: m,
                                status: y,
                                statusText: E,
                                url: T || void 0
                            }))
                        },
                        h = m => {
                            let {
                                url: y
                            } = u(), E = new vd({
                                error: m,
                                status: a.status || 0,
                                statusText: a.statusText || "Unknown Error",
                                url: y || void 0
                            });
                            o.error(E)
                        },
                        f = !1,
                        p = m => {
                            f || (o.next(u()), f = !0);
                            let y = {
                                type: Eo.DownloadProgress,
                                loaded: m.loaded
                            };
                            m.lengthComputable && (y.total = m.total), r.responseType === "text" && a.responseText && (y.partialText = a.responseText), o.next(y)
                        },
                        g = m => {
                            let y = {
                                type: Eo.UploadProgress,
                                loaded: m.loaded
                            };
                            m.lengthComputable && (y.total = m.total), o.next(y)
                        };
                    return a.addEventListener("load", d), a.addEventListener("error", h), a.addEventListener("timeout", h), a.addEventListener("abort", h), r.reportProgress && (a.addEventListener("progress", p), c !== null && a.upload && a.upload.addEventListener("progress", g)), a.send(c), o.next({
                        type: Eo.Sent
                    }), () => {
                        a.removeEventListener("error", h), a.removeEventListener("abort", h), a.removeEventListener("load", d), a.removeEventListener("timeout", h), r.reportProgress && (a.removeEventListener("progress", p), c !== null && a.upload && a.upload.removeEventListener("progress", g)), a.readyState !== a.DONE && a.abort()
                    }
                })))
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(bo))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    wC = new R(""),
    Kk = "XSRF-TOKEN",
    Yk = new R("", {
        providedIn: "root",
        factory: () => Kk
    }),
    Jk = "X-XSRF-TOKEN",
    Xk = new R("", {
        providedIn: "root",
        factory: () => Jk
    }),
    _d = class {},
    eP = (() => {
        let e = class e {
            constructor(r, i, s) {
                this.doc = r, this.platform = i, this.cookieName = s, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0
            }
            getToken() {
                if (this.platform === "server") return null;
                let r = this.doc.cookie || "";
                return r !== this.lastCookieString && (this.parseCount++, this.lastToken = fd(r, this.cookieName), this.lastCookieString = r), this.lastToken
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(ke), C(st), C(Yk))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })();

function tP(t, e) {
    let n = t.url.toLowerCase();
    if (!M(wC) || t.method === "GET" || t.method === "HEAD" || n.startsWith("http://") || n.startsWith("https://")) return e(t);
    let r = M(_d).getToken(),
        i = M(Xk);
    return r != null && !t.headers.has(i) && (t = t.clone({
        headers: t.headers.set(i, r)
    })), e(t)
}
var _C = function(t) {
    return t[t.Interceptors = 0] = "Interceptors", t[t.LegacyInterceptors = 1] = "LegacyInterceptors", t[t.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", t[t.NoXsrfProtection = 3] = "NoXsrfProtection", t[t.JsonpSupport = 4] = "JsonpSupport", t[t.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", t[t.Fetch = 6] = "Fetch", t
}(_C || {});

function nP(t, e) {
    return {\
        u0275kind: t,
        \u0275providers: e
    }
}

function rP(...t) {
    let e = [rs, mC, gC, {
        provide: Va,
        useExisting: gC
    }, {
        provide: md,
        useExisting: mC
    }, {
        provide: Hm,
        useValue: tP,
        multi: !0
    }, {
        provide: wC,
        useValue: !0
    }, {
        provide: _d,
        useClass: eP
    }];
    for (let n of t) e.push(...n.\u0275providers);
    return Ru(e)
}
var yC = new R("");

function iP() {
    return nP(_C.LegacyInterceptors, [{
        provide: yC,
        useFactory: Zk
    }, {
        provide: Hm,
        useExisting: yC,
        multi: !0
    }])
}
var bC = (() => {
    let e = class e {};
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275mod = xe({
        type: e
    }), e.\u0275inj = Te({
        providers: [rP(iP())]
    });
    let t = e;
    return t
})();
var Qm = class extends hd {
        constructor() {
            super(...arguments), this.supportsDOMEvents = !0
        }
    },
    qm = class t extends Qm {
        static makeCurrent() {
            iC(new t)
        }
        onAndCancel(e, n, r) {
            return e.addEventListener(n, r), () => {
                e.removeEventListener(n, r)
            }
        }
        dispatchEvent(e, n) {
            e.dispatchEvent(n)
        }
        remove(e) {
            e.parentNode && e.parentNode.removeChild(e)
        }
        createElement(e, n) {
            return n = n || this.getDefaultDocument(), n.createElement(e)
        }
        createHtmlDocument() {
            return document.implementation.createHTMLDocument("fakeTitle")
        }
        getDefaultDocument() {
            return document
        }
        isElementNode(e) {
            return e.nodeType === Node.ELEMENT_NODE
        }
        isShadowRoot(e) {
            return e instanceof DocumentFragment
        }
        getGlobalEventTarget(e, n) {
            return n === "window" ? window : n === "document" ? e : n === "body" ? e.body : null
        }
        getBaseHref(e) {
            let n = sP();
            return n == null ? null : oP(n)
        }
        resetBaseElement() {
            ja = null
        }
        getUserAgent() {
            return window.navigator.userAgent
        }
        getCookie(e) {
            return fd(document.cookie, e)
        }
    },
    ja = null;

function sP() {
    return ja = ja || document.querySelector("base"), ja ? ja.getAttribute("href") : null
}

function oP(t) {
    return new URL(t, document.baseURI).pathname
}
var Km = class {
        addToWindow(e) {
            Kt.getAngularTestability = (r, i = !0) => {
                let s = e.findTestabilityInTree(r, i);
                if (s == null) throw new S(5103, !1);
                return s
            }, Kt.getAllAngularTestabilities = () => e.getAllTestabilities(), Kt.getAllAngularRootElements = () => e.getAllRootElements();
            let n = r => {
                let i = Kt.getAllAngularTestabilities(),
                    s = i.length,
                    o = function() {
                        s--, s == 0 && r()
                    };
                i.forEach(a => {
                    a.whenStable(o)
                })
            };
            Kt.frameworkStabilizers || (Kt.frameworkStabilizers = []), Kt.frameworkStabilizers.push(n)
        }
        findTestabilityInTree(e, n, r) {
            if (n == null) return null;
            let i = e.getTestability(n);
            return i ? ? (r ? er().isShadowRoot(n) ? this.findTestabilityInTree(e, n.host, !0) : this.findTestabilityInTree(e, n.parentElement, !0) : null)
        }
    },
    aP = (() => {
        let e = class e {
            build() {
                return new XMLHttpRequest
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    Ym = new R(""),
    SC = (() => {
        let e = class e {
            constructor(r, i) {
                this._zone = i, this._eventNameToPlugin = new Map, r.forEach(s => {
                    s.manager = this
                }), this._plugins = r.slice().reverse()
            }
            addEventListener(r, i, s) {
                return this._findPluginFor(i).addEventListener(r, i, s)
            }
            getZone() {
                return this._zone
            }
            _findPluginFor(r) {
                let i = this._eventNameToPlugin.get(r);
                if (i) return i;
                if (i = this._plugins.find(o => o.supports(r)), !i) throw new S(5101, !1);
                return this._eventNameToPlugin.set(r, i), i
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(Ym), C(ye))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    bd = class {
        constructor(e) {
            this._doc = e
        }
    },
    Gm = "ng-app-id",
    MC = (() => {
        let e = class e {
            constructor(r, i, s, o = {}) {
                this.doc = r, this.appId = i, this.nonce = s, this.platformId = o, this.styleRef = new Map, this.hostNodes = new Set, this.styleNodesInDOM = this.collectServerRenderedStyles(), this.platformIsServer = jm(o), this.resetHostNodes()
            }
            addStyles(r) {
                for (let i of r) this.changeUsageCount(i, 1) === 1 && this.onStyleAdded(i)
            }
            removeStyles(r) {
                for (let i of r) this.changeUsageCount(i, -1) <= 0 && this.onStyleRemoved(i)
            }
            ngOnDestroy() {
                let r = this.styleNodesInDOM;
                r && (r.forEach(i => i.remove()), r.clear());
                for (let i of this.getAllStyles()) this.onStyleRemoved(i);
                this.resetHostNodes()
            }
            addHost(r) {
                this.hostNodes.add(r);
                for (let i of this.getAllStyles()) this.addStyleToHost(r, i)
            }
            removeHost(r) {
                this.hostNodes.delete(r)
            }
            getAllStyles() {
                return this.styleRef.keys()
            }
            onStyleAdded(r) {
                for (let i of this.hostNodes) this.addStyleToHost(i, r)
            }
            onStyleRemoved(r) {
                let i = this.styleRef;
                i.get(r) ? .elements ? .forEach(s => s.remove()), i.delete(r)
            }
            collectServerRenderedStyles() {
                let r = this.doc.head ? .querySelectorAll(`style[${Gm}="${this.appId}"]`);
                if (r ? .length) {
                    let i = new Map;
                    return r.forEach(s => {
                        s.textContent != null && i.set(s.textContent, s)
                    }), i
                }
                return null
            }
            changeUsageCount(r, i) {
                let s = this.styleRef;
                if (s.has(r)) {
                    let o = s.get(r);
                    return o.usage += i, o.usage
                }
                return s.set(r, {
                    usage: i,
                    elements: []
                }), i
            }
            getStyleElement(r, i) {
                let s = this.styleNodesInDOM,
                    o = s ? .get(i);
                if (o ? .parentNode === r) return s.delete(i), o.removeAttribute(Gm), o; {
                    let a = this.doc.createElement("style");
                    return this.nonce && a.setAttribute("nonce", this.nonce), a.textContent = i, this.platformIsServer && a.setAttribute(Gm, this.appId), r.appendChild(a), a
                }
            }
            addStyleToHost(r, i) {
                let s = this.getStyleElement(r, i),
                    o = this.styleRef,
                    a = o.get(i) ? .elements;
                a ? a.push(s) : o.set(i, {
                    elements: [s],
                    usage: 1
                })
            }
            resetHostNodes() {
                let r = this.hostNodes;
                r.clear(), r.add(this.doc.head)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(ke), C(Lu), C(om, 8), C(st))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    Zm = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: "http://www.w3.org/1999/xhtml",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/",
        math: "http://www.w3.org/1998/MathML/"
    },
    Xm = /%COMP%/g,
    IC = "%COMP%",
    cP = `_nghost-${IC}`,
    lP = `_ngcontent-${IC}`,
    uP = !0,
    dP = new R("", {
        providedIn: "root",
        factory: () => uP
    });

function hP(t) {
    return lP.replace(Xm, t)
}

function fP(t) {
    return cP.replace(Xm, t)
}

function TC(t, e) {
    return e.map(n => n.replace(Xm, t))
}
var Dd = (() => {
        let e = class e {
            constructor(r, i, s, o, a, c, l, u = null) {
                this.eventManager = r, this.sharedStylesHost = i, this.appId = s, this.removeStylesOnCompDestroy = o, this.doc = a, this.platformId = c, this.ngZone = l, this.nonce = u, this.rendererByCompId = new Map, this.platformIsServer = jm(c), this.defaultRenderer = new Ba(r, a, l, this.platformIsServer)
            }
            createRenderer(r, i) {
                if (!r || !i) return this.defaultRenderer;
                this.platformIsServer && i.encapsulation === gn.ShadowDom && (i = Q(_({}, i), {
                    encapsulation: gn.Emulated
                }));
                let s = this.getOrCreateRenderer(r, i);
                return s instanceof Ed ? s.applyToHost(r) : s instanceof za && s.applyStyles(), s
            }
            getOrCreateRenderer(r, i) {
                let s = this.rendererByCompId,
                    o = s.get(i.id);
                if (!o) {
                    let a = this.doc,
                        c = this.ngZone,
                        l = this.eventManager,
                        u = this.sharedStylesHost,
                        d = this.removeStylesOnCompDestroy,
                        h = this.platformIsServer;
                    switch (i.encapsulation) {
                        case gn.Emulated:
                            o = new Ed(l, u, i, this.appId, d, a, c, h);
                            break;
                        case gn.ShadowDom:
                            return new Jm(l, u, r, i, a, c, this.nonce, h);
                        default:
                            o = new za(l, u, i, d, a, c, h);
                            break
                    }
                    s.set(i.id, o)
                }
                return o
            }
            ngOnDestroy() {
                this.rendererByCompId.clear()
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(SC), C(MC), C(Lu), C(dP), C(ke), C(st), C(ye), C(om))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    Ba = class {
        constructor(e, n, r, i) {
            this.eventManager = e, this.doc = n, this.ngZone = r, this.platformIsServer = i, this.data = Object.create(null), this.throwOnSyntheticProps = !0, this.destroyNode = null
        }
        destroy() {}
        createElement(e, n) {
            return n ? this.doc.createElementNS(Zm[n] || n, e) : this.doc.createElement(e)
        }
        createComment(e) {
            return this.doc.createComment(e)
        }
        createText(e) {
            return this.doc.createTextNode(e)
        }
        appendChild(e, n) {
            (EC(e) ? e.content : e).appendChild(n)
        }
        insertBefore(e, n, r) {
            e && (EC(e) ? e.content : e).insertBefore(n, r)
        }
        removeChild(e, n) {
            e && e.removeChild(n)
        }
        selectRootElement(e, n) {
            let r = typeof e == "string" ? this.doc.querySelector(e) : e;
            if (!r) throw new S(-5104, !1);
            return n || (r.textContent = ""), r
        }
        parentNode(e) {
            return e.parentNode
        }
        nextSibling(e) {
            return e.nextSibling
        }
        setAttribute(e, n, r, i) {
            if (i) {
                n = i + ":" + n;
                let s = Zm[i];
                s ? e.setAttributeNS(s, n, r) : e.setAttribute(n, r)
            } else e.setAttribute(n, r)
        }
        removeAttribute(e, n, r) {
            if (r) {
                let i = Zm[r];
                i ? e.removeAttributeNS(i, n) : e.removeAttribute(`${r}:${n}`)
            } else e.removeAttribute(n)
        }
        addClass(e, n) {
            e.classList.add(n)
        }
        removeClass(e, n) {
            e.classList.remove(n)
        }
        setStyle(e, n, r, i) {
            i & (Cr.DashCase | Cr.Important) ? e.style.setProperty(n, r, i & Cr.Important ? "important" : "") : e.style[n] = r
        }
        removeStyle(e, n, r) {
            r & Cr.DashCase ? e.style.removeProperty(n) : e.style[n] = ""
        }
        setProperty(e, n, r) {
            e != null && (e[n] = r)
        }
        setValue(e, n) {
            e.nodeValue = n
        }
        listen(e, n, r) {
            if (typeof e == "string" && (e = er().getGlobalEventTarget(this.doc, e), !e)) throw new Error(`Unsupported event target ${e} for event ${n}`);
            return this.eventManager.addEventListener(e, n, this.decoratePreventDefault(r))
        }
        decoratePreventDefault(e) {
            return n => {
                if (n === "__ngUnwrap__") return e;
                (this.platformIsServer ? this.ngZone.runGuarded(() => e(n)) : e(n)) === !1 && n.preventDefault()
            }
        }
    };

function EC(t) {
    return t.tagName === "TEMPLATE" && t.content !== void 0
}
var Jm = class extends Ba {
        constructor(e, n, r, i, s, o, a, c) {
            super(e, s, o, c), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({
                mode: "open"
            }), this.sharedStylesHost.addHost(this.shadowRoot);
            let l = TC(i.id, i.styles);
            for (let u of l) {
                let d = document.createElement("style");
                a && d.setAttribute("nonce", a), d.textContent = u, this.shadowRoot.appendChild(d)
            }
        }
        nodeOrShadowRoot(e) {
            return e === this.hostEl ? this.shadowRoot : e
        }
        appendChild(e, n) {
            return super.appendChild(this.nodeOrShadowRoot(e), n)
        }
        insertBefore(e, n, r) {
            return super.insertBefore(this.nodeOrShadowRoot(e), n, r)
        }
        removeChild(e, n) {
            return super.removeChild(this.nodeOrShadowRoot(e), n)
        }
        parentNode(e) {
            return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))
        }
        destroy() {
            this.sharedStylesHost.removeHost(this.shadowRoot)
        }
    },
    za = class extends Ba {
        constructor(e, n, r, i, s, o, a, c) {
            super(e, s, o, a), this.sharedStylesHost = n, this.removeStylesOnCompDestroy = i, this.styles = c ? TC(c, r.styles) : r.styles
        }
        applyStyles() {
            this.sharedStylesHost.addStyles(this.styles)
        }
        destroy() {
            this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles)
        }
    },
    Ed = class extends za {
        constructor(e, n, r, i, s, o, a, c) {
            let l = i + "-" + r.id;
            super(e, n, r, s, o, a, c, l), this.contentAttr = hP(l), this.hostAttr = fP(l)
        }
        applyToHost(e) {
            this.applyStyles(), this.setAttribute(e, this.hostAttr, "")
        }
        createElement(e, n) {
            let r = super.createElement(e, n);
            return super.setAttribute(r, this.contentAttr, ""), r
        }
    },
    pP = (() => {
        let e = class e extends bd {
            constructor(r) {
                super(r)
            }
            supports(r) {
                return !0
            }
            addEventListener(r, i, s) {
                return r.addEventListener(i, s, !1), () => this.removeEventListener(r, i, s)
            }
            removeEventListener(r, i, s) {
                return r.removeEventListener(i, s)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(ke))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    CC = ["alt", "control", "meta", "shift"],
    gP = {
        "\b": "Backspace",
        "	": "Tab",
        "\x7F": "Delete",
        "\x1B": "Escape",
        Del: "Delete",
        Esc: "Escape",
        Left: "ArrowLeft",
        Right: "ArrowRight",
        Up: "ArrowUp",
        Down: "ArrowDown",
        Menu: "ContextMenu",
        Scroll: "ScrollLock",
        Win: "OS"
    },
    mP = {
        alt: t => t.altKey,
        control: t => t.ctrlKey,
        meta: t => t.metaKey,
        shift: t => t.shiftKey
    },
    yP = (() => {
        let e = class e extends bd {
            constructor(r) {
                super(r)
            }
            supports(r) {
                return e.parseEventName(r) != null
            }
            addEventListener(r, i, s) {
                let o = e.parseEventName(i),
                    a = e.eventCallback(o.fullKey, s, this.manager.getZone());
                return this.manager.getZone().runOutsideAngular(() => er().onAndCancel(r, o.domEventName, a))
            }
            static parseEventName(r) {
                let i = r.toLowerCase().split("."),
                    s = i.shift();
                if (i.length === 0 || !(s === "keydown" || s === "keyup")) return null;
                let o = e._normalizeKey(i.pop()),
                    a = "",
                    c = i.indexOf("code");
                if (c > -1 && (i.splice(c, 1), a = "code."), CC.forEach(u => {
                        let d = i.indexOf(u);
                        d > -1 && (i.splice(d, 1), a += u + ".")
                    }), a += o, i.length != 0 || o.length === 0) return null;
                let l = {};
                return l.domEventName = s, l.fullKey = a, l
            }
            static matchEventFullKeyCode(r, i) {
                let s = gP[r.key] || r.key,
                    o = "";
                return i.indexOf("code.") > -1 && (s = r.code, o = "code."), s == null || !s ? !1 : (s = s.toLowerCase(), s === " " ? s = "space" : s === "." && (s = "dot"), CC.forEach(a => {
                    if (a !== s) {
                        let c = mP[a];
                        c(r) && (o += a + ".")
                    }
                }), o += s, o === i)
            }
            static eventCallback(r, i, s) {
                return o => {
                    e.matchEventFullKeyCode(o, r) && s.runGuarded(() => i(o))
                }
            }
            static _normalizeKey(r) {
                return r === "esc" ? "escape" : r
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(ke))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })();

function vP() {
    qm.makeCurrent()
}

function wP() {
    return new yn
}

function _P() {
    return jD(document), document
}
var bP = [{
        provide: st,
        useValue: Um
    }, {
        provide: sm,
        useValue: vP,
        multi: !0
    }, {
        provide: ke,
        useFactory: _P,
        deps: []
    }],
    xC = Tm(QE, "browser", bP),
    DP = new R(""),
    EP = [{
        provide: Pa,
        useClass: Km,
        deps: []
    }, {
        provide: Sm,
        useClass: rd,
        deps: [ye, id, Pa]
    }, {
        provide: rd,
        useClass: rd,
        deps: [ye, id, Pa]
    }],
    CP = [{
            provide: Ou,
            useValue: "root"
        }, {
            provide: yn,
            useFactory: wP,
            deps: []
        }, {
            provide: Ym,
            useClass: pP,
            multi: !0,
            deps: [ke, ye, st]
        }, {
            provide: Ym,
            useClass: yP,
            multi: !0,
            deps: [ke]
        }, Dd, MC, SC, {
            provide: Pn,
            useExisting: Dd
        }, {
            provide: bo,
            useClass: aP,
            deps: []
        },
        []
    ],
    AC = (() => {
        let e = class e {
            constructor(r) {}
            static withServerTransition(r) {
                return {
                    ngModule: e,
                    providers: [{
                        provide: Lu,
                        useValue: r.appId
                    }]
                }
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(DP, 12))
        }, e.\u0275mod = xe({
            type: e
        }), e.\u0275inj = Te({
            providers: [...CP, ...EP],
            imports: [ci, qE]
        });
        let t = e;
        return t
    })();
var NC = (() => {
    let e = class e {
        constructor(r) {
            this._doc = r
        }
        getTitle() {
            return this._doc.title
        }
        setTitle(r) {
            this._doc.title = r || ""
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)(C(ke))
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
})();
var ce = function(t) {
        return t[t.State = 0] = "State", t[t.Transition = 1] = "Transition", t[t.Sequence = 2] = "Sequence", t[t.Group = 3] = "Group", t[t.Animate = 4] = "Animate", t[t.Keyframes = 5] = "Keyframes", t[t.Style = 6] = "Style", t[t.Trigger = 7] = "Trigger", t[t.Reference = 8] = "Reference", t[t.AnimateChild = 9] = "AnimateChild", t[t.AnimateRef = 10] = "AnimateRef", t[t.Query = 11] = "Query", t[t.Stagger = 12] = "Stagger", t
    }(ce || {}),
    tr = "*";

function OC(t, e = null) {
    return {
        type: ce.Animate,
        styles: e,
        timings: t
    }
}

function ry(t, e = null) {
    return {
        type: ce.Sequence,
        steps: t,
        options: e
    }
}

function Co(t) {
    return {
        type: ce.Style,
        styles: t,
        offset: null
    }
}
var Cd = (() => {
        let e = class e {};
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: () => M(SP),
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    ey = class {},
    SP = (() => {
        let e = class e extends Cd {
            constructor(r, i) {
                super(), this.animationModuleType = M(Oa, {
                    optional: !0
                }), this._nextAnimationId = 0;
                let s = {
                    id: "0",
                    encapsulation: gn.None,
                    styles: [],
                    data: {
                        animation: []
                    }
                };
                if (this._renderer = r.createRenderer(i.body, s), this.animationModuleType === null && !IP(this._renderer)) throw new S(3600, !1)
            }
            build(r) {
                let i = this._nextAnimationId;
                this._nextAnimationId++;
                let s = Array.isArray(r) ? ry(r) : r;
                return FC(this._renderer, null, i, "register", [s]), new ty(i, this._renderer)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(Pn), C(ke))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    ty = class extends ey {
        constructor(e, n) {
            super(), this._id = e, this._renderer = n
        }
        create(e, n) {
            return new ny(this._id, e, n || {}, this._renderer)
        }
    },
    ny = class {
        constructor(e, n, r, i) {
            this.id = e, this.element = n, this._renderer = i, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", r)
        }
        _listen(e, n) {
            return this._renderer.listen(this.element, `@@${this.id}:${e}`, n)
        }
        _command(e, ...n) {
            FC(this._renderer, this.element, this.id, e, n)
        }
        onDone(e) {
            this._listen("done", e)
        }
        onStart(e) {
            this._listen("start", e)
        }
        onDestroy(e) {
            this._listen("destroy", e)
        }
        init() {
            this._command("init")
        }
        hasStarted() {
            return this._started
        }
        play() {
            this._command("play"), this._started = !0
        }
        pause() {
            this._command("pause")
        }
        restart() {
            this._command("restart")
        }
        finish() {
            this._command("finish")
        }
        destroy() {
            this._command("destroy")
        }
        reset() {
            this._command("reset"), this._started = !1
        }
        setPosition(e) {
            this._command("setPosition", e)
        }
        getPosition() {
            return MP(this._renderer) ? .engine ? .players[this.id] ? .getPosition() ? ? 0
        }
    };

function FC(t, e, n, r, i) {
    t.setProperty(e, `@@${n}:${r}`, i)
}

function MP(t) {
    let e = t.\u0275type;
    return e === 0 ? t : e === 1 ? t.animationRenderer : null
}

function IP(t) {
    let e = t.\u0275type;
    return e === 0 || e === 1
}
var ui = class {
        constructor(e = 0, n = 0) {
            this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._originalOnDoneFns = [], this._originalOnStartFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = e + n
        }
        _onFinish() {
            this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = [])
        }
        onStart(e) {
            this._originalOnStartFns.push(e), this._onStartFns.push(e)
        }
        onDone(e) {
            this._originalOnDoneFns.push(e), this._onDoneFns.push(e)
        }
        onDestroy(e) {
            this._onDestroyFns.push(e)
        }
        hasStarted() {
            return this._started
        }
        init() {}
        play() {
            this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0
        }
        triggerMicrotask() {
            queueMicrotask(() => this._onFinish())
        }
        _onStart() {
            this._onStartFns.forEach(e => e()), this._onStartFns = []
        }
        pause() {}
        restart() {}
        finish() {
            this._onFinish()
        }
        destroy() {
            this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = [])
        }
        reset() {
            this._started = !1, this._finished = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns
        }
        setPosition(e) {
            this._position = this.totalTime ? e * this.totalTime : 1
        }
        getPosition() {
            return this.totalTime ? this._position / this.totalTime : 1
        }
        triggerCallback(e) {
            let n = e == "start" ? this._onStartFns : this._onDoneFns;
            n.forEach(r => r()), n.length = 0
        }
    },
    $a = class {
        constructor(e) {
            this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = e;
            let n = 0,
                r = 0,
                i = 0,
                s = this.players.length;
            s == 0 ? queueMicrotask(() => this._onFinish()) : this.players.forEach(o => {
                o.onDone(() => {
                    ++n == s && this._onFinish()
                }), o.onDestroy(() => {
                    ++r == s && this._onDestroy()
                }), o.onStart(() => {
                    ++i == s && this._onStart()
                })
            }), this.totalTime = this.players.reduce((o, a) => Math.max(o, a.totalTime), 0)
        }
        _onFinish() {
            this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = [])
        }
        init() {
            this.players.forEach(e => e.init())
        }
        onStart(e) {
            this._onStartFns.push(e)
        }
        _onStart() {
            this.hasStarted() || (this._started = !0, this._onStartFns.forEach(e => e()), this._onStartFns = [])
        }
        onDone(e) {
            this._onDoneFns.push(e)
        }
        onDestroy(e) {
            this._onDestroyFns.push(e)
        }
        hasStarted() {
            return this._started
        }
        play() {
            this.parentPlayer || this.init(), this._onStart(), this.players.forEach(e => e.play())
        }
        pause() {
            this.players.forEach(e => e.pause())
        }
        restart() {
            this.players.forEach(e => e.restart())
        }
        finish() {
            this._onFinish(), this.players.forEach(e => e.finish())
        }
        destroy() {
            this._onDestroy()
        }
        _onDestroy() {
            this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(e => e.destroy()), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = [])
        }
        reset() {
            this.players.forEach(e => e.reset()), this._destroyed = !1, this._finished = !1, this._started = !1
        }
        setPosition(e) {
            let n = e * this.totalTime;
            this.players.forEach(r => {
                let i = r.totalTime ? Math.min(1, n / r.totalTime) : 1;
                r.setPosition(i)
            })
        }
        getPosition() {
            let e = this.players.reduce((n, r) => n === null || r.totalTime > n.totalTime ? r : n, null);
            return e != null ? e.getPosition() : 0
        }
        beforeDestroy() {
            this.players.forEach(e => {
                e.beforeDestroy && e.beforeDestroy()
            })
        }
        triggerCallback(e) {
            let n = e == "start" ? this._onStartFns : this._onDoneFns;
            n.forEach(r => r()), n.length = 0
        }
    },
    Sd = "!";

function kC(t) {
    return new S(3e3, !1)
}

function xP() {
    return new S(3100, !1)
}

function AP() {
    return new S(3101, !1)
}

function NP(t) {
    return new S(3001, !1)
}

function RP(t) {
    return new S(3003, !1)
}

function OP(t) {
    return new S(3004, !1)
}

function FP(t, e) {
    return new S(3005, !1)
}

function kP() {
    return new S(3006, !1)
}

function PP() {
    return new S(3007, !1)
}

function LP(t, e) {
    return new S(3008, !1)
}

function VP(t) {
    return new S(3002, !1)
}

function UP(t, e, n, r, i) {
    return new S(3010, !1)
}

function jP() {
    return new S(3011, !1)
}

function BP() {
    return new S(3012, !1)
}

function zP() {
    return new S(3200, !1)
}

function $P() {
    return new S(3202, !1)
}

function WP() {
    return new S(3013, !1)
}

function HP(t) {
    return new S(3014, !1)
}

function GP(t) {
    return new S(3015, !1)
}

function ZP(t) {
    return new S(3016, !1)
}

function QP(t, e) {
    return new S(3404, !1)
}

function qP(t) {
    return new S(3502, !1)
}

function KP(t) {
    return new S(3503, !1)
}

function YP() {
    return new S(3300, !1)
}

function JP(t) {
    return new S(3504, !1)
}

function XP(t) {
    return new S(3301, !1)
}

function eL(t, e) {
    return new S(3302, !1)
}

function tL(t) {
    return new S(3303, !1)
}

function nL(t, e) {
    return new S(3400, !1)
}

function rL(t) {
    return new S(3401, !1)
}

function iL(t) {
    return new S(3402, !1)
}

function sL(t, e) {
    return new S(3505, !1)
}

function di(t) {
    switch (t.length) {
        case 0:
            return new ui;
        case 1:
            return t[0];
        default:
            return new $a(t)
    }
}

function qC(t, e, n = new Map, r = new Map) {
    let i = [],
        s = [],
        o = -1,
        a = null;
    if (e.forEach(c => {
            let l = c.get("offset"),
                u = l == o,
                d = u && a || new Map;
            c.forEach((h, f) => {
                let p = f,
                    g = h;
                if (f !== "offset") switch (p = t.normalizePropertyName(p, i), g) {
                    case Sd:
                        g = n.get(f);
                        break;
                    case tr:
                        g = r.get(f);
                        break;
                    default:
                        g = t.normalizeStyleValue(f, p, g, i);
                        break
                }
                d.set(p, g)
            }), u || s.push(d), a = d, o = l
        }), i.length) throw qP(i);
    return s
}

function My(t, e, n, r) {
    switch (e) {
        case "start":
            t.onStart(() => r(n && iy(n, "start", t)));
            break;
        case "done":
            t.onDone(() => r(n && iy(n, "done", t)));
            break;
        case "destroy":
            t.onDestroy(() => r(n && iy(n, "destroy", t)));
            break
    }
}

function iy(t, e, n) {
    let r = n.totalTime,
        i = !!n.disabled,
        s = Iy(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, r ? ? t.totalTime, i),
        o = t._data;
    return o != null && (s._data = o), s
}

function Iy(t, e, n, r, i = "", s = 0, o) {
    return {
        element: t,
        triggerName: e,
        fromState: n,
        toState: r,
        phaseName: i,
        totalTime: s,
        disabled: !!o
    }
}

function tn(t, e, n) {
    let r = t.get(e);
    return r || t.set(e, r = n), r
}

function PC(t) {
    let e = t.indexOf(":"),
        n = t.substring(1, e),
        r = t.slice(e + 1);
    return [n, r]
}
var oL = typeof document > "u" ? null : document.documentElement;

function Ty(t) {
    let e = t.parentNode || t.host || null;
    return e === oL ? null : e
}

function aL(t) {
    return t.substring(1, 6) == "ebkit"
}
var is = null,
    LC = !1;

function cL(t) {
    is || (is = lL() || {}, LC = is.style ? "WebkitAppearance" in is.style : !1);
    let e = !0;
    return is.style && !aL(t) && (e = t in is.style, !e && LC && (e = "Webkit" + t.charAt(0).toUpperCase() + t.slice(1) in is.style)), e
}

function lL() {
    return typeof document < "u" ? document.body : null
}

function KC(t, e) {
    for (; e;) {
        if (e === t) return !0;
        e = Ty(e)
    }
    return !1
}

function YC(t, e, n) {
    if (n) return Array.from(t.querySelectorAll(e));
    let r = t.querySelector(e);
    return r ? [r] : []
}
var xy = (() => {
        let e = class e {
            validateStyleProperty(r) {
                return cL(r)
            }
            matchesElement(r, i) {
                return !1
            }
            containsElement(r, i) {
                return KC(r, i)
            }
            getParentElement(r) {
                return Ty(r)
            }
            query(r, i, s) {
                return YC(r, i, s)
            }
            computeStyle(r, i, s) {
                return s || ""
            }
            animate(r, i, s, o, a, c = [], l) {
                return new ui(s, o)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    Oy = class Oy {};
Oy.NOOP = new xy;
var as = Oy,
    cs = class {};
var uL = 1e3,
    JC = "{{",
    dL = "}}",
    XC = "ng-enter",
    uy = "ng-leave",
    Md = "ng-trigger",
    Nd = ".ng-trigger",
    VC = "ng-animating",
    dy = ".ng-animating";

function Or(t) {
    if (typeof t == "number") return t;
    let e = t.match(/^(-?[\.\d]+)(m?s)/);
    return !e || e.length < 2 ? 0 : hy(parseFloat(e[1]), e[2])
}

function hy(t, e) {
    switch (e) {
        case "s":
            return t * uL;
        default:
            return t
    }
}

function Rd(t, e, n) {
    return t.hasOwnProperty("duration") ? t : hL(t, e, n)
}

function hL(t, e, n) {
    let r = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i,
        i, s = 0,
        o = "";
    if (typeof t == "string") {
        let a = t.match(r);
        if (a === null) return e.push(kC(t)), {
            duration: 0,
            delay: 0,
            easing: ""
        };
        i = hy(parseFloat(a[1]), a[2]);
        let c = a[3];
        c != null && (s = hy(parseFloat(c), a[4]));
        let l = a[5];
        l && (o = l)
    } else i = t;
    if (!n) {
        let a = !1,
            c = e.length;
        i < 0 && (e.push(xP()), a = !0), s < 0 && (e.push(AP()), a = !0), a && e.splice(c, 0, kC(t))
    }
    return {
        duration: i,
        delay: s,
        easing: o
    }
}

function fL(t) {
    return t.length ? t[0] instanceof Map ? t : t.map(e => new Map(Object.entries(e))) : []
}

function nr(t, e, n) {
    e.forEach((r, i) => {
        let s = Ay(i);
        n && !n.has(i) && n.set(i, t.style[s]), t.style[s] = r
    })
}

function os(t, e) {
    e.forEach((n, r) => {
        let i = Ay(r);
        t.style[i] = ""
    })
}

function Wa(t) {
    return Array.isArray(t) ? t.length == 1 ? t[0] : ry(t) : t
}

function pL(t, e, n) {
    let r = e.params || {},
        i = eS(t);
    i.length && i.forEach(s => {
        r.hasOwnProperty(s) || n.push(NP(s))
    })
}
var fy = new RegExp(`${JC}\\s*(.+?)\\s*${dL}`, "g");

function eS(t) {
    let e = [];
    if (typeof t == "string") {
        let n;
        for (; n = fy.exec(t);) e.push(n[1]);
        fy.lastIndex = 0
    }
    return e
}

function Ga(t, e, n) {
    let r = `${t}`,
        i = r.replace(fy, (s, o) => {
            let a = e[o];
            return a == null && (n.push(RP(o)), a = ""), a.toString()
        });
    return i == r ? t : i
}
var gL = /-+([a-z0-9])/g;

function Ay(t) {
    return t.replace(gL, (...e) => e[1].toUpperCase())
}

function mL(t, e) {
    return t === 0 || e === 0
}

function yL(t, e, n) {
    if (n.size && e.length) {
        let r = e[0],
            i = [];
        if (n.forEach((s, o) => {
                r.has(o) || i.push(o), r.set(o, s)
            }), i.length)
            for (let s = 1; s < e.length; s++) {
                let o = e[s];
                i.forEach(a => o.set(a, Ny(t, a)))
            }
    }
    return e
}

function en(t, e, n) {
    switch (e.type) {
        case ce.Trigger:
            return t.visitTrigger(e, n);
        case ce.State:
            return t.visitState(e, n);
        case ce.Transition:
            return t.visitTransition(e, n);
        case ce.Sequence:
            return t.visitSequence(e, n);
        case ce.Group:
            return t.visitGroup(e, n);
        case ce.Animate:
            return t.visitAnimate(e, n);
        case ce.Keyframes:
            return t.visitKeyframes(e, n);
        case ce.Style:
            return t.visitStyle(e, n);
        case ce.Reference:
            return t.visitReference(e, n);
        case ce.AnimateChild:
            return t.visitAnimateChild(e, n);
        case ce.AnimateRef:
            return t.visitAnimateRef(e, n);
        case ce.Query:
            return t.visitQuery(e, n);
        case ce.Stagger:
            return t.visitStagger(e, n);
        default:
            throw OP(e.type)
    }
}

function Ny(t, e) {
    return window.getComputedStyle(t)[e]
}
var vL = new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]),
    Od = class extends cs {
        normalizePropertyName(e, n) {
            return Ay(e)
        }
        normalizeStyleValue(e, n, r, i) {
            let s = "",
                o = r.toString().trim();
            if (vL.has(n) && r !== 0 && r !== "0")
                if (typeof r == "number") s = "px";
                else {
                    let a = r.match(/^[+-]?[\d\.]+([a-z]*)$/);
                    a && a[1].length == 0 && i.push(FP(e, r))
                }
            return o + s
        }
    };
var Fd = "*";

function wL(t, e) {
    let n = [];
    return typeof t == "string" ? t.split(/\s*,\s*/).forEach(r => _L(r, n, e)) : n.push(t), n
}

function _L(t, e, n) {
    if (t[0] == ":") {
        let c = bL(t, n);
        if (typeof c == "function") {
            e.push(c);
            return
        }
        t = c
    }
    let r = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
    if (r == null || r.length < 4) return n.push(GP(t)), e;
    let i = r[1],
        s = r[2],
        o = r[3];
    e.push(UC(i, o));
    let a = i == Fd && o == Fd;
    s[0] == "<" && !a && e.push(UC(o, i))
}

function bL(t, e) {
    switch (t) {
        case ":enter":
            return "void => *";
        case ":leave":
            return "* => void";
        case ":increment":
            return (n, r) => parseFloat(r) > parseFloat(n);
        case ":decrement":
            return (n, r) => parseFloat(r) < parseFloat(n);
        default:
            return e.push(ZP(t)), "* => *"
    }
}
var Id = new Set(["true", "1"]),
    Td = new Set(["false", "0"]);

function UC(t, e) {
    let n = Id.has(t) || Td.has(t),
        r = Id.has(e) || Td.has(e);
    return (i, s) => {
        let o = t == Fd || t == i,
            a = e == Fd || e == s;
        return !o && n && typeof i == "boolean" && (o = i ? Id.has(t) : Td.has(t)), !a && r && typeof s == "boolean" && (a = s ? Id.has(e) : Td.has(e)), o && a
    }
}
var tS = ":self",
    DL = new RegExp(`s*${tS}s*,?`, "g");

function nS(t, e, n, r) {
    return new py(t).build(e, n, r)
}
var jC = "",
    py = class {
        constructor(e) {
            this._driver = e
        }
        build(e, n, r) {
            let i = new gy(n);
            return this._resetContextStyleTimingState(i), en(this, Wa(e), i)
        }
        _resetContextStyleTimingState(e) {
            e.currentQuerySelector = jC, e.collectedStyles = new Map, e.collectedStyles.set(jC, new Map), e.currentTime = 0
        }
        visitTrigger(e, n) {
            let r = n.queryCount = 0,
                i = n.depCount = 0,
                s = [],
                o = [];
            return e.name.charAt(0) == "@" && n.errors.push(kP()), e.definitions.forEach(a => {
                if (this._resetContextStyleTimingState(n), a.type == ce.State) {
                    let c = a,
                        l = c.name;
                    l.toString().split(/\s*,\s*/).forEach(u => {
                        c.name = u, s.push(this.visitState(c, n))
                    }), c.name = l
                } else if (a.type == ce.Transition) {
                    let c = this.visitTransition(a, n);
                    r += c.queryCount, i += c.depCount, o.push(c)
                } else n.errors.push(PP())
            }), {
                type: ce.Trigger,
                name: e.name,
                states: s,
                transitions: o,
                queryCount: r,
                depCount: i,
                options: null
            }
        }
        visitState(e, n) {
            let r = this.visitStyle(e.styles, n),
                i = e.options && e.options.params || null;
            if (r.containsDynamicStyles) {
                let s = new Set,
                    o = i || {};
                r.styles.forEach(a => {
                    a instanceof Map && a.forEach(c => {
                        eS(c).forEach(l => {
                            o.hasOwnProperty(l) || s.add(l)
                        })
                    })
                }), s.size && n.errors.push(LP(e.name, [...s.values()]))
            }
            return {
                type: ce.State,
                name: e.name,
                style: r,
                options: i ? {
                    params: i
                } : null
            }
        }
        visitTransition(e, n) {
            n.queryCount = 0, n.depCount = 0;
            let r = en(this, Wa(e.animation), n),
                i = wL(e.expr, n.errors);
            return {
                type: ce.Transition,
                matchers: i,
                animation: r,
                queryCount: n.queryCount,
                depCount: n.depCount,
                options: ss(e.options)
            }
        }
        visitSequence(e, n) {
            return {
                type: ce.Sequence,
                steps: e.steps.map(r => en(this, r, n)),
                options: ss(e.options)
            }
        }
        visitGroup(e, n) {
            let r = n.currentTime,
                i = 0,
                s = e.steps.map(o => {
                    n.currentTime = r;
                    let a = en(this, o, n);
                    return i = Math.max(i, n.currentTime), a
                });
            return n.currentTime = i, {
                type: ce.Group,
                steps: s,
                options: ss(e.options)
            }
        }
        visitAnimate(e, n) {
            let r = ML(e.timings, n.errors);
            n.currentAnimateTimings = r;
            let i, s = e.styles ? e.styles : Co({});
            if (s.type == ce.Keyframes) i = this.visitKeyframes(s, n);
            else {
                let o = e.styles,
                    a = !1;
                if (!o) {
                    a = !0;
                    let l = {};
                    r.easing && (l.easing = r.easing), o = Co(l)
                }
                n.currentTime += r.duration + r.delay;
                let c = this.visitStyle(o, n);
                c.isEmptyStep = a, i = c
            }
            return n.currentAnimateTimings = null, {
                type: ce.Animate,
                timings: r,
                style: i,
                options: null
            }
        }
        visitStyle(e, n) {
            let r = this._makeStyleAst(e, n);
            return this._validateStyleAst(r, n), r
        }
        _makeStyleAst(e, n) {
            let r = [],
                i = Array.isArray(e.styles) ? e.styles : [e.styles];
            for (let a of i) typeof a == "string" ? a === tr ? r.push(a) : n.errors.push(VP(a)) : r.push(new Map(Object.entries(a)));
            let s = !1,
                o = null;
            return r.forEach(a => {
                if (a instanceof Map && (a.has("easing") && (o = a.get("easing"), a.delete("easing")), !s)) {
                    for (let c of a.values())
                        if (c.toString().indexOf(JC) >= 0) {
                            s = !0;
                            break
                        }
                }
            }), {
                type: ce.Style,
                styles: r,
                easing: o,
                offset: e.offset,
                containsDynamicStyles: s,
                options: null
            }
        }
        _validateStyleAst(e, n) {
            let r = n.currentAnimateTimings,
                i = n.currentTime,
                s = n.currentTime;
            r && s > 0 && (s -= r.duration + r.delay), e.styles.forEach(o => {
                typeof o != "string" && o.forEach((a, c) => {
                    let l = n.collectedStyles.get(n.currentQuerySelector),
                        u = l.get(c),
                        d = !0;
                    u && (s != i && s >= u.startTime && i <= u.endTime && (n.errors.push(UP(c, u.startTime, u.endTime, s, i)), d = !1), s = u.startTime), d && l.set(c, {
                        startTime: s,
                        endTime: i
                    }), n.options && pL(a, n.options, n.errors)
                })
            })
        }
        visitKeyframes(e, n) {
            let r = {
                type: ce.Keyframes,
                styles: [],
                options: null
            };
            if (!n.currentAnimateTimings) return n.errors.push(jP()), r;
            let i = 1,
                s = 0,
                o = [],
                a = !1,
                c = !1,
                l = 0,
                u = e.steps.map(y => {
                    let E = this._makeStyleAst(y, n),
                        T = E.offset != null ? E.offset : SL(E.styles),
                        w = 0;
                    return T != null && (s++, w = E.offset = T), c = c || w < 0 || w > 1, a = a || w < l, l = w, o.push(w), E
                });
            c && n.errors.push(BP()), a && n.errors.push(zP());
            let d = e.steps.length,
                h = 0;
            s > 0 && s < d ? n.errors.push($P()) : s == 0 && (h = i / (d - 1));
            let f = d - 1,
                p = n.currentTime,
                g = n.currentAnimateTimings,
                m = g.duration;
            return u.forEach((y, E) => {
                let T = h > 0 ? E == f ? 1 : h * E : o[E],
                    w = T * m;
                n.currentTime = p + g.delay + w, g.duration = w, this._validateStyleAst(y, n), y.offset = T, r.styles.push(y)
            }), r
        }
        visitReference(e, n) {
            return {
                type: ce.Reference,
                animation: en(this, Wa(e.animation), n),
                options: ss(e.options)
            }
        }
        visitAnimateChild(e, n) {
            return n.depCount++, {
                type: ce.AnimateChild,
                options: ss(e.options)
            }
        }
        visitAnimateRef(e, n) {
            return {
                type: ce.AnimateRef,
                animation: this.visitReference(e.animation, n),
                options: ss(e.options)
            }
        }
        visitQuery(e, n) {
            let r = n.currentQuerySelector,
                i = e.options || {};
            n.queryCount++, n.currentQuery = e;
            let [s, o] = EL(e.selector);
            n.currentQuerySelector = r.length ? r + " " + s : s, tn(n.collectedStyles, n.currentQuerySelector, new Map);
            let a = en(this, Wa(e.animation), n);
            return n.currentQuery = null, n.currentQuerySelector = r, {
                type: ce.Query,
                selector: s,
                limit: i.limit || 0,
                optional: !!i.optional,
                includeSelf: o,
                animation: a,
                originalSelector: e.selector,
                options: ss(e.options)
            }
        }
        visitStagger(e, n) {
            n.currentQuery || n.errors.push(WP());
            let r = e.timings === "full" ? {
                duration: 0,
                delay: 0,
                easing: "full"
            } : Rd(e.timings, n.errors, !0);
            return {
                type: ce.Stagger,
                animation: en(this, Wa(e.animation), n),
                timings: r,
                options: null
            }
        }
    };

function EL(t) {
    let e = !!t.split(/\s*,\s*/).find(n => n == tS);
    return e && (t = t.replace(DL, "")), t = t.replace(/@\*/g, Nd).replace(/@\w+/g, n => Nd + "-" + n.slice(1)).replace(/:animating/g, dy), [t, e]
}

function CL(t) {
    return t ? _({}, t) : null
}
var gy = class {
    constructor(e) {
        this.errors = e, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = new Map, this.options = null, this.unsupportedCSSPropertiesFound = new Set
    }
};

function SL(t) {
    if (typeof t == "string") return null;
    let e = null;
    if (Array.isArray(t)) t.forEach(n => {
        if (n instanceof Map && n.has("offset")) {
            let r = n;
            e = parseFloat(r.get("offset")), r.delete("offset")
        }
    });
    else if (t instanceof Map && t.has("offset")) {
        let n = t;
        e = parseFloat(n.get("offset")), n.delete("offset")
    }
    return e
}

function ML(t, e) {
    if (t.hasOwnProperty("duration")) return t;
    if (typeof t == "number") {
        let s = Rd(t, e).duration;
        return sy(s, 0, "")
    }
    let n = t;
    if (n.split(/\s+/).some(s => s.charAt(0) == "{" && s.charAt(1) == "{")) {
        let s = sy(0, 0, "");
        return s.dynamic = !0, s.strValue = n, s
    }
    let i = Rd(n, e);
    return sy(i.duration, i.delay, i.easing)
}

function ss(t) {
    return t ? (t = _({}, t), t.params && (t.params = CL(t.params))) : t = {}, t
}

function sy(t, e, n) {
    return {
        duration: t,
        delay: e,
        easing: n
    }
}

function Ry(t, e, n, r, i, s, o = null, a = !1) {
    return {
        type: 1,
        element: t,
        keyframes: e,
        preStyleProps: n,
        postStyleProps: r,
        duration: i,
        delay: s,
        totalTime: i + s,
        easing: o,
        subTimeline: a
    }
}
var Za = class {
        constructor() {
            this._map = new Map
        }
        get(e) {
            return this._map.get(e) || []
        }
        append(e, n) {
            let r = this._map.get(e);
            r || this._map.set(e, r = []), r.push(...n)
        }
        has(e) {
            return this._map.has(e)
        }
        clear() {
            this._map.clear()
        }
    },
    IL = 1,
    TL = ":enter",
    xL = new RegExp(TL, "g"),
    AL = ":leave",
    NL = new RegExp(AL, "g");

function rS(t, e, n, r, i, s = new Map, o = new Map, a, c, l = []) {
    return new my().buildKeyframes(t, e, n, r, i, s, o, a, c, l)
}
var my = class {
        buildKeyframes(e, n, r, i, s, o, a, c, l, u = []) {
            l = l || new Za;
            let d = new yy(e, n, l, i, s, u, []);
            d.options = c;
            let h = c.delay ? Or(c.delay) : 0;
            d.currentTimeline.delayNextStep(h), d.currentTimeline.setStyles([o], null, d.errors, c), en(this, r, d);
            let f = d.timelines.filter(p => p.containsAnimation());
            if (f.length && a.size) {
                let p;
                for (let g = f.length - 1; g >= 0; g--) {
                    let m = f[g];
                    if (m.element === n) {
                        p = m;
                        break
                    }
                }
                p && !p.allowOnlyTimelineStyles() && p.setStyles([a], null, d.errors, c)
            }
            return f.length ? f.map(p => p.buildKeyframes()) : [Ry(n, [], [], [], 0, h, "", !1)]
        }
        visitTrigger(e, n) {}
        visitState(e, n) {}
        visitTransition(e, n) {}
        visitAnimateChild(e, n) {
            let r = n.subInstructions.get(n.element);
            if (r) {
                let i = n.createSubContext(e.options),
                    s = n.currentTimeline.currentTime,
                    o = this._visitSubInstructions(r, i, i.options);
                s != o && n.transformIntoNewTimeline(o)
            }
            n.previousNode = e
        }
        visitAnimateRef(e, n) {
            let r = n.createSubContext(e.options);
            r.transformIntoNewTimeline(), this._applyAnimationRefDelays([e.options, e.animation.options], n, r), this.visitReference(e.animation, r), n.transformIntoNewTimeline(r.currentTimeline.currentTime), n.previousNode = e
        }
        _applyAnimationRefDelays(e, n, r) {
            for (let i of e) {
                let s = i ? .delay;
                if (s) {
                    let o = typeof s == "number" ? s : Or(Ga(s, i ? .params ? ? {}, n.errors));
                    r.delayNextStep(o)
                }
            }
        }
        _visitSubInstructions(e, n, r) {
            let s = n.currentTimeline.currentTime,
                o = r.duration != null ? Or(r.duration) : null,
                a = r.delay != null ? Or(r.delay) : null;
            return o !== 0 && e.forEach(c => {
                let l = n.appendInstructionToTimeline(c, o, a);
                s = Math.max(s, l.duration + l.delay)
            }), s
        }
        visitReference(e, n) {
            n.updateOptions(e.options, !0), en(this, e.animation, n), n.previousNode = e
        }
        visitSequence(e, n) {
            let r = n.subContextCount,
                i = n,
                s = e.options;
            if (s && (s.params || s.delay) && (i = n.createSubContext(s), i.transformIntoNewTimeline(), s.delay != null)) {
                i.previousNode.type == ce.Style && (i.currentTimeline.snapshotCurrentStyles(), i.previousNode = kd);
                let o = Or(s.delay);
                i.delayNextStep(o)
            }
            e.steps.length && (e.steps.forEach(o => en(this, o, i)), i.currentTimeline.applyStylesToKeyframe(), i.subContextCount > r && i.transformIntoNewTimeline()), n.previousNode = e
        }
        visitGroup(e, n) {
            let r = [],
                i = n.currentTimeline.currentTime,
                s = e.options && e.options.delay ? Or(e.options.delay) : 0;
            e.steps.forEach(o => {
                let a = n.createSubContext(e.options);
                s && a.delayNextStep(s), en(this, o, a), i = Math.max(i, a.currentTimeline.currentTime), r.push(a.currentTimeline)
            }), r.forEach(o => n.currentTimeline.mergeTimelineCollectedStyles(o)), n.transformIntoNewTimeline(i), n.previousNode = e
        }
        _visitTiming(e, n) {
            if (e.dynamic) {
                let r = e.strValue,
                    i = n.params ? Ga(r, n.params, n.errors) : r;
                return Rd(i, n.errors)
            } else return {
                duration: e.duration,
                delay: e.delay,
                easing: e.easing
            }
        }
        visitAnimate(e, n) {
            let r = n.currentAnimateTimings = this._visitTiming(e.timings, n),
                i = n.currentTimeline;
            r.delay && (n.incrementTime(r.delay), i.snapshotCurrentStyles());
            let s = e.style;
            s.type == ce.Keyframes ? this.visitKeyframes(s, n) : (n.incrementTime(r.duration), this.visitStyle(s, n), i.applyStylesToKeyframe()), n.currentAnimateTimings = null, n.previousNode = e
        }
        visitStyle(e, n) {
            let r = n.currentTimeline,
                i = n.currentAnimateTimings;
            !i && r.hasCurrentStyleProperties() && r.forwardFrame();
            let s = i && i.easing || e.easing;
            e.isEmptyStep ? r.applyEmptyStep(s) : r.setStyles(e.styles, s, n.errors, n.options), n.previousNode = e
        }
        visitKeyframes(e, n) {
            let r = n.currentAnimateTimings,
                i = n.currentTimeline.duration,
                s = r.duration,
                a = n.createSubContext().currentTimeline;
            a.easing = r.easing, e.styles.forEach(c => {
                let l = c.offset || 0;
                a.forwardTime(l * s), a.setStyles(c.styles, c.easing, n.errors, n.options), a.applyStylesToKeyframe()
            }), n.currentTimeline.mergeTimelineCollectedStyles(a), n.transformIntoNewTimeline(i + s), n.previousNode = e
        }
        visitQuery(e, n) {
            let r = n.currentTimeline.currentTime,
                i = e.options || {},
                s = i.delay ? Or(i.delay) : 0;
            s && (n.previousNode.type === ce.Style || r == 0 && n.currentTimeline.hasCurrentStyleProperties()) && (n.currentTimeline.snapshotCurrentStyles(), n.previousNode = kd);
            let o = r,
                a = n.invokeQuery(e.selector, e.originalSelector, e.limit, e.includeSelf, !!i.optional, n.errors);
            n.currentQueryTotal = a.length;
            let c = null;
            a.forEach((l, u) => {
                n.currentQueryIndex = u;
                let d = n.createSubContext(e.options, l);
                s && d.delayNextStep(s), l === n.element && (c = d.currentTimeline), en(this, e.animation, d), d.currentTimeline.applyStylesToKeyframe();
                let h = d.currentTimeline.currentTime;
                o = Math.max(o, h)
            }), n.currentQueryIndex = 0, n.currentQueryTotal = 0, n.transformIntoNewTimeline(o), c && (n.currentTimeline.mergeTimelineCollectedStyles(c), n.currentTimeline.snapshotCurrentStyles()), n.previousNode = e
        }
        visitStagger(e, n) {
            let r = n.parentContext,
                i = n.currentTimeline,
                s = e.timings,
                o = Math.abs(s.duration),
                a = o * (n.currentQueryTotal - 1),
                c = o * n.currentQueryIndex;
            switch (s.duration < 0 ? "reverse" : s.easing) {
                case "reverse":
                    c = a - c;
                    break;
                case "full":
                    c = r.currentStaggerTime;
                    break
            }
            let u = n.currentTimeline;
            c && u.delayNextStep(c);
            let d = u.currentTime;
            en(this, e.animation, n), n.previousNode = e, r.currentStaggerTime = i.currentTime - d + (i.startTime - r.currentTimeline.startTime)
        }
    },
    kd = {},
    yy = class t {
        constructor(e, n, r, i, s, o, a, c) {
            this._driver = e, this.element = n, this.subInstructions = r, this._enterClassName = i, this._leaveClassName = s, this.errors = o, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = kd, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = c || new Pd(this._driver, n, 0), a.push(this.currentTimeline)
        }
        get params() {
            return this.options.params
        }
        updateOptions(e, n) {
            if (!e) return;
            let r = e,
                i = this.options;
            r.duration != null && (i.duration = Or(r.duration)), r.delay != null && (i.delay = Or(r.delay));
            let s = r.params;
            if (s) {
                let o = i.params;
                o || (o = this.options.params = {}), Object.keys(s).forEach(a => {
                    (!n || !o.hasOwnProperty(a)) && (o[a] = Ga(s[a], o, this.errors))
                })
            }
        }
        _copyOptions() {
            let e = {};
            if (this.options) {
                let n = this.options.params;
                if (n) {
                    let r = e.params = {};
                    Object.keys(n).forEach(i => {
                        r[i] = n[i]
                    })
                }
            }
            return e
        }
        createSubContext(e = null, n, r) {
            let i = n || this.element,
                s = new t(this._driver, i, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(i, r || 0));
            return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(e), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s
        }
        transformIntoNewTimeline(e) {
            return this.previousNode = kd, this.currentTimeline = this.currentTimeline.fork(this.element, e), this.timelines.push(this.currentTimeline), this.currentTimeline
        }
        appendInstructionToTimeline(e, n, r) {
            let i = {
                    duration: n ? ? e.duration,
                    delay: this.currentTimeline.currentTime + (r ? ? 0) + e.delay,
                    easing: ""
                },
                s = new vy(this._driver, e.element, e.keyframes, e.preStyleProps, e.postStyleProps, i, e.stretchStartingKeyframe);
            return this.timelines.push(s), i
        }
        incrementTime(e) {
            this.currentTimeline.forwardTime(this.currentTimeline.duration + e)
        }
        delayNextStep(e) {
            e > 0 && this.currentTimeline.delayNextStep(e)
        }
        invokeQuery(e, n, r, i, s, o) {
            let a = [];
            if (i && a.push(this.element), e.length > 0) {
                e = e.replace(xL, "." + this._enterClassName), e = e.replace(NL, "." + this._leaveClassName);
                let c = r != 1,
                    l = this._driver.query(this.element, e, c);
                r !== 0 && (l = r < 0 ? l.slice(l.length + r, l.length) : l.slice(0, r)), a.push(...l)
            }
            return !s && a.length == 0 && o.push(HP(n)), a
        }
    },
    Pd = class t {
        constructor(e, n, r, i) {
            this._driver = e, this.element = n, this.startTime = r, this._elementTimelineStylesLookup = i, this.duration = 0, this.easing = null, this._previousKeyframe = new Map, this._currentKeyframe = new Map, this._keyframes = new Map, this._styleSummary = new Map, this._localTimelineStyles = new Map, this._pendingStyles = new Map, this._backFill = new Map, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(n), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(n, this._localTimelineStyles)), this._loadKeyframe()
        }
        containsAnimation() {
            switch (this._keyframes.size) {
                case 0:
                    return !1;
                case 1:
                    return this.hasCurrentStyleProperties();
                default:
                    return !0
            }
        }
        hasCurrentStyleProperties() {
            return this._currentKeyframe.size > 0
        }
        get currentTime() {
            return this.startTime + this.duration
        }
        delayNextStep(e) {
            let n = this._keyframes.size === 1 && this._pendingStyles.size;
            this.duration || n ? (this.forwardTime(this.currentTime + e), n && this.snapshotCurrentStyles()) : this.startTime += e
        }
        fork(e, n) {
            return this.applyStylesToKeyframe(), new t(this._driver, e, n || this.currentTime, this._elementTimelineStylesLookup)
        }
        _loadKeyframe() {
            this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = new Map, this._keyframes.set(this.duration, this._currentKeyframe))
        }
        forwardFrame() {
            this.duration += IL, this._loadKeyframe()
        }
        forwardTime(e) {
            this.applyStylesToKeyframe(), this.duration = e, this._loadKeyframe()
        }
        _updateStyle(e, n) {
            this._localTimelineStyles.set(e, n), this._globalTimelineStyles.set(e, n), this._styleSummary.set(e, {
                time: this.currentTime,
                value: n
            })
        }
        allowOnlyTimelineStyles() {
            return this._currentEmptyStepKeyframe !== this._currentKeyframe
        }
        applyEmptyStep(e) {
            e && this._previousKeyframe.set("easing", e);
            for (let [n, r] of this._globalTimelineStyles) this._backFill.set(n, r || tr), this._currentKeyframe.set(n, tr);
            this._currentEmptyStepKeyframe = this._currentKeyframe
        }
        setStyles(e, n, r, i) {
            n && this._previousKeyframe.set("easing", n);
            let s = i && i.params || {},
                o = RL(e, this._globalTimelineStyles);
            for (let [a, c] of o) {
                let l = Ga(c, s, r);
                this._pendingStyles.set(a, l), this._localTimelineStyles.has(a) || this._backFill.set(a, this._globalTimelineStyles.get(a) ? ? tr), this._updateStyle(a, l)
            }
        }
        applyStylesToKeyframe() {
            this._pendingStyles.size != 0 && (this._pendingStyles.forEach((e, n) => {
                this._currentKeyframe.set(n, e)
            }), this._pendingStyles.clear(), this._localTimelineStyles.forEach((e, n) => {
                this._currentKeyframe.has(n) || this._currentKeyframe.set(n, e)
            }))
        }
        snapshotCurrentStyles() {
            for (let [e, n] of this._localTimelineStyles) this._pendingStyles.set(e, n), this._updateStyle(e, n)
        }
        getFinalKeyframe() {
            return this._keyframes.get(this.duration)
        }
        get properties() {
            let e = [];
            for (let n in this._currentKeyframe) e.push(n);
            return e
        }
        mergeTimelineCollectedStyles(e) {
            e._styleSummary.forEach((n, r) => {
                let i = this._styleSummary.get(r);
                (!i || n.time > i.time) && this._updateStyle(r, n.value)
            })
        }
        buildKeyframes() {
            this.applyStylesToKeyframe();
            let e = new Set,
                n = new Set,
                r = this._keyframes.size === 1 && this.duration === 0,
                i = [];
            this._keyframes.forEach((a, c) => {
                let l = new Map([...this._backFill, ...a]);
                l.forEach((u, d) => {
                    u === Sd ? e.add(d) : u === tr && n.add(d)
                }), r || l.set("offset", c / this.duration), i.push(l)
            });
            let s = [...e.values()],
                o = [...n.values()];
            if (r) {
                let a = i[0],
                    c = new Map(a);
                a.set("offset", 0), c.set("offset", 1), i = [a, c]
            }
            return Ry(this.element, i, s, o, this.duration, this.startTime, this.easing, !1)
        }
    },
    vy = class extends Pd {
        constructor(e, n, r, i, s, o, a = !1) {
            super(e, n, o.delay), this.keyframes = r, this.preStyleProps = i, this.postStyleProps = s, this._stretchStartingKeyframe = a, this.timings = {
                duration: o.duration,
                delay: o.delay,
                easing: o.easing
            }
        }
        containsAnimation() {
            return this.keyframes.length > 1
        }
        buildKeyframes() {
            let e = this.keyframes,
                {
                    delay: n,
                    duration: r,
                    easing: i
                } = this.timings;
            if (this._stretchStartingKeyframe && n) {
                let s = [],
                    o = r + n,
                    a = n / o,
                    c = new Map(e[0]);
                c.set("offset", 0), s.push(c);
                let l = new Map(e[0]);
                l.set("offset", BC(a)), s.push(l);
                let u = e.length - 1;
                for (let d = 1; d <= u; d++) {
                    let h = new Map(e[d]),
                        f = h.get("offset"),
                        p = n + f * r;
                    h.set("offset", BC(p / o)), s.push(h)
                }
                r = o, n = 0, i = "", e = s
            }
            return Ry(this.element, e, this.preStyleProps, this.postStyleProps, r, n, i, !0)
        }
    };

function BC(t, e = 3) {
    let n = Math.pow(10, e - 1);
    return Math.round(t * n) / n
}

function RL(t, e) {
    let n = new Map,
        r;
    return t.forEach(i => {
        if (i === "*") {
            r ? ? = e.keys();
            for (let s of r) n.set(s, tr)
        } else
            for (let [s, o] of i) n.set(s, o)
    }), n
}

function zC(t, e, n, r, i, s, o, a, c, l, u, d, h) {
    return {
        type: 0,
        element: t,
        triggerName: e,
        isRemovalTransition: i,
        fromState: n,
        fromStyles: s,
        toState: r,
        toStyles: o,
        timelines: a,
        queriedElements: c,
        preStyleProps: l,
        postStyleProps: u,
        totalTime: d,
        errors: h
    }
}
var oy = {},
    Ld = class {
        constructor(e, n, r) {
            this._triggerName = e, this.ast = n, this._stateStyles = r
        }
        match(e, n, r, i) {
            return OL(this.ast.matchers, e, n, r, i)
        }
        buildStyles(e, n, r) {
            let i = this._stateStyles.get("*");
            return e !== void 0 && (i = this._stateStyles.get(e ? .toString()) || i), i ? i.buildStyles(n, r) : new Map
        }
        build(e, n, r, i, s, o, a, c, l, u) {
            let d = [],
                h = this.ast.options && this.ast.options.params || oy,
                f = a && a.params || oy,
                p = this.buildStyles(r, f, d),
                g = c && c.params || oy,
                m = this.buildStyles(i, g, d),
                y = new Set,
                E = new Map,
                T = new Map,
                w = i === "void",
                N = {
                    params: iS(g, h),
                    delay: this.ast.options ? .delay
                },
                L = u ? [] : rS(e, n, this.ast.animation, s, o, p, m, N, l, d),
                D = 0;
            return L.forEach(j => {
                D = Math.max(j.duration + j.delay, D)
            }), d.length ? zC(n, this._triggerName, r, i, w, p, m, [], [], E, T, D, d) : (L.forEach(j => {
                let Y = j.element,
                    H = tn(E, Y, new Set);
                j.preStyleProps.forEach(Ue => H.add(Ue));
                let G = tn(T, Y, new Set);
                j.postStyleProps.forEach(Ue => G.add(Ue)), Y !== n && y.add(Y)
            }), zC(n, this._triggerName, r, i, w, p, m, L, [...y.values()], E, T, D))
        }
    };

function OL(t, e, n, r, i) {
    return t.some(s => s(e, n, r, i))
}

function iS(t, e) {
    let n = _({}, e);
    return Object.entries(t).forEach(([r, i]) => {
        i != null && (n[r] = i)
    }), n
}
var wy = class {
    constructor(e, n, r) {
        this.styles = e, this.defaultParams = n, this.normalizer = r
    }
    buildStyles(e, n) {
        let r = new Map,
            i = iS(e, this.defaultParams);
        return this.styles.styles.forEach(s => {
            typeof s != "string" && s.forEach((o, a) => {
                o && (o = Ga(o, i, n));
                let c = this.normalizer.normalizePropertyName(a, n);
                o = this.normalizer.normalizeStyleValue(a, c, o, n), r.set(a, o)
            })
        }), r
    }
};

function FL(t, e, n) {
    return new _y(t, e, n)
}
var _y = class {
    constructor(e, n, r) {
        this.name = e, this.ast = n, this._normalizer = r, this.transitionFactories = [], this.states = new Map, n.states.forEach(i => {
            let s = i.options && i.options.params || {};
            this.states.set(i.name, new wy(i.style, s, r))
        }), $C(this.states, "true", "1"), $C(this.states, "false", "0"), n.transitions.forEach(i => {
            this.transitionFactories.push(new Ld(e, i, this.states))
        }), this.fallbackTransition = kL(e, this.states, this._normalizer)
    }
    get containsQueries() {
        return this.ast.queryCount > 0
    }
    matchTransition(e, n, r, i) {
        return this.transitionFactories.find(o => o.match(e, n, r, i)) || null
    }
    matchStyles(e, n, r) {
        return this.fallbackTransition.buildStyles(e, n, r)
    }
};

function kL(t, e, n) {
    let r = [(o, a) => !0],
        i = {
            type: ce.Sequence,
            steps: [],
            options: null
        },
        s = {
            type: ce.Transition,
            animation: i,
            matchers: r,
            options: null,
            queryCount: 0,
            depCount: 0
        };
    return new Ld(t, s, e)
}

function $C(t, e, n) {
    t.has(e) ? t.has(n) || t.set(n, t.get(e)) : t.has(n) && t.set(e, t.get(n))
}
var PL = new Za,
    by = class {
        constructor(e, n, r) {
            this.bodyNode = e, this._driver = n, this._normalizer = r, this._animations = new Map, this._playersById = new Map, this.players = []
        }
        register(e, n) {
            let r = [],
                i = [],
                s = nS(this._driver, n, r, i);
            if (r.length) throw KP(r);
            i.length && void 0, this._animations.set(e, s)
        }
        _buildPlayer(e, n, r) {
            let i = e.element,
                s = qC(this._normalizer, e.keyframes, n, r);
            return this._driver.animate(i, s, e.duration, e.delay, e.easing, [], !0)
        }
        create(e, n, r = {}) {
            let i = [],
                s = this._animations.get(e),
                o, a = new Map;
            if (s ? (o = rS(this._driver, n, s, XC, uy, new Map, new Map, r, PL, i), o.forEach(u => {
                    let d = tn(a, u.element, new Map);
                    u.postStyleProps.forEach(h => d.set(h, null))
                })) : (i.push(YP()), o = []), i.length) throw JP(i);
            a.forEach((u, d) => {
                u.forEach((h, f) => {
                    u.set(f, this._driver.computeStyle(d, f, tr))
                })
            });
            let c = o.map(u => {
                    let d = a.get(u.element);
                    return this._buildPlayer(u, new Map, d)
                }),
                l = di(c);
            return this._playersById.set(e, l), l.onDestroy(() => this.destroy(e)), this.players.push(l), l
        }
        destroy(e) {
            let n = this._getPlayer(e);
            n.destroy(), this._playersById.delete(e);
            let r = this.players.indexOf(n);
            r >= 0 && this.players.splice(r, 1)
        }
        _getPlayer(e) {
            let n = this._playersById.get(e);
            if (!n) throw XP(e);
            return n
        }
        listen(e, n, r, i) {
            let s = Iy(n, "", "", "");
            return My(this._getPlayer(e), r, s, i), () => {}
        }
        command(e, n, r, i) {
            if (r == "register") {
                this.register(e, i[0]);
                return
            }
            if (r == "create") {
                let o = i[0] || {};
                this.create(e, n, o);
                return
            }
            let s = this._getPlayer(e);
            switch (r) {
                case "play":
                    s.play();
                    break;
                case "pause":
                    s.pause();
                    break;
                case "reset":
                    s.reset();
                    break;
                case "restart":
                    s.restart();
                    break;
                case "finish":
                    s.finish();
                    break;
                case "init":
                    s.init();
                    break;
                case "setPosition":
                    s.setPosition(parseFloat(i[0]));
                    break;
                case "destroy":
                    this.destroy(e);
                    break
            }
        }
    },
    WC = "ng-animate-queued",
    LL = ".ng-animate-queued",
    ay = "ng-animate-disabled",
    VL = ".ng-animate-disabled",
    UL = "ng-star-inserted",
    jL = ".ng-star-inserted",
    BL = [],
    sS = {
        namespaceId: "",
        setForRemoval: !1,
        setForMove: !1,
        hasAnimation: !1,
        removedBeforeQueried: !1
    },
    zL = {
        namespaceId: "",
        setForMove: !1,
        setForRemoval: !1,
        hasAnimation: !1,
        removedBeforeQueried: !0
    },
    Bn = "__ng_removed",
    Qa = class {
        get params() {
            return this.options.params
        }
        constructor(e, n = "") {
            this.namespaceId = n;
            let r = e && e.hasOwnProperty("value"),
                i = r ? e.value : e;
            if (this.value = WL(i), r) {
                let s = e,
                    {
                        value: o
                    } = s,
                    a = Tn(s, ["value"]);
                this.options = a
            } else this.options = {};
            this.options.params || (this.options.params = {})
        }
        absorbOptions(e) {
            let n = e.params;
            if (n) {
                let r = this.options.params;
                Object.keys(n).forEach(i => {
                    r[i] == null && (r[i] = n[i])
                })
            }
        }
    },
    Ha = "void",
    cy = new Qa(Ha),
    Dy = class {
        constructor(e, n, r) {
            this.id = e, this.hostElement = n, this._engine = r, this.players = [], this._triggers = new Map, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + e, _n(n, this._hostClassName)
        }
        listen(e, n, r, i) {
            if (!this._triggers.has(n)) throw eL(r, n);
            if (r == null || r.length == 0) throw tL(n);
            if (!HL(r)) throw nL(r, n);
            let s = tn(this._elementListeners, e, []),
                o = {
                    name: n,
                    phase: r,
                    callback: i
                };
            s.push(o);
            let a = tn(this._engine.statesByElement, e, new Map);
            return a.has(n) || (_n(e, Md), _n(e, Md + "-" + n), a.set(n, cy)), () => {
                this._engine.afterFlush(() => {
                    let c = s.indexOf(o);
                    c >= 0 && s.splice(c, 1), this._triggers.has(n) || a.delete(n)
                })
            }
        }
        register(e, n) {
            return this._triggers.has(e) ? !1 : (this._triggers.set(e, n), !0)
        }
        _getTrigger(e) {
            let n = this._triggers.get(e);
            if (!n) throw rL(e);
            return n
        }
        trigger(e, n, r, i = !0) {
            let s = this._getTrigger(n),
                o = new qa(this.id, n, e),
                a = this._engine.statesByElement.get(e);
            a || (_n(e, Md), _n(e, Md + "-" + n), this._engine.statesByElement.set(e, a = new Map));
            let c = a.get(n),
                l = new Qa(r, this.id);
            if (!(r && r.hasOwnProperty("value")) && c && l.absorbOptions(c.options), a.set(n, l), c || (c = cy), !(l.value === Ha) && c.value === l.value) {
                if (!QL(c.params, l.params)) {
                    let g = [],
                        m = s.matchStyles(c.value, c.params, g),
                        y = s.matchStyles(l.value, l.params, g);
                    g.length ? this._engine.reportError(g) : this._engine.afterFlush(() => {
                        os(e, m), nr(e, y)
                    })
                }
                return
            }
            let h = tn(this._engine.playersByElement, e, []);
            h.forEach(g => {
                g.namespaceId == this.id && g.triggerName == n && g.queued && g.destroy()
            });
            let f = s.matchTransition(c.value, l.value, e, l.params),
                p = !1;
            if (!f) {
                if (!i) return;
                f = s.fallbackTransition, p = !0
            }
            return this._engine.totalQueuedPlayers++, this._queue.push({
                element: e,
                triggerName: n,
                transition: f,
                fromState: c,
                toState: l,
                player: o,
                isFallbackTransition: p
            }), p || (_n(e, WC), o.onStart(() => {
                So(e, WC)
            })), o.onDone(() => {
                let g = this.players.indexOf(o);
                g >= 0 && this.players.splice(g, 1);
                let m = this._engine.playersByElement.get(e);
                if (m) {
                    let y = m.indexOf(o);
                    y >= 0 && m.splice(y, 1)
                }
            }), this.players.push(o), h.push(o), o
        }
        deregister(e) {
            this._triggers.delete(e), this._engine.statesByElement.forEach(n => n.delete(e)), this._elementListeners.forEach((n, r) => {
                this._elementListeners.set(r, n.filter(i => i.name != e))
            })
        }
        clearElementCache(e) {
            this._engine.statesByElement.delete(e), this._elementListeners.delete(e);
            let n = this._engine.playersByElement.get(e);
            n && (n.forEach(r => r.destroy()), this._engine.playersByElement.delete(e))
        }
        _signalRemovalForInnerTriggers(e, n) {
            let r = this._engine.driver.query(e, Nd, !0);
            r.forEach(i => {
                if (i[Bn]) return;
                let s = this._engine.fetchNamespacesByElement(i);
                s.size ? s.forEach(o => o.triggerLeaveAnimation(i, n, !1, !0)) : this.clearElementCache(i)
            }), this._engine.afterFlushAnimationsDone(() => r.forEach(i => this.clearElementCache(i)))
        }
        triggerLeaveAnimation(e, n, r, i) {
            let s = this._engine.statesByElement.get(e),
                o = new Map;
            if (s) {
                let a = [];
                if (s.forEach((c, l) => {
                        if (o.set(l, c.value), this._triggers.has(l)) {
                            let u = this.trigger(e, l, Ha, i);
                            u && a.push(u)
                        }
                    }), a.length) return this._engine.markElementAsRemoved(this.id, e, !0, n, o), r && di(a).onDone(() => this._engine.processLeaveNode(e)), !0
            }
            return !1
        }
        prepareLeaveAnimationListeners(e) {
            let n = this._elementListeners.get(e),
                r = this._engine.statesByElement.get(e);
            if (n && r) {
                let i = new Set;
                n.forEach(s => {
                    let o = s.name;
                    if (i.has(o)) return;
                    i.add(o);
                    let c = this._triggers.get(o).fallbackTransition,
                        l = r.get(o) || cy,
                        u = new Qa(Ha),
                        d = new qa(this.id, o, e);
                    this._engine.totalQueuedPlayers++, this._queue.push({
                        element: e,
                        triggerName: o,
                        transition: c,
                        fromState: l,
                        toState: u,
                        player: d,
                        isFallbackTransition: !0
                    })
                })
            }
        }
        removeNode(e, n) {
            let r = this._engine;
            if (e.childElementCount && this._signalRemovalForInnerTriggers(e, n), this.triggerLeaveAnimation(e, n, !0)) return;
            let i = !1;
            if (r.totalAnimations) {
                let s = r.players.length ? r.playersByQueriedElement.get(e) : [];
                if (s && s.length) i = !0;
                else {
                    let o = e;
                    for (; o = o.parentNode;)
                        if (r.statesByElement.get(o)) {
                            i = !0;
                            break
                        }
                }
            }
            if (this.prepareLeaveAnimationListeners(e), i) r.markElementAsRemoved(this.id, e, !1, n);
            else {
                let s = e[Bn];
                (!s || s === sS) && (r.afterFlush(() => this.clearElementCache(e)), r.destroyInnerAnimations(e), r._onRemovalComplete(e, n))
            }
        }
        insertNode(e, n) {
            _n(e, this._hostClassName)
        }
        drainQueuedTransitions(e) {
            let n = [];
            return this._queue.forEach(r => {
                let i = r.player;
                if (i.destroyed) return;
                let s = r.element,
                    o = this._elementListeners.get(s);
                o && o.forEach(a => {
                    if (a.name == r.triggerName) {
                        let c = Iy(s, r.triggerName, r.fromState.value, r.toState.value);
                        c._data = e, My(r.player, a.phase, c, a.callback)
                    }
                }), i.markedForDestroy ? this._engine.afterFlush(() => {
                    i.destroy()
                }) : n.push(r)
            }), this._queue = [], n.sort((r, i) => {
                let s = r.transition.ast.depCount,
                    o = i.transition.ast.depCount;
                return s == 0 || o == 0 ? s - o : this._engine.driver.containsElement(r.element, i.element) ? 1 : -1
            })
        }
        destroy(e) {
            this.players.forEach(n => n.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, e)
        }
    },
    Ey = class {
        _onRemovalComplete(e, n) {
            this.onRemovalComplete(e, n)
        }
        constructor(e, n, r, i) {
            this.bodyNode = e, this.driver = n, this._normalizer = r, this.scheduler = i, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (s, o) => {}
        }
        get queuedPlayers() {
            let e = [];
            return this._namespaceList.forEach(n => {
                n.players.forEach(r => {
                    r.queued && e.push(r)
                })
            }), e
        }
        createNamespace(e, n) {
            let r = new Dy(e, n, this);
            return this.bodyNode && this.driver.containsElement(this.bodyNode, n) ? this._balanceNamespaceList(r, n) : (this.newHostElements.set(n, r), this.collectEnterElement(n)), this._namespaceLookup[e] = r
        }
        _balanceNamespaceList(e, n) {
            let r = this._namespaceList,
                i = this.namespacesByHostElement;
            if (r.length - 1 >= 0) {
                let o = !1,
                    a = this.driver.getParentElement(n);
                for (; a;) {
                    let c = i.get(a);
                    if (c) {
                        let l = r.indexOf(c);
                        r.splice(l + 1, 0, e), o = !0;
                        break
                    }
                    a = this.driver.getParentElement(a)
                }
                o || r.unshift(e)
            } else r.push(e);
            return i.set(n, e), e
        }
        register(e, n) {
            let r = this._namespaceLookup[e];
            return r || (r = this.createNamespace(e, n)), r
        }
        registerTrigger(e, n, r) {
            let i = this._namespaceLookup[e];
            i && i.register(n, r) && this.totalAnimations++
        }
        destroy(e, n) {
            e && (this.afterFlush(() => {}), this.afterFlushAnimationsDone(() => {
                let r = this._fetchNamespace(e);
                this.namespacesByHostElement.delete(r.hostElement);
                let i = this._namespaceList.indexOf(r);
                i >= 0 && this._namespaceList.splice(i, 1), r.destroy(n), delete this._namespaceLookup[e]
            }))
        }
        _fetchNamespace(e) {
            return this._namespaceLookup[e]
        }
        fetchNamespacesByElement(e) {
            let n = new Set,
                r = this.statesByElement.get(e);
            if (r) {
                for (let i of r.values())
                    if (i.namespaceId) {
                        let s = this._fetchNamespace(i.namespaceId);
                        s && n.add(s)
                    }
            }
            return n
        }
        trigger(e, n, r, i) {
            if (xd(n)) {
                let s = this._fetchNamespace(e);
                if (s) return s.trigger(n, r, i), !0
            }
            return !1
        }
        insertNode(e, n, r, i) {
            if (!xd(n)) return;
            let s = n[Bn];
            if (s && s.setForRemoval) {
                s.setForRemoval = !1, s.setForMove = !0;
                let o = this.collectedLeaveElements.indexOf(n);
                o >= 0 && this.collectedLeaveElements.splice(o, 1)
            }
            if (e) {
                let o = this._fetchNamespace(e);
                o && o.insertNode(n, r)
            }
            i && this.collectEnterElement(n)
        }
        collectEnterElement(e) {
            this.collectedEnterElements.push(e)
        }
        markElementAsDisabled(e, n) {
            n ? this.disabledNodes.has(e) || (this.disabledNodes.add(e), _n(e, ay)) : this.disabledNodes.has(e) && (this.disabledNodes.delete(e), So(e, ay))
        }
        removeNode(e, n, r) {
            if (xd(n)) {
                this.scheduler ? .notify();
                let i = e ? this._fetchNamespace(e) : null;
                i ? i.removeNode(n, r) : this.markElementAsRemoved(e, n, !1, r);
                let s = this.namespacesByHostElement.get(n);
                s && s.id !== e && s.removeNode(n, r)
            } else this._onRemovalComplete(n, r)
        }
        markElementAsRemoved(e, n, r, i, s) {
            this.collectedLeaveElements.push(n), n[Bn] = {
                namespaceId: e,
                setForRemoval: i,
                hasAnimation: r,
                removedBeforeQueried: !1,
                previousTriggersValues: s
            }
        }
        listen(e, n, r, i, s) {
            return xd(n) ? this._fetchNamespace(e).listen(n, r, i, s) : () => {}
        }
        _buildInstruction(e, n, r, i, s) {
            return e.transition.build(this.driver, e.element, e.fromState.value, e.toState.value, r, i, e.fromState.options, e.toState.options, n, s)
        }
        destroyInnerAnimations(e) {
            let n = this.driver.query(e, Nd, !0);
            n.forEach(r => this.destroyActiveAnimationsForElement(r)), this.playersByQueriedElement.size != 0 && (n = this.driver.query(e, dy, !0), n.forEach(r => this.finishActiveQueriedAnimationOnElement(r)))
        }
        destroyActiveAnimationsForElement(e) {
            let n = this.playersByElement.get(e);
            n && n.forEach(r => {
                r.queued ? r.markedForDestroy = !0 : r.destroy()
            })
        }
        finishActiveQueriedAnimationOnElement(e) {
            let n = this.playersByQueriedElement.get(e);
            n && n.forEach(r => r.finish())
        }
        whenRenderingDone() {
            return new Promise(e => {
                if (this.players.length) return di(this.players).onDone(() => e());
                e()
            })
        }
        processLeaveNode(e) {
            let n = e[Bn];
            if (n && n.setForRemoval) {
                if (e[Bn] = sS, n.namespaceId) {
                    this.destroyInnerAnimations(e);
                    let r = this._fetchNamespace(n.namespaceId);
                    r && r.clearElementCache(e)
                }
                this._onRemovalComplete(e, n.setForRemoval)
            }
            e.classList ? .contains(ay) && this.markElementAsDisabled(e, !1), this.driver.query(e, VL, !0).forEach(r => {
                this.markElementAsDisabled(r, !1)
            })
        }
        flush(e = -1) {
            let n = [];
            if (this.newHostElements.size && (this.newHostElements.forEach((r, i) => this._balanceNamespaceList(r, i)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length)
                for (let r = 0; r < this.collectedEnterElements.length; r++) {
                    let i = this.collectedEnterElements[r];
                    _n(i, UL)
                }
            if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
                let r = [];
                try {
                    n = this._flushAnimations(r, e)
                } finally {
                    for (let i = 0; i < r.length; i++) r[i]()
                }
            } else
                for (let r = 0; r < this.collectedLeaveElements.length; r++) {
                    let i = this.collectedLeaveElements[r];
                    this.processLeaveNode(i)
                }
            if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(r => r()), this._flushFns = [], this._whenQuietFns.length) {
                let r = this._whenQuietFns;
                this._whenQuietFns = [], n.length ? di(n).onDone(() => {
                    r.forEach(i => i())
                }) : r.forEach(i => i())
            }
        }
        reportError(e) {
            throw iL(e)
        }
        _flushAnimations(e, n) {
            let r = new Za,
                i = [],
                s = new Map,
                o = [],
                a = new Map,
                c = new Map,
                l = new Map,
                u = new Set;
            this.disabledNodes.forEach(b => {
                u.add(b);
                let F = this.driver.query(b, LL, !0);
                for (let V = 0; V < F.length; V++) u.add(F[V])
            });
            let d = this.bodyNode,
                h = Array.from(this.statesByElement.keys()),
                f = ZC(h, this.collectedEnterElements),
                p = new Map,
                g = 0;
            f.forEach((b, F) => {
                let V = XC + g++;
                p.set(F, V), b.forEach($ => _n($, V))
            });
            let m = [],
                y = new Set,
                E = new Set;
            for (let b = 0; b < this.collectedLeaveElements.length; b++) {
                let F = this.collectedLeaveElements[b],
                    V = F[Bn];
                V && V.setForRemoval && (m.push(F), y.add(F), V.hasAnimation ? this.driver.query(F, jL, !0).forEach($ => y.add($)) : E.add(F))
            }
            let T = new Map,
                w = ZC(h, Array.from(y));
            w.forEach((b, F) => {
                let V = uy + g++;
                T.set(F, V), b.forEach($ => _n($, V))
            }), e.push(() => {
                f.forEach((b, F) => {
                    let V = p.get(F);
                    b.forEach($ => So($, V))
                }), w.forEach((b, F) => {
                    let V = T.get(F);
                    b.forEach($ => So($, V))
                }), m.forEach(b => {
                    this.processLeaveNode(b)
                })
            });
            let N = [],
                L = [];
            for (let b = this._namespaceList.length - 1; b >= 0; b--) this._namespaceList[b].drainQueuedTransitions(n).forEach(V => {
                let $ = V.player,
                    $e = V.element;
                if (N.push($), this.collectedEnterElements.length) {
                    let Mt = $e[Bn];
                    if (Mt && Mt.setForMove) {
                        if (Mt.previousTriggersValues && Mt.previousTriggersValues.has(V.triggerName)) {
                            let Ni = Mt.previousTriggersValues.get(V.triggerName),
                                dn = this.statesByElement.get(V.element);
                            if (dn && dn.has(V.triggerName)) {
                                let hl = dn.get(V.triggerName);
                                hl.value = Ni, dn.set(V.triggerName, hl)
                            }
                        }
                        $.destroy();
                        return
                    }
                }
                let St = !d || !this.driver.containsElement(d, $e),
                    pt = T.get($e),
                    Hr = p.get($e),
                    We = this._buildInstruction(V, r, Hr, pt, St);
                if (We.errors && We.errors.length) {
                    L.push(We);
                    return
                }
                if (St) {
                    $.onStart(() => os($e, We.fromStyles)), $.onDestroy(() => nr($e, We.toStyles)), i.push($);
                    return
                }
                if (V.isFallbackTransition) {
                    $.onStart(() => os($e, We.fromStyles)), $.onDestroy(() => nr($e, We.toStyles)), i.push($);
                    return
                }
                let Z0 = [];
                We.timelines.forEach(Mt => {
                    Mt.stretchStartingKeyframe = !0, this.disabledNodes.has(Mt.element) || Z0.push(Mt)
                }), We.timelines = Z0, r.append($e, We.timelines);
                let mA = {
                    instruction: We,
                    player: $,
                    element: $e
                };
                o.push(mA), We.queriedElements.forEach(Mt => tn(a, Mt, []).push($)), We.preStyleProps.forEach((Mt, Ni) => {
                    if (Mt.size) {
                        let dn = c.get(Ni);
                        dn || c.set(Ni, dn = new Set), Mt.forEach((hl, Wf) => dn.add(Wf))
                    }
                }), We.postStyleProps.forEach((Mt, Ni) => {
                    let dn = l.get(Ni);
                    dn || l.set(Ni, dn = new Set), Mt.forEach((hl, Wf) => dn.add(Wf))
                })
            });
            if (L.length) {
                let b = [];
                L.forEach(F => {
                    b.push(sL(F.triggerName, F.errors))
                }), N.forEach(F => F.destroy()), this.reportError(b)
            }
            let D = new Map,
                j = new Map;
            o.forEach(b => {
                let F = b.element;
                r.has(F) && (j.set(F, F), this._beforeAnimationBuild(b.player.namespaceId, b.instruction, D))
            }), i.forEach(b => {
                let F = b.element;
                this._getPreviousPlayers(F, !1, b.namespaceId, b.triggerName, null).forEach($ => {
                    tn(D, F, []).push($), $.destroy()
                })
            });
            let Y = m.filter(b => QC(b, c, l)),
                H = new Map;
            GC(H, this.driver, E, l, tr).forEach(b => {
                QC(b, c, l) && Y.push(b)
            });
            let Ue = new Map;
            f.forEach((b, F) => {
                GC(Ue, this.driver, new Set(b), c, Sd)
            }), Y.forEach(b => {
                let F = H.get(b),
                    V = Ue.get(b);
                H.set(b, new Map([...F ? .entries() ? ? [], ...V ? .entries() ? ? []]))
            });
            let qt = [],
                v = [],
                A = {};
            o.forEach(b => {
                let {
                    element: F,
                    player: V,
                    instruction: $
                } = b;
                if (r.has(F)) {
                    if (u.has(F)) {
                        V.onDestroy(() => nr(F, $.toStyles)), V.disabled = !0, V.overrideTotalTime($.totalTime), i.push(V);
                        return
                    }
                    let $e = A;
                    if (j.size > 1) {
                        let pt = F,
                            Hr = [];
                        for (; pt = pt.parentNode;) {
                            let We = j.get(pt);
                            if (We) {
                                $e = We;
                                break
                            }
                            Hr.push(pt)
                        }
                        Hr.forEach(We => j.set(We, $e))
                    }
                    let St = this._buildAnimation(V.namespaceId, $, D, s, Ue, H);
                    if (V.setRealPlayer(St), $e === A) qt.push(V);
                    else {
                        let pt = this.playersByElement.get($e);
                        pt && pt.length && (V.parentPlayer = di(pt)), i.push(V)
                    }
                } else os(F, $.fromStyles), V.onDestroy(() => nr(F, $.toStyles)), v.push(V), u.has(F) && i.push(V)
            }), v.forEach(b => {
                let F = s.get(b.element);
                if (F && F.length) {
                    let V = di(F);
                    b.setRealPlayer(V)
                }
            }), i.forEach(b => {
                b.parentPlayer ? b.syncPlayerEvents(b.parentPlayer) : b.destroy()
            });
            for (let b = 0; b < m.length; b++) {
                let F = m[b],
                    V = F[Bn];
                if (So(F, uy), V && V.hasAnimation) continue;
                let $ = [];
                if (a.size) {
                    let St = a.get(F);
                    St && St.length && $.push(...St);
                    let pt = this.driver.query(F, dy, !0);
                    for (let Hr = 0; Hr < pt.length; Hr++) {
                        let We = a.get(pt[Hr]);
                        We && We.length && $.push(...We)
                    }
                }
                let $e = $.filter(St => !St.destroyed);
                $e.length ? GL(this, F, $e) : this.processLeaveNode(F)
            }
            return m.length = 0, qt.forEach(b => {
                this.players.push(b), b.onDone(() => {
                    b.destroy();
                    let F = this.players.indexOf(b);
                    this.players.splice(F, 1)
                }), b.play()
            }), qt
        }
        afterFlush(e) {
            this._flushFns.push(e)
        }
        afterFlushAnimationsDone(e) {
            this._whenQuietFns.push(e)
        }
        _getPreviousPlayers(e, n, r, i, s) {
            let o = [];
            if (n) {
                let a = this.playersByQueriedElement.get(e);
                a && (o = a)
            } else {
                let a = this.playersByElement.get(e);
                if (a) {
                    let c = !s || s == Ha;
                    a.forEach(l => {
                        l.queued || !c && l.triggerName != i || o.push(l)
                    })
                }
            }
            return (r || i) && (o = o.filter(a => !(r && r != a.namespaceId || i && i != a.triggerName))), o
        }
        _beforeAnimationBuild(e, n, r) {
            let i = n.triggerName,
                s = n.element,
                o = n.isRemovalTransition ? void 0 : e,
                a = n.isRemovalTransition ? void 0 : i;
            for (let c of n.timelines) {
                let l = c.element,
                    u = l !== s,
                    d = tn(r, l, []);
                this._getPreviousPlayers(l, u, o, a, n.toState).forEach(f => {
                    let p = f.getRealPlayer();
                    p.beforeDestroy && p.beforeDestroy(), f.destroy(), d.push(f)
                })
            }
            os(s, n.fromStyles)
        }
        _buildAnimation(e, n, r, i, s, o) {
            let a = n.triggerName,
                c = n.element,
                l = [],
                u = new Set,
                d = new Set,
                h = n.timelines.map(p => {
                    let g = p.element;
                    u.add(g);
                    let m = g[Bn];
                    if (m && m.removedBeforeQueried) return new ui(p.duration, p.delay);
                    let y = g !== c,
                        E = ZL((r.get(g) || BL).map(D => D.getRealPlayer())).filter(D => {
                            let j = D;
                            return j.element ? j.element === g : !1
                        }),
                        T = s.get(g),
                        w = o.get(g),
                        N = qC(this._normalizer, p.keyframes, T, w),
                        L = this._buildPlayer(p, N, E);
                    if (p.subTimeline && i && d.add(g), y) {
                        let D = new qa(e, a, g);
                        D.setRealPlayer(L), l.push(D)
                    }
                    return L
                });
            l.forEach(p => {
                tn(this.playersByQueriedElement, p.element, []).push(p), p.onDone(() => $L(this.playersByQueriedElement, p.element, p))
            }), u.forEach(p => _n(p, VC));
            let f = di(h);
            return f.onDestroy(() => {
                u.forEach(p => So(p, VC)), nr(c, n.toStyles)
            }), d.forEach(p => {
                tn(i, p, []).push(f)
            }), f
        }
        _buildPlayer(e, n, r) {
            return n.length > 0 ? this.driver.animate(e.element, n, e.duration, e.delay, e.easing, r) : new ui(e.duration, e.delay)
        }
    },
    qa = class {
        constructor(e, n, r) {
            this.namespaceId = e, this.triggerName = n, this.element = r, this._player = new ui, this._containsRealPlayer = !1, this._queuedCallbacks = new Map, this.destroyed = !1, this.parentPlayer = null, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0
        }
        setRealPlayer(e) {
            this._containsRealPlayer || (this._player = e, this._queuedCallbacks.forEach((n, r) => {
                n.forEach(i => My(e, r, void 0, i))
            }), this._queuedCallbacks.clear(), this._containsRealPlayer = !0, this.overrideTotalTime(e.totalTime), this.queued = !1)
        }
        getRealPlayer() {
            return this._player
        }
        overrideTotalTime(e) {
            this.totalTime = e
        }
        syncPlayerEvents(e) {
            let n = this._player;
            n.triggerCallback && e.onStart(() => n.triggerCallback("start")), e.onDone(() => this.finish()), e.onDestroy(() => this.destroy())
        }
        _queueEvent(e, n) {
            tn(this._queuedCallbacks, e, []).push(n)
        }
        onDone(e) {
            this.queued && this._queueEvent("done", e), this._player.onDone(e)
        }
        onStart(e) {
            this.queued && this._queueEvent("start", e), this._player.onStart(e)
        }
        onDestroy(e) {
            this.queued && this._queueEvent("destroy", e), this._player.onDestroy(e)
        }
        init() {
            this._player.init()
        }
        hasStarted() {
            return this.queued ? !1 : this._player.hasStarted()
        }
        play() {
            !this.queued && this._player.play()
        }
        pause() {
            !this.queued && this._player.pause()
        }
        restart() {
            !this.queued && this._player.restart()
        }
        finish() {
            this._player.finish()
        }
        destroy() {
            this.destroyed = !0, this._player.destroy()
        }
        reset() {
            !this.queued && this._player.reset()
        }
        setPosition(e) {
            this.queued || this._player.setPosition(e)
        }
        getPosition() {
            return this.queued ? 0 : this._player.getPosition()
        }
        triggerCallback(e) {
            let n = this._player;
            n.triggerCallback && n.triggerCallback(e)
        }
    };

function $L(t, e, n) {
    let r = t.get(e);
    if (r) {
        if (r.length) {
            let i = r.indexOf(n);
            r.splice(i, 1)
        }
        r.length == 0 && t.delete(e)
    }
    return r
}

function WL(t) {
    return t ? ? null
}

function xd(t) {
    return t && t.nodeType === 1
}

function HL(t) {
    return t == "start" || t == "done"
}

function HC(t, e) {
    let n = t.style.display;
    return t.style.display = e ? ? "none", n
}

function GC(t, e, n, r, i) {
    let s = [];
    n.forEach(c => s.push(HC(c)));
    let o = [];
    r.forEach((c, l) => {
        let u = new Map;
        c.forEach(d => {
            let h = e.computeStyle(l, d, i);
            u.set(d, h), (!h || h.length == 0) && (l[Bn] = zL, o.push(l))
        }), t.set(l, u)
    });
    let a = 0;
    return n.forEach(c => HC(c, s[a++])), o
}

function ZC(t, e) {
    let n = new Map;
    if (t.forEach(a => n.set(a, [])), e.length == 0) return n;
    let r = 1,
        i = new Set(e),
        s = new Map;

    function o(a) {
        if (!a) return r;
        let c = s.get(a);
        if (c) return c;
        let l = a.parentNode;
        return n.has(l) ? c = l : i.has(l) ? c = r : c = o(l), s.set(a, c), c
    }
    return e.forEach(a => {
        let c = o(a);
        c !== r && n.get(c).push(a)
    }), n
}

function _n(t, e) {
    t.classList ? .add(e)
}

function So(t, e) {
    t.classList ? .remove(e)
}

function GL(t, e, n) {
    di(n).onDone(() => t.processLeaveNode(e))
}

function ZL(t) {
    let e = [];
    return oS(t, e), e
}

function oS(t, e) {
    for (let n = 0; n < t.length; n++) {
        let r = t[n];
        r instanceof $a ? oS(r.players, e) : e.push(r)
    }
}

function QL(t, e) {
    let n = Object.keys(t),
        r = Object.keys(e);
    if (n.length != r.length) return !1;
    for (let i = 0; i < n.length; i++) {
        let s = n[i];
        if (!e.hasOwnProperty(s) || t[s] !== e[s]) return !1
    }
    return !0
}

function QC(t, e, n) {
    let r = n.get(t);
    if (!r) return !1;
    let i = e.get(t);
    return i ? r.forEach(s => i.add(s)) : e.set(t, r), n.delete(t), !0
}
var Io = class {
    constructor(e, n, r, i) {
        this._driver = n, this._normalizer = r, this._triggerCache = {}, this.onRemovalComplete = (s, o) => {}, this._transitionEngine = new Ey(e.body, n, r, i), this._timelineEngine = new by(e.body, n, r), this._transitionEngine.onRemovalComplete = (s, o) => this.onRemovalComplete(s, o)
    }
    registerTrigger(e, n, r, i, s) {
        let o = e + "-" + i,
            a = this._triggerCache[o];
        if (!a) {
            let c = [],
                l = [],
                u = nS(this._driver, s, c, l);
            if (c.length) throw QP(i, c);
            l.length && void 0, a = FL(i, u, this._normalizer), this._triggerCache[o] = a
        }
        this._transitionEngine.registerTrigger(n, i, a)
    }
    register(e, n) {
        this._transitionEngine.register(e, n)
    }
    destroy(e, n) {
        this._transitionEngine.destroy(e, n)
    }
    onInsert(e, n, r, i) {
        this._transitionEngine.insertNode(e, n, r, i)
    }
    onRemove(e, n, r) {
        this._transitionEngine.removeNode(e, n, r)
    }
    disableAnimations(e, n) {
        this._transitionEngine.markElementAsDisabled(e, n)
    }
    process(e, n, r, i) {
        if (r.charAt(0) == "@") {
            let [s, o] = PC(r), a = i;
            this._timelineEngine.command(s, n, o, a)
        } else this._transitionEngine.trigger(e, n, r, i)
    }
    listen(e, n, r, i, s) {
        if (r.charAt(0) == "@") {
            let [o, a] = PC(r);
            return this._timelineEngine.listen(o, n, a, s)
        }
        return this._transitionEngine.listen(e, n, r, i, s)
    }
    flush(e = -1) {
        this._transitionEngine.flush(e)
    }
    get players() {
        return [...this._transitionEngine.players, ...this._timelineEngine.players]
    }
    whenRenderingDone() {
        return this._transitionEngine.whenRenderingDone()
    }
    afterFlushAnimationsDone(e) {
        this._transitionEngine.afterFlushAnimationsDone(e)
    }
};

function qL(t, e) {
    let n = null,
        r = null;
    return Array.isArray(e) && e.length ? (n = ly(e[0]), e.length > 1 && (r = ly(e[e.length - 1]))) : e instanceof Map && (n = ly(e)), n || r ? new Cy(t, n, r) : null
}
var Mo = class Mo {
    constructor(e, n, r) {
        this._element = e, this._startStyles = n, this._endStyles = r, this._state = 0;
        let i = Mo.initialStylesByElement.get(e);
        i || Mo.initialStylesByElement.set(e, i = new Map), this._initialStyles = i
    }
    start() {
        this._state < 1 && (this._startStyles && nr(this._element, this._startStyles, this._initialStyles), this._state = 1)
    }
    finish() {
        this.start(), this._state < 2 && (nr(this._element, this._initialStyles), this._endStyles && (nr(this._element, this._endStyles), this._endStyles = null), this._state = 1)
    }
    destroy() {
        this.finish(), this._state < 3 && (Mo.initialStylesByElement.delete(this._element), this._startStyles && (os(this._element, this._startStyles), this._endStyles = null), this._endStyles && (os(this._element, this._endStyles), this._endStyles = null), nr(this._element, this._initialStyles), this._state = 3)
    }
};
Mo.initialStylesByElement = new WeakMap;
var Cy = Mo;

function ly(t) {
    let e = null;
    return t.forEach((n, r) => {
        KL(r) && (e = e || new Map, e.set(r, n))
    }), e
}

function KL(t) {
    return t === "display" || t === "position"
}
var Vd = class {
        constructor(e, n, r, i) {
            this.element = e, this.keyframes = n, this.options = r, this._specialStyles = i, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this._originalOnDoneFns = [], this._originalOnStartFns = [], this.time = 0, this.parentPlayer = null, this.currentSnapshot = new Map, this._duration = r.duration, this._delay = r.delay || 0, this.time = this._duration + this._delay
        }
        _onFinish() {
            this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = [])
        }
        init() {
            this._buildPlayer(), this._preparePlayerBeforeStart()
        }
        _buildPlayer() {
            if (this._initialized) return;
            this._initialized = !0;
            let e = this.keyframes;
            this.domPlayer = this._triggerWebAnimation(this.element, e, this.options), this._finalKeyframe = e.length ? e[e.length - 1] : new Map;
            let n = () => this._onFinish();
            this.domPlayer.addEventListener("finish", n), this.onDestroy(() => {
                this.domPlayer.removeEventListener("finish", n)
            })
        }
        _preparePlayerBeforeStart() {
            this._delay ? this._resetDomPlayerState() : this.domPlayer.pause()
        }
        _convertKeyframesToObject(e) {
            let n = [];
            return e.forEach(r => {
                n.push(Object.fromEntries(r))
            }), n
        }
        _triggerWebAnimation(e, n, r) {
            return e.animate(this._convertKeyframesToObject(n), r)
        }
        onStart(e) {
            this._originalOnStartFns.push(e), this._onStartFns.push(e)
        }
        onDone(e) {
            this._originalOnDoneFns.push(e), this._onDoneFns.push(e)
        }
        onDestroy(e) {
            this._onDestroyFns.push(e)
        }
        play() {
            this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(e => e()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play()
        }
        pause() {
            this.init(), this.domPlayer.pause()
        }
        finish() {
            this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish()
        }
        reset() {
            this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns
        }
        _resetDomPlayerState() {
            this.domPlayer && this.domPlayer.cancel()
        }
        restart() {
            this.reset(), this.play()
        }
        hasStarted() {
            return this._started
        }
        destroy() {
            this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = [])
        }
        setPosition(e) {
            this.domPlayer === void 0 && this.init(), this.domPlayer.currentTime = e * this.time
        }
        getPosition() {
            return +(this.domPlayer.currentTime ? ? 0) / this.time
        }
        get totalTime() {
            return this._delay + this._duration
        }
        beforeDestroy() {
            let e = new Map;
            this.hasStarted() && this._finalKeyframe.forEach((r, i) => {
                i !== "offset" && e.set(i, this._finished ? r : Ny(this.element, i))
            }), this.currentSnapshot = e
        }
        triggerCallback(e) {
            let n = e === "start" ? this._onStartFns : this._onDoneFns;
            n.forEach(r => r()), n.length = 0
        }
    },
    Ud = class {
        validateStyleProperty(e) {
            return !0
        }
        validateAnimatableStyleProperty(e) {
            return !0
        }
        matchesElement(e, n) {
            return !1
        }
        containsElement(e, n) {
            return KC(e, n)
        }
        getParentElement(e) {
            return Ty(e)
        }
        query(e, n, r) {
            return YC(e, n, r)
        }
        computeStyle(e, n, r) {
            return Ny(e, n)
        }
        animate(e, n, r, i, s, o = []) {
            let a = i == 0 ? "both" : "forwards",
                c = {
                    duration: r,
                    delay: i,
                    fill: a
                };
            s && (c.easing = s);
            let l = new Map,
                u = o.filter(f => f instanceof Vd);
            mL(r, i) && u.forEach(f => {
                f.currentSnapshot.forEach((p, g) => l.set(g, p))
            });
            let d = fL(n).map(f => new Map(f));
            d = yL(e, d, l);
            let h = qL(e, d);
            return new Vd(e, d, c, h)
        }
    };
var Ad = "@",
    aS = "@.disabled",
    jd = class {
        constructor(e, n, r, i) {
            this.namespaceId = e, this.delegate = n, this.engine = r, this._onDestroy = i, this.\u0275type = 0
        }
        get data() {
            return this.delegate.data
        }
        destroyNode(e) {
            this.delegate.destroyNode ? .(e)
        }
        destroy() {
            this.engine.destroy(this.namespaceId, this.delegate), this.engine.afterFlushAnimationsDone(() => {
                queueMicrotask(() => {
                    this.delegate.destroy()
                })
            }), this._onDestroy ? .()
        }
        createElement(e, n) {
            return this.delegate.createElement(e, n)
        }
        createComment(e) {
            return this.delegate.createComment(e)
        }
        createText(e) {
            return this.delegate.createText(e)
        }
        appendChild(e, n) {
            this.delegate.appendChild(e, n), this.engine.onInsert(this.namespaceId, n, e, !1)
        }
        insertBefore(e, n, r, i = !0) {
            this.delegate.insertBefore(e, n, r), this.engine.onInsert(this.namespaceId, n, e, i)
        }
        removeChild(e, n, r) {
            this.engine.onRemove(this.namespaceId, n, this.delegate)
        }
        selectRootElement(e, n) {
            return this.delegate.selectRootElement(e, n)
        }
        parentNode(e) {
            return this.delegate.parentNode(e)
        }
        nextSibling(e) {
            return this.delegate.nextSibling(e)
        }
        setAttribute(e, n, r, i) {
            this.delegate.setAttribute(e, n, r, i)
        }
        removeAttribute(e, n, r) {
            this.delegate.removeAttribute(e, n, r)
        }
        addClass(e, n) {
            this.delegate.addClass(e, n)
        }
        removeClass(e, n) {
            this.delegate.removeClass(e, n)
        }
        setStyle(e, n, r, i) {
            this.delegate.setStyle(e, n, r, i)
        }
        removeStyle(e, n, r) {
            this.delegate.removeStyle(e, n, r)
        }
        setProperty(e, n, r) {
            n.charAt(0) == Ad && n == aS ? this.disableAnimations(e, !!r) : this.delegate.setProperty(e, n, r)
        }
        setValue(e, n) {
            this.delegate.setValue(e, n)
        }
        listen(e, n, r) {
            return this.delegate.listen(e, n, r)
        }
        disableAnimations(e, n) {
            this.engine.disableAnimations(e, n)
        }
    },
    Sy = class extends jd {
        constructor(e, n, r, i, s) {
            super(n, r, i, s), this.factory = e, this.namespaceId = n
        }
        setProperty(e, n, r) {
            n.charAt(0) == Ad ? n.charAt(1) == "." && n == aS ? (r = r === void 0 ? !0 : !!r, this.disableAnimations(e, r)) : this.engine.process(this.namespaceId, e, n.slice(1), r) : this.delegate.setProperty(e, n, r)
        }
        listen(e, n, r) {
            if (n.charAt(0) == Ad) {
                let i = YL(e),
                    s = n.slice(1),
                    o = "";
                return s.charAt(0) != Ad && ([s, o] = JL(s)), this.engine.listen(this.namespaceId, i, s, o, a => {
                    let c = a._data || -1;
                    this.factory.scheduleListenerCallback(c, r, a)
                })
            }
            return this.delegate.listen(e, n, r)
        }
    };

function YL(t) {
    switch (t) {
        case "body":
            return document.body;
        case "document":
            return document;
        case "window":
            return window;
        default:
            return t
    }
}

function JL(t) {
    let e = t.indexOf("."),
        n = t.substring(0, e),
        r = t.slice(e + 1);
    return [n, r]
}
var Bd = class {
    constructor(e, n, r) {
        this.delegate = e, this.engine = n, this._zone = r, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, n.onRemovalComplete = (i, s) => {
            let o = s ? .parentNode(i);
            o && s.removeChild(o, i)
        }
    }
    createRenderer(e, n) {
        let r = "",
            i = this.delegate.createRenderer(e, n);
        if (!e || !n ? .data ? .animation) {
            let l = this._rendererCache,
                u = l.get(i);
            if (!u) {
                let d = () => l.delete(i);
                u = new jd(r, i, this.engine, d), l.set(i, u)
            }
            return u
        }
        let s = n.id,
            o = n.id + "-" + this._currentId;
        this._currentId++, this.engine.register(o, e);
        let a = l => {
            Array.isArray(l) ? l.forEach(a) : this.engine.registerTrigger(s, o, e, l.name, l)
        };
        return n.data.animation.forEach(a), new Sy(this, o, i, this.engine)
    }
    begin() {
        this._cdRecurDepth++, this.delegate.begin && this.delegate.begin()
    }
    _scheduleCountTask() {
        queueMicrotask(() => {
            this._microtaskId++
        })
    }
    scheduleListenerCallback(e, n, r) {
        if (e >= 0 && e < this._microtaskId) {
            this._zone.run(() => n(r));
            return
        }
        let i = this._animationCallbacksBuffer;
        i.length == 0 && queueMicrotask(() => {
            this._zone.run(() => {
                i.forEach(s => {
                    let [o, a] = s;
                    o(a)
                }), this._animationCallbacksBuffer = []
            })
        }), i.push([n, r])
    }
    end() {
        this._cdRecurDepth--, this._cdRecurDepth == 0 && this._zone.runOutsideAngular(() => {
            this._scheduleCountTask(), this.engine.flush(this._microtaskId)
        }), this.delegate.end && this.delegate.end()
    }
    whenRenderingDone() {
        return this.engine.whenRenderingDone()
    }
};
var eV = (() => {
    let e = class e extends Io {
        constructor(r, i, s) {
            super(r, i, s, M(ao, {
                optional: !0
            }))
        }
        ngOnDestroy() {
            this.flush()
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)(C(ke), C(as), C(cs))
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac
    });
    let t = e;
    return t
})();

function tV() {
    return new Od
}

function nV(t, e, n) {
    return new Bd(t, e, n)
}
var lS = [{
        provide: cs,
        useFactory: tV
    }, {
        provide: Io,
        useClass: eV
    }, {
        provide: Pn,
        useFactory: nV,
        deps: [Dd, Io, ye]
    }],
    cS = [{
        provide: as,
        useFactory: () => new Ud
    }, {
        provide: Oa,
        useValue: "BrowserAnimations"
    }, ...lS],
    rV = [{
        provide: as,
        useClass: xy
    }, {
        provide: Oa,
        useValue: "NoopAnimations"
    }, ...lS],
    uS = (() => {
        let e = class e {
            static withConfig(r) {
                return {
                    ngModule: e,
                    providers: r.disableAnimations ? rV : cS
                }
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275mod = xe({
            type: e
        }), e.\u0275inj = Te({
            providers: cS,
            imports: [AC]
        });
        let t = e;
        return t
    })();
var hi = class {},
    dS = (() => {
        class t extends hi {
            getTranslation(n) {
                return k({})
            }
        }
        return t.\u0275fac = (() => {
            let e;
            return function(r) {
                return (e || (e = Xn(t)))(r || t)
            }
        })(), t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac
        }), t
    })(),
    Ka = class {},
    hS = (() => {
        class t {
            handle(n) {
                return n.key
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)
        }, t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac
        }), t
    })();

function Ya(t, e) {
    if (t === e) return !0;
    if (t === null || e === null) return !1;
    if (t !== t && e !== e) return !0;
    let n = typeof t,
        r = typeof e,
        i, s, o;
    if (n == r && n == "object")
        if (Array.isArray(t)) {
            if (!Array.isArray(e)) return !1;
            if ((i = t.length) == e.length) {
                for (s = 0; s < i; s++)
                    if (!Ya(t[s], e[s])) return !1;
                return !0
            }
        } else {
            if (Array.isArray(e)) return !1;
            o = Object.create(null);
            for (s in t) {
                if (!Ya(t[s], e[s])) return !1;
                o[s] = !0
            }
            for (s in e)
                if (!(s in o) && typeof e[s] < "u") return !1;
            return !0
        }
    return !1
}

function nn(t) {
    return typeof t < "u" && t !== null
}

function Fy(t) {
    return t && typeof t == "object" && !Array.isArray(t)
}

function gS(t, e) {
    let n = Object.assign({}, t);
    return Fy(t) && Fy(e) && Object.keys(e).forEach(r => {
        Fy(e[r]) ? r in t ? n[r] = gS(t[r], e[r]) : Object.assign(n, {
            [r]: e[r]
        }) : Object.assign(n, {
            [r]: e[r]
        })
    }), n
}
var To = class {},
    fS = (() => {
        class t extends To {
            constructor() {
                super(...arguments), this.templateMatcher = /{{\s?([^{}\s]*)\s?}}/g
            }
            interpolate(n, r) {
                let i;
                return typeof n == "string" ? i = this.interpolateString(n, r) : typeof n == "function" ? i = this.interpolateFunction(n, r) : i = n, i
            }
            getValue(n, r) {
                let i = typeof r == "string" ? r.split(".") : [r];
                r = "";
                do r += i.shift(), nn(n) && nn(n[r]) && (typeof n[r] == "object" || !i.length) ? (n = n[r], r = "") : i.length ? r += "." : n = void 0; while (i.length);
                return n
            }
            interpolateFunction(n, r) {
                return n(r)
            }
            interpolateString(n, r) {
                return r ? n.replace(this.templateMatcher, (i, s) => {
                    let o = this.getValue(r, s);
                    return nn(o) ? o : i
                }) : n
            }
        }
        return t.\u0275fac = (() => {
            let e;
            return function(r) {
                return (e || (e = Xn(t)))(r || t)
            }
        })(), t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac
        }), t
    })(),
    xo = class {},
    pS = (() => {
        class t extends xo {
            compile(n, r) {
                return n
            }
            compileTranslations(n, r) {
                return n
            }
        }
        return t.\u0275fac = (() => {
            let e;
            return function(r) {
                return (e || (e = Xn(t)))(r || t)
            }
        })(), t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac
        }), t
    })(),
    zd = class {
        constructor() {
            this.currentLang = this.defaultLang, this.translations = {}, this.langs = [], this.onTranslationChange = new oe, this.onLangChange = new oe, this.onDefaultLangChange = new oe
        }
    },
    ky = new R("USE_STORE"),
    Py = new R("USE_DEFAULT_LANG"),
    Ly = new R("DEFAULT_LANGUAGE"),
    Vy = new R("USE_EXTEND"),
    rr = (() => {
        class t {
            constructor(n, r, i, s, o, a = !0, c = !1, l = !1, u) {
                this.store = n, this.currentLoader = r, this.compiler = i, this.parser = s, this.missingTranslationHandler = o, this.useDefaultLang = a, this.isolate = c, this.extend = l, this.pending = !1, this._onTranslationChange = new oe, this._onLangChange = new oe, this._onDefaultLangChange = new oe, this._langs = [], this._translations = {}, this._translationRequests = {}, u && this.setDefaultLang(u)
            }
            get onTranslationChange() {
                return this.isolate ? this._onTranslationChange : this.store.onTranslationChange
            }
            get onLangChange() {
                return this.isolate ? this._onLangChange : this.store.onLangChange
            }
            get onDefaultLangChange() {
                return this.isolate ? this._onDefaultLangChange : this.store.onDefaultLangChange
            }
            get defaultLang() {
                return this.isolate ? this._defaultLang : this.store.defaultLang
            }
            set defaultLang(n) {
                this.isolate ? this._defaultLang = n : this.store.defaultLang = n
            }
            get currentLang() {
                return this.isolate ? this._currentLang : this.store.currentLang
            }
            set currentLang(n) {
                this.isolate ? this._currentLang = n : this.store.currentLang = n
            }
            get langs() {
                return this.isolate ? this._langs : this.store.langs
            }
            set langs(n) {
                this.isolate ? this._langs = n : this.store.langs = n
            }
            get translations() {
                return this.isolate ? this._translations : this.store.translations
            }
            set translations(n) {
                this.isolate ? this._translations = n : this.store.translations = n
            }
            setDefaultLang(n) {
                if (n === this.defaultLang) return;
                let r = this.retrieveTranslations(n);
                typeof r < "u" ? (this.defaultLang == null && (this.defaultLang = n), r.pipe(vt(1)).subscribe(i => {
                    this.changeDefaultLang(n)
                })) : this.changeDefaultLang(n)
            }
            getDefaultLang() {
                return this.defaultLang
            }
            use(n) {
                if (n === this.currentLang) return k(this.translations[n]);
                let r = this.retrieveTranslations(n);
                return typeof r < "u" ? (this.currentLang || (this.currentLang = n), r.pipe(vt(1)).subscribe(i => {
                    this.changeLang(n)
                }), r) : (this.changeLang(n), k(this.translations[n]))
            }
            retrieveTranslations(n) {
                let r;
                return (typeof this.translations[n] > "u" || this.extend) && (this._translationRequests[n] = this._translationRequests[n] || this.getTranslation(n), r = this._translationRequests[n]), r
            }
            getTranslation(n) {
                this.pending = !0;
                let r = this.currentLoader.getTranslation(n).pipe(Zs(1), vt(1));
                return this.loadingTranslations = r.pipe(Z(i => this.compiler.compileTranslations(i, n)), Zs(1), vt(1)), this.loadingTranslations.subscribe({
                    next: i => {
                        this.translations[n] = this.extend && this.translations[n] ? _(_({}, i), this.translations[n]) : i, this.updateLangs(), this.pending = !1
                    },
                    error: i => {
                        this.pending = !1
                    }
                }), r
            }
            setTranslation(n, r, i = !1) {
                r = this.compiler.compileTranslations(r, n), (i || this.extend) && this.translations[n] ? this.translations[n] = gS(this.translations[n], r) : this.translations[n] = r, this.updateLangs(), this.onTranslationChange.emit({
                    lang: n,
                    translations: this.translations[n]
                })
            }
            getLangs() {
                return this.langs
            }
            addLangs(n) {
                n.forEach(r => {
                    this.langs.indexOf(r) === -1 && this.langs.push(r)
                })
            }
            updateLangs() {
                this.addLangs(Object.keys(this.translations))
            }
            getParsedResult(n, r, i) {
                let s;
                if (r instanceof Array) {
                    let o = {},
                        a = !1;
                    for (let c of r) o[c] = this.getParsedResult(n, c, i), Rt(o[c]) && (a = !0);
                    if (a) {
                        let c = r.map(l => Rt(o[l]) ? o[l] : k(o[l]));
                        return ha(c).pipe(Z(l => {
                            let u = {};
                            return l.forEach((d, h) => {
                                u[r[h]] = d
                            }), u
                        }))
                    }
                    return o
                }
                if (n && (s = this.parser.interpolate(this.parser.getValue(n, r), i)), typeof s > "u" && this.defaultLang != null && this.defaultLang !== this.currentLang && this.useDefaultLang && (s = this.parser.interpolate(this.parser.getValue(this.translations[this.defaultLang], r), i)), typeof s > "u") {
                    let o = {
                        key: r,
                        translateService: this
                    };
                    typeof i < "u" && (o.interpolateParams = i), s = this.missingTranslationHandler.handle(o)
                }
                return typeof s < "u" ? s : r
            }
            get(n, r) {
                if (!nn(n) || !n.length) throw new Error('Parameter "key" required');
                if (this.pending) return this.loadingTranslations.pipe(nt(i => (i = this.getParsedResult(i, n, r), Rt(i) ? i : k(i)))); {
                    let i = this.getParsedResult(this.translations[this.currentLang], n, r);
                    return Rt(i) ? i : k(i)
                }
            }
            getStreamOnTranslationChange(n, r) {
                if (!nn(n) || !n.length) throw new Error('Parameter "key" required');
                return Dr(mt(() => this.get(n, r)), this.onTranslationChange.pipe(Je(i => {
                    let s = this.getParsedResult(i.translations, n, r);
                    return typeof s.subscribe == "function" ? s : k(s)
                })))
            }
            stream(n, r) {
                if (!nn(n) || !n.length) throw new Error('Parameter "key" required');
                return Dr(mt(() => this.get(n, r)), this.onLangChange.pipe(Je(i => {
                    let s = this.getParsedResult(i.translations, n, r);
                    return Rt(s) ? s : k(s)
                })))
            }
            instant(n, r) {
                if (!nn(n) || !n.length) throw new Error('Parameter "key" required');
                let i = this.getParsedResult(this.translations[this.currentLang], n, r);
                if (Rt(i)) {
                    if (n instanceof Array) {
                        let s = {};
                        return n.forEach((o, a) => {
                            s[n[a]] = n[a]
                        }), s
                    }
                    return n
                } else return i
            }
            set(n, r, i = this.currentLang) {
                this.translations[i][n] = this.compiler.compile(r, i), this.updateLangs(), this.onTranslationChange.emit({
                    lang: i,
                    translations: this.translations[i]
                })
            }
            changeLang(n) {
                this.currentLang = n, this.onLangChange.emit({
                    lang: n,
                    translations: this.translations[n]
                }), this.defaultLang == null && this.changeDefaultLang(n)
            }
            changeDefaultLang(n) {
                this.defaultLang = n, this.onDefaultLangChange.emit({
                    lang: n,
                    translations: this.translations[n]
                })
            }
            reloadLang(n) {
                return this.resetLang(n), this.getTranslation(n)
            }
            resetLang(n) {
                this._translationRequests[n] = void 0, this.translations[n] = void 0
            }
            getBrowserLang() {
                if (typeof window > "u" || typeof window.navigator > "u") return;
                let n = window.navigator.languages ? window.navigator.languages[0] : null;
                if (n = n || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage, !(typeof n > "u")) return n.indexOf("-") !== -1 && (n = n.split("-")[0]), n.indexOf("_") !== -1 && (n = n.split("_")[0]), n
            }
            getBrowserCultureLang() {
                if (typeof window > "u" || typeof window.navigator > "u") return;
                let n = window.navigator.languages ? window.navigator.languages[0] : null;
                return n = n || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage, n
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(C(zd), C(hi), C(xo), C(To), C(Ka), C(Py), C(ky), C(Vy), C(Ly))
        }, t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac
        }), t
    })(),
    ir = (() => {
        class t {
            constructor(n, r, i) {
                this.translateService = n, this.element = r, this._ref = i, this.onTranslationChangeSub || (this.onTranslationChangeSub = this.translateService.onTranslationChange.subscribe(s => {
                    s.lang === this.translateService.currentLang && this.checkNodes(!0, s.translations)
                })), this.onLangChangeSub || (this.onLangChangeSub = this.translateService.onLangChange.subscribe(s => {
                    this.checkNodes(!0, s.translations)
                })), this.onDefaultLangChangeSub || (this.onDefaultLangChangeSub = this.translateService.onDefaultLangChange.subscribe(s => {
                    this.checkNodes(!0)
                }))
            }
            set translate(n) {
                n && (this.key = n, this.checkNodes())
            }
            set translateParams(n) {
                Ya(this.currentParams, n) || (this.currentParams = n, this.checkNodes(!0))
            }
            ngAfterViewChecked() {
                this.checkNodes()
            }
            checkNodes(n = !1, r) {
                let i = this.element.nativeElement.childNodes;
                i.length || (this.setContent(this.element.nativeElement, this.key), i = this.element.nativeElement.childNodes);
                for (let s = 0; s < i.length; ++s) {
                    let o = i[s];
                    if (o.nodeType === 3) {
                        let a;
                        if (n && (o.lastKey = null), nn(o.lookupKey)) a = o.lookupKey;
                        else if (this.key) a = this.key;
                        else {
                            let c = this.getContent(o),
                                l = c.trim();
                            l.length && (o.lookupKey = l, c !== o.currentValue ? (a = l, o.originalContent = c || o.originalContent) : o.originalContent ? a = o.originalContent.trim() : c !== o.currentValue && (a = l, o.originalContent = c || o.originalContent))
                        }
                        this.updateValue(a, o, r)
                    }
                }
            }
            updateValue(n, r, i) {
                if (n) {
                    if (r.lastKey === n && this.lastParams === this.currentParams) return;
                    this.lastParams = this.currentParams;
                    let s = o => {
                        o !== n && (r.lastKey = n), r.originalContent || (r.originalContent = this.getContent(r)), r.currentValue = nn(o) ? o : r.originalContent || n, this.setContent(r, this.key ? r.currentValue : r.originalContent.replace(n, r.currentValue)), this._ref.markForCheck()
                    };
                    if (nn(i)) {
                        let o = this.translateService.getParsedResult(i, n, this.currentParams);
                        Rt(o) ? o.subscribe({
                            next: s
                        }) : s(o)
                    } else this.translateService.get(n, this.currentParams).subscribe(s)
                }
            }
            getContent(n) {
                return nn(n.textContent) ? n.textContent : n.data
            }
            setContent(n, r) {
                nn(n.textContent) ? n.textContent = r : n.data = r
            }
            ngOnDestroy() {
                this.onLangChangeSub && this.onLangChangeSub.unsubscribe(), this.onDefaultLangChangeSub && this.onDefaultLangChangeSub.unsubscribe(), this.onTranslationChangeSub && this.onTranslationChangeSub.unsubscribe()
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(O(rr), O(je), O(xt))
        }, t.\u0275dir = et({
            type: t,
            selectors: [
                ["", "translate", ""],
                ["", "ngx-translate", ""]
            ],
            inputs: {
                translate: "translate",
                translateParams: "translateParams"
            }
        }), t
    })(),
    $d = (() => {
        class t {
            constructor(n, r) {
                this.translate = n, this._ref = r, this.value = "", this.lastKey = null, this.lastParams = []
            }
            updateValue(n, r, i) {
                let s = o => {
                    this.value = o !== void 0 ? o : n, this.lastKey = n, this._ref.markForCheck()
                };
                if (i) {
                    let o = this.translate.getParsedResult(i, n, r);
                    Rt(o.subscribe) ? o.subscribe(s) : s(o)
                }
                this.translate.get(n, r).subscribe(s)
            }
            transform(n, ...r) {
                if (!n || !n.length) return n;
                if (Ya(n, this.lastKey) && Ya(r, this.lastParams)) return this.value;
                let i;
                if (nn(r[0]) && r.length)
                    if (typeof r[0] == "string" && r[0].length) {
                        let s = r[0].replace(/(\')?([a-zA-Z0-9_]+)(\')?(\s)?:/g, '"$2":').replace(/:(\s)?(\')(.*?)(\')/g, ':"$3"');
                        try {
                            i = JSON.parse(s)
                        } catch {
                            throw new SyntaxError(`Wrong parameter in TranslatePipe. Expected a valid Object, received: ${r[0]}`)
                        }
                    } else typeof r[0] == "object" && !Array.isArray(r[0]) && (i = r[0]);
                return this.lastKey = n, this.lastParams = r, this.updateValue(n, i), this._dispose(), this.onTranslationChange || (this.onTranslationChange = this.translate.onTranslationChange.subscribe(s => {
                    this.lastKey && s.lang === this.translate.currentLang && (this.lastKey = null, this.updateValue(n, i, s.translations))
                })), this.onLangChange || (this.onLangChange = this.translate.onLangChange.subscribe(s => {
                    this.lastKey && (this.lastKey = null, this.updateValue(n, i, s.translations))
                })), this.onDefaultLangChange || (this.onDefaultLangChange = this.translate.onDefaultLangChange.subscribe(() => {
                    this.lastKey && (this.lastKey = null, this.updateValue(n, i))
                })), this.value
            }
            _dispose() {
                typeof this.onTranslationChange < "u" && (this.onTranslationChange.unsubscribe(), this.onTranslationChange = void 0), typeof this.onLangChange < "u" && (this.onLangChange.unsubscribe(), this.onLangChange = void 0), typeof this.onDefaultLangChange < "u" && (this.onDefaultLangChange.unsubscribe(), this.onDefaultLangChange = void 0)
            }
            ngOnDestroy() {
                this._dispose()
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(O(rr, 16), O(xt, 16))
        }, t.\u0275pipe = zg({
            name: "translate",
            type: t,
            pure: !1
        }), t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac
        }), t
    })(),
    mS = (() => {
        class t {
            static forRoot(n = {}) {
                return {
                    ngModule: t,
                    providers: [n.loader || {
                        provide: hi,
                        useClass: dS
                    }, n.compiler || {
                        provide: xo,
                        useClass: pS
                    }, n.parser || {
                        provide: To,
                        useClass: fS
                    }, n.missingTranslationHandler || {
                        provide: Ka,
                        useClass: hS
                    }, zd, {
                        provide: ky,
                        useValue: n.isolate
                    }, {
                        provide: Py,
                        useValue: n.useDefaultLang
                    }, {
                        provide: Vy,
                        useValue: n.extend
                    }, {
                        provide: Ly,
                        useValue: n.defaultLanguage
                    }, rr]
                }
            }
            static forChild(n = {}) {
                return {
                    ngModule: t,
                    providers: [n.loader || {
                        provide: hi,
                        useClass: dS
                    }, n.compiler || {
                        provide: xo,
                        useClass: pS
                    }, n.parser || {
                        provide: To,
                        useClass: fS
                    }, n.missingTranslationHandler || {
                        provide: Ka,
                        useClass: hS
                    }, {
                        provide: ky,
                        useValue: n.isolate
                    }, {
                        provide: Py,
                        useValue: n.useDefaultLang
                    }, {
                        provide: Vy,
                        useValue: n.extend
                    }, {
                        provide: Ly,
                        useValue: n.defaultLanguage
                    }, rr]
                }
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)
        }, t.\u0275mod = xe({
            type: t
        }), t.\u0275inj = Te({}), t
    })();
var Wd = class {
    constructor(e, n = "/assets/i18n/", r = ".json") {
        this.http = e, this.prefix = n, this.suffix = r
    }
    getTranslation(e) {
        return this.http.get(`${this.prefix}${e}${this.suffix}`)
    }
};
var SS = (() => {
        let e = class e {
            constructor(r, i) {
                this._renderer = r, this._elementRef = i, this.onChange = s => {}, this.onTouched = () => {}
            }
            setProperty(r, i) {
                this._renderer.setProperty(this._elementRef.nativeElement, r, i)
            }
            registerOnTouched(r) {
                this.onTouched = r
            }
            registerOnChange(r) {
                this.onChange = r
            }
            setDisabledState(r) {
                this.setProperty("disabled", r)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(O(Wt), O(je))
        }, e.\u0275dir = et({
            type: e
        });
        let t = e;
        return t
    })(),
    MS = (() => {
        let e = class e extends SS {};
        e.\u0275fac = (() => {
            let r;
            return function(s) {
                return (r || (r = Xn(e)))(s || e)
            }
        })(), e.\u0275dir = et({
            type: e,
            features: [Ki]
        });
        let t = e;
        return t
    })(),
    Wy = new R("");
var iV = {
    provide: Wy,
    useExisting: uo(() => Yd),
    multi: !0
};

function sV() {
    let t = er() ? er().getUserAgent() : "";
    return /android (\d+)/.test(t.toLowerCase())
}
var oV = new R(""),
    Yd = (() => {
        let e = class e extends SS {
            constructor(r, i, s) {
                super(r, i), this._compositionMode = s, this._composing = !1, this._compositionMode == null && (this._compositionMode = !sV())
            }
            writeValue(r) {
                let i = r ? ? "";
                this.setProperty("value", i)
            }
            _handleInput(r) {
                (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(r)
            }
            _compositionStart() {
                this._composing = !0
            }
            _compositionEnd(r) {
                this._composing = !1, this._compositionMode && this.onChange(r)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(O(Wt), O(je), O(oV, 8))
        }, e.\u0275dir = et({
            type: e,
            selectors: [
                ["input", "formControlName", "", 3, "type", "checkbox"],
                ["textarea", "formControlName", ""],
                ["input", "formControl", "", 3, "type", "checkbox"],
                ["textarea", "formControl", ""],
                ["input", "ngModel", "", 3, "type", "checkbox"],
                ["textarea", "ngModel", ""],
                ["", "ngDefaultControl", ""]
            ],
            hostBindings: function(i, s) {
                i & 1 && we("input", function(a) {
                    return s._handleInput(a.target.value)
                })("blur", function() {
                    return s.onTouched()
                })("compositionstart", function() {
                    return s._compositionStart()
                })("compositionend", function(a) {
                    return s._compositionEnd(a.target.value)
                })
            },
            features: [Ji([iV]), Ki]
        });
        let t = e;
        return t
    })();

function fi(t) {
    return t == null || (typeof t == "string" || Array.isArray(t)) && t.length === 0
}

function IS(t) {
    return t != null && typeof t.length == "number"
}
var aV = new R(""),
    cV = new R(""),
    lV = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
    Zd = class {
        static min(e) {
            return uV(e)
        }
        static max(e) {
            return dV(e)
        }
        static required(e) {
            return hV(e)
        }
        static requiredTrue(e) {
            return fV(e)
        }
        static email(e) {
            return pV(e)
        }
        static minLength(e) {
            return gV(e)
        }
        static maxLength(e) {
            return mV(e)
        }
        static pattern(e) {
            return yV(e)
        }
        static nullValidator(e) {
            return TS(e)
        }
        static compose(e) {
            return FS(e)
        }
        static composeAsync(e) {
            return PS(e)
        }
    };

function uV(t) {
    return e => {
        if (fi(e.value) || fi(t)) return null;
        let n = parseFloat(e.value);
        return !isNaN(n) && n < t ? {
            min: {
                min: t,
                actual: e.value
            }
        } : null
    }
}

function dV(t) {
    return e => {
        if (fi(e.value) || fi(t)) return null;
        let n = parseFloat(e.value);
        return !isNaN(n) && n > t ? {
            max: {
                max: t,
                actual: e.value
            }
        } : null
    }
}

function hV(t) {
    return fi(t.value) ? {
        required: !0
    } : null
}

function fV(t) {
    return t.value === !0 ? null : {
        required: !0
    }
}

function pV(t) {
    return fi(t.value) || lV.test(t.value) ? null : {
        email: !0
    }
}

function gV(t) {
    return e => fi(e.value) || !IS(e.value) ? null : e.value.length < t ? {
        minlength: {
            requiredLength: t,
            actualLength: e.value.length
        }
    } : null
}

function mV(t) {
    return e => IS(e.value) && e.value.length > t ? {
        maxlength: {
            requiredLength: t,
            actualLength: e.value.length
        }
    } : null
}

function yV(t) {
    if (!t) return TS;
    let e, n;
    return typeof t == "string" ? (n = "", t.charAt(0) !== "^" && (n += "^"), n += t, t.charAt(t.length - 1) !== "$" && (n += "$"), e = new RegExp(n)) : (n = t.toString(), e = t), r => {
        if (fi(r.value)) return null;
        let i = r.value;
        return e.test(i) ? null : {
            pattern: {
                requiredPattern: n,
                actualValue: i
            }
        }
    }
}

function TS(t) {
    return null
}

function xS(t) {
    return t != null
}

function AS(t) {
    return Xi(t) ? le(t) : t
}

function NS(t) {
    let e = {};
    return t.forEach(n => {
        e = n != null ? _(_({}, e), n) : e
    }), Object.keys(e).length === 0 ? null : e
}

function RS(t, e) {
    return e.map(n => n(t))
}

function vV(t) {
    return !t.validate
}

function OS(t) {
    return t.map(e => vV(e) ? e : n => e.validate(n))
}

function FS(t) {
    if (!t) return null;
    let e = t.filter(xS);
    return e.length == 0 ? null : function(n) {
        return NS(RS(n, e))
    }
}

function kS(t) {
    return t != null ? FS(OS(t)) : null
}

function PS(t) {
    if (!t) return null;
    let e = t.filter(xS);
    return e.length == 0 ? null : function(n) {
        let r = RS(n, e).map(AS);
        return ha(r).pipe(Z(NS))
    }
}

function LS(t) {
    return t != null ? PS(OS(t)) : null
}

function yS(t, e) {
    return t === null ? [e] : Array.isArray(t) ? [...t, e] : [t, e]
}

function wV(t) {
    return t._rawValidators
}

function _V(t) {
    return t._rawAsyncValidators
}

function Uy(t) {
    return t ? Array.isArray(t) ? t : [t] : []
}

function Qd(t, e) {
    return Array.isArray(t) ? t.includes(e) : t === e
}

function vS(t, e) {
    let n = Uy(e);
    return Uy(t).forEach(i => {
        Qd(n, i) || n.push(i)
    }), n
}

function wS(t, e) {
    return Uy(e).filter(n => !Qd(t, n))
}
var qd = class {
        constructor() {
            this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = []
        }
        get value() {
            return this.control ? this.control.value : null
        }
        get valid() {
            return this.control ? this.control.valid : null
        }
        get invalid() {
            return this.control ? this.control.invalid : null
        }
        get pending() {
            return this.control ? this.control.pending : null
        }
        get disabled() {
            return this.control ? this.control.disabled : null
        }
        get enabled() {
            return this.control ? this.control.enabled : null
        }
        get errors() {
            return this.control ? this.control.errors : null
        }
        get pristine() {
            return this.control ? this.control.pristine : null
        }
        get dirty() {
            return this.control ? this.control.dirty : null
        }
        get touched() {
            return this.control ? this.control.touched : null
        }
        get status() {
            return this.control ? this.control.status : null
        }
        get untouched() {
            return this.control ? this.control.untouched : null
        }
        get statusChanges() {
            return this.control ? this.control.statusChanges : null
        }
        get valueChanges() {
            return this.control ? this.control.valueChanges : null
        }
        get path() {
            return null
        }
        _setValidators(e) {
            this._rawValidators = e || [], this._composedValidatorFn = kS(this._rawValidators)
        }
        _setAsyncValidators(e) {
            this._rawAsyncValidators = e || [], this._composedAsyncValidatorFn = LS(this._rawAsyncValidators)
        }
        get validator() {
            return this._composedValidatorFn || null
        }
        get asyncValidator() {
            return this._composedAsyncValidatorFn || null
        }
        _registerOnDestroy(e) {
            this._onDestroyCallbacks.push(e)
        }
        _invokeOnDestroyCallbacks() {
            this._onDestroyCallbacks.forEach(e => e()), this._onDestroyCallbacks = []
        }
        reset(e = void 0) {
            this.control && this.control.reset(e)
        }
        hasError(e, n) {
            return this.control ? this.control.hasError(e, n) : !1
        }
        getError(e, n) {
            return this.control ? this.control.getError(e, n) : null
        }
    },
    jy = class extends qd {
        get formDirective() {
            return null
        }
        get path() {
            return null
        }
    },
    ec = class extends qd {
        constructor() {
            super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null
        }
    },
    By = class {
        constructor(e) {
            this._cd = e
        }
        get isTouched() {
            return !!this._cd ? .control ? .touched
        }
        get isUntouched() {
            return !!this._cd ? .control ? .untouched
        }
        get isPristine() {
            return !!this._cd ? .control ? .pristine
        }
        get isDirty() {
            return !!this._cd ? .control ? .dirty
        }
        get isValid() {
            return !!this._cd ? .control ? .valid
        }
        get isInvalid() {
            return !!this._cd ? .control ? .invalid
        }
        get isPending() {
            return !!this._cd ? .control ? .pending
        }
        get isSubmitted() {
            return !!this._cd ? .submitted
        }
    },
    bV = {
        "[class.ng-untouched]": "isUntouched",
        "[class.ng-touched]": "isTouched",
        "[class.ng-pristine]": "isPristine",
        "[class.ng-dirty]": "isDirty",
        "[class.ng-valid]": "isValid",
        "[class.ng-invalid]": "isInvalid",
        "[class.ng-pending]": "isPending"
    },
    xK = Q(_({}, bV), {
        "[class.ng-submitted]": "isSubmitted"
    }),
    VS = (() => {
        let e = class e extends By {
            constructor(r) {
                super(r)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(O(ec, 2))
        }, e.\u0275dir = et({
            type: e,
            selectors: [
                ["", "formControlName", ""],
                ["", "ngModel", ""],
                ["", "formControl", ""]
            ],
            hostVars: 14,
            hostBindings: function(i, s) {
                i & 2 && wo("ng-untouched", s.isUntouched)("ng-touched", s.isTouched)("ng-pristine", s.isPristine)("ng-dirty", s.isDirty)("ng-valid", s.isValid)("ng-invalid", s.isInvalid)("ng-pending", s.isPending)
            },
            features: [Ki]
        });
        let t = e;
        return t
    })();
var Ja = "VALID",
    Hd = "INVALID",
    Ao = "PENDING",
    Xa = "DISABLED";

function Hy(t) {
    return (Jd(t) ? t.validators : t) || null
}

function DV(t) {
    return Array.isArray(t) ? kS(t) : t || null
}

function Gy(t, e) {
    return (Jd(e) ? e.asyncValidators : t) || null
}

function EV(t) {
    return Array.isArray(t) ? LS(t) : t || null
}

function Jd(t) {
    return t != null && !Array.isArray(t) && typeof t == "object"
}

function US(t, e, n) {
    let r = t.controls;
    if (!(e ? Object.keys(r) : r).length) throw new S(1e3, "");
    if (!r[n]) throw new S(1001, "")
}

function jS(t, e, n) {
    t._forEachChild((r, i) => {
        if (n[i] === void 0) throw new S(1002, "")
    })
}
var No = class {
        constructor(e, n) {
            this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => {}, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._assignValidators(e), this._assignAsyncValidators(n)
        }
        get validator() {
            return this._composedValidatorFn
        }
        set validator(e) {
            this._rawValidators = this._composedValidatorFn = e
        }
        get asyncValidator() {
            return this._composedAsyncValidatorFn
        }
        set asyncValidator(e) {
            this._rawAsyncValidators = this._composedAsyncValidatorFn = e
        }
        get parent() {
            return this._parent
        }
        get valid() {
            return this.status === Ja
        }
        get invalid() {
            return this.status === Hd
        }
        get pending() {
            return this.status == Ao
        }
        get disabled() {
            return this.status === Xa
        }
        get enabled() {
            return this.status !== Xa
        }
        get dirty() {
            return !this.pristine
        }
        get untouched() {
            return !this.touched
        }
        get updateOn() {
            return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change"
        }
        setValidators(e) {
            this._assignValidators(e)
        }
        setAsyncValidators(e) {
            this._assignAsyncValidators(e)
        }
        addValidators(e) {
            this.setValidators(vS(e, this._rawValidators))
        }
        addAsyncValidators(e) {
            this.setAsyncValidators(vS(e, this._rawAsyncValidators))
        }
        removeValidators(e) {
            this.setValidators(wS(e, this._rawValidators))
        }
        removeAsyncValidators(e) {
            this.setAsyncValidators(wS(e, this._rawAsyncValidators))
        }
        hasValidator(e) {
            return Qd(this._rawValidators, e)
        }
        hasAsyncValidator(e) {
            return Qd(this._rawAsyncValidators, e)
        }
        clearValidators() {
            this.validator = null
        }
        clearAsyncValidators() {
            this.asyncValidator = null
        }
        markAsTouched(e = {}) {
            this.touched = !0, this._parent && !e.onlySelf && this._parent.markAsTouched(e)
        }
        markAllAsTouched() {
            this.markAsTouched({
                onlySelf: !0
            }), this._forEachChild(e => e.markAllAsTouched())
        }
        markAsUntouched(e = {}) {
            this.touched = !1, this._pendingTouched = !1, this._forEachChild(n => {
                n.markAsUntouched({
                    onlySelf: !0
                })
            }), this._parent && !e.onlySelf && this._parent._updateTouched(e)
        }
        markAsDirty(e = {}) {
            this.pristine = !1, this._parent && !e.onlySelf && this._parent.markAsDirty(e)
        }
        markAsPristine(e = {}) {
            this.pristine = !0, this._pendingDirty = !1, this._forEachChild(n => {
                n.markAsPristine({
                    onlySelf: !0
                })
            }), this._parent && !e.onlySelf && this._parent._updatePristine(e)
        }
        markAsPending(e = {}) {
            this.status = Ao, e.emitEvent !== !1 && this.statusChanges.emit(this.status), this._parent && !e.onlySelf && this._parent.markAsPending(e)
        }
        disable(e = {}) {
            let n = this._parentMarkedDirty(e.onlySelf);
            this.status = Xa, this.errors = null, this._forEachChild(r => {
                r.disable(Q(_({}, e), {
                    onlySelf: !0
                }))
            }), this._updateValue(), e.emitEvent !== !1 && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Q(_({}, e), {
                skipPristineCheck: n
            })), this._onDisabledChange.forEach(r => r(!0))
        }
        enable(e = {}) {
            let n = this._parentMarkedDirty(e.onlySelf);
            this.status = Ja, this._forEachChild(r => {
                r.enable(Q(_({}, e), {
                    onlySelf: !0
                }))
            }), this.updateValueAndValidity({
                onlySelf: !0,
                emitEvent: e.emitEvent
            }), this._updateAncestors(Q(_({}, e), {
                skipPristineCheck: n
            })), this._onDisabledChange.forEach(r => r(!1))
        }
        _updateAncestors(e) {
            this._parent && !e.onlySelf && (this._parent.updateValueAndValidity(e), e.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched())
        }
        setParent(e) {
            this._parent = e
        }
        getRawValue() {
            return this.value
        }
        updateValueAndValidity(e = {}) {
            this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === Ja || this.status === Ao) && this._runAsyncValidator(e.emitEvent)), e.emitEvent !== !1 && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !e.onlySelf && this._parent.updateValueAndValidity(e)
        }
        _updateTreeValidity(e = {
            emitEvent: !0
        }) {
            this._forEachChild(n => n._updateTreeValidity(e)), this.updateValueAndValidity({
                onlySelf: !0,
                emitEvent: e.emitEvent
            })
        }
        _setInitialStatus() {
            this.status = this._allControlsDisabled() ? Xa : Ja
        }
        _runValidator() {
            return this.validator ? this.validator(this) : null
        }
        _runAsyncValidator(e) {
            if (this.asyncValidator) {
                this.status = Ao, this._hasOwnPendingAsyncValidator = !0;
                let n = AS(this.asyncValidator(this));
                this._asyncValidationSubscription = n.subscribe(r => {
                    this._hasOwnPendingAsyncValidator = !1, this.setErrors(r, {
                        emitEvent: e
                    })
                })
            }
        }
        _cancelExistingSubscription() {
            this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1)
        }
        setErrors(e, n = {}) {
            this.errors = e, this._updateControlsErrors(n.emitEvent !== !1)
        }
        get(e) {
            let n = e;
            return n == null || (Array.isArray(n) || (n = n.split(".")), n.length === 0) ? null : n.reduce((r, i) => r && r._find(i), this)
        }
        getError(e, n) {
            let r = n ? this.get(n) : this;
            return r && r.errors ? r.errors[e] : null
        }
        hasError(e, n) {
            return !!this.getError(e, n)
        }
        get root() {
            let e = this;
            for (; e._parent;) e = e._parent;
            return e
        }
        _updateControlsErrors(e) {
            this.status = this._calculateStatus(), e && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(e)
        }
        _initObservables() {
            this.valueChanges = new oe, this.statusChanges = new oe
        }
        _calculateStatus() {
            return this._allControlsDisabled() ? Xa : this.errors ? Hd : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Ao) ? Ao : this._anyControlsHaveStatus(Hd) ? Hd : Ja
        }
        _anyControlsHaveStatus(e) {
            return this._anyControls(n => n.status === e)
        }
        _anyControlsDirty() {
            return this._anyControls(e => e.dirty)
        }
        _anyControlsTouched() {
            return this._anyControls(e => e.touched)
        }
        _updatePristine(e = {}) {
            this.pristine = !this._anyControlsDirty(), this._parent && !e.onlySelf && this._parent._updatePristine(e)
        }
        _updateTouched(e = {}) {
            this.touched = this._anyControlsTouched(), this._parent && !e.onlySelf && this._parent._updateTouched(e)
        }
        _registerOnCollectionChange(e) {
            this._onCollectionChange = e
        }
        _setUpdateStrategy(e) {
            Jd(e) && e.updateOn != null && (this._updateOn = e.updateOn)
        }
        _parentMarkedDirty(e) {
            let n = this._parent && this._parent.dirty;
            return !e && !!n && !this._parent._anyControlsDirty()
        }
        _find(e) {
            return null
        }
        _assignValidators(e) {
            this._rawValidators = Array.isArray(e) ? e.slice() : e, this._composedValidatorFn = DV(this._rawValidators)
        }
        _assignAsyncValidators(e) {
            this._rawAsyncValidators = Array.isArray(e) ? e.slice() : e, this._composedAsyncValidatorFn = EV(this._rawAsyncValidators)
        }
    },
    Kd = class extends No {
        constructor(e, n, r) {
            super(Hy(n), Gy(r, n)), this.controls = e, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({
                onlySelf: !0,
                emitEvent: !!this.asyncValidator
            })
        }
        registerControl(e, n) {
            return this.controls[e] ? this.controls[e] : (this.controls[e] = n, n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange), n)
        }
        addControl(e, n, r = {}) {
            this.registerControl(e, n), this.updateValueAndValidity({
                emitEvent: r.emitEvent
            }), this._onCollectionChange()
        }
        removeControl(e, n = {}) {
            this.controls[e] && this.controls[e]._registerOnCollectionChange(() => {}), delete this.controls[e], this.updateValueAndValidity({
                emitEvent: n.emitEvent
            }), this._onCollectionChange()
        }
        setControl(e, n, r = {}) {
            this.controls[e] && this.controls[e]._registerOnCollectionChange(() => {}), delete this.controls[e], n && this.registerControl(e, n), this.updateValueAndValidity({
                emitEvent: r.emitEvent
            }), this._onCollectionChange()
        }
        contains(e) {
            return this.controls.hasOwnProperty(e) && this.controls[e].enabled
        }
        setValue(e, n = {}) {
            jS(this, !0, e), Object.keys(e).forEach(r => {
                US(this, !0, r), this.controls[r].setValue(e[r], {
                    onlySelf: !0,
                    emitEvent: n.emitEvent
                })
            }), this.updateValueAndValidity(n)
        }
        patchValue(e, n = {}) {
            e != null && (Object.keys(e).forEach(r => {
                let i = this.controls[r];
                i && i.patchValue(e[r], {
                    onlySelf: !0,
                    emitEvent: n.emitEvent
                })
            }), this.updateValueAndValidity(n))
        }
        reset(e = {}, n = {}) {
            this._forEachChild((r, i) => {
                r.reset(e ? e[i] : null, {
                    onlySelf: !0,
                    emitEvent: n.emitEvent
                })
            }), this._updatePristine(n), this._updateTouched(n), this.updateValueAndValidity(n)
        }
        getRawValue() {
            return this._reduceChildren({}, (e, n, r) => (e[r] = n.getRawValue(), e))
        }
        _syncPendingControls() {
            let e = this._reduceChildren(!1, (n, r) => r._syncPendingControls() ? !0 : n);
            return e && this.updateValueAndValidity({
                onlySelf: !0
            }), e
        }
        _forEachChild(e) {
            Object.keys(this.controls).forEach(n => {
                let r = this.controls[n];
                r && e(r, n)
            })
        }
        _setUpControls() {
            this._forEachChild(e => {
                e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange)
            })
        }
        _updateValue() {
            this.value = this._reduceValue()
        }
        _anyControls(e) {
            for (let [n, r] of Object.entries(this.controls))
                if (this.contains(n) && e(r)) return !0;
            return !1
        }
        _reduceValue() {
            let e = {};
            return this._reduceChildren(e, (n, r, i) => ((r.enabled || this.disabled) && (n[i] = r.value), n))
        }
        _reduceChildren(e, n) {
            let r = e;
            return this._forEachChild((i, s) => {
                r = n(r, i, s)
            }), r
        }
        _allControlsDisabled() {
            for (let e of Object.keys(this.controls))
                if (this.controls[e].enabled) return !1;
            return Object.keys(this.controls).length > 0 || this.disabled
        }
        _find(e) {
            return this.controls.hasOwnProperty(e) ? this.controls[e] : null
        }
    };
var zy = class extends Kd {};
var Zy = new R("CallSetDisabledState", {
        providedIn: "root",
        factory: () => Xd
    }),
    Xd = "always";

function CV(t, e) {
    return [...e.path, t]
}

function SV(t, e, n = Xd) {
    IV(t, e), e.valueAccessor.writeValue(t.value), (t.disabled || n === "always") && e.valueAccessor.setDisabledState ? .(t.disabled), TV(t, e), AV(t, e), xV(t, e), MV(t, e)
}

function _S(t, e) {
    t.forEach(n => {
        n.registerOnValidatorChange && n.registerOnValidatorChange(e)
    })
}

function MV(t, e) {
    if (e.valueAccessor.setDisabledState) {
        let n = r => {
            e.valueAccessor.setDisabledState(r)
        };
        t.registerOnDisabledChange(n), e._registerOnDestroy(() => {
            t._unregisterOnDisabledChange(n)
        })
    }
}

function IV(t, e) {
    let n = wV(t);
    e.validator !== null ? t.setValidators(yS(n, e.validator)) : typeof n == "function" && t.setValidators([n]);
    let r = _V(t);
    e.asyncValidator !== null ? t.setAsyncValidators(yS(r, e.asyncValidator)) : typeof r == "function" && t.setAsyncValidators([r]);
    let i = () => t.updateValueAndValidity();
    _S(e._rawValidators, i), _S(e._rawAsyncValidators, i)
}

function TV(t, e) {
    e.valueAccessor.registerOnChange(n => {
        t._pendingValue = n, t._pendingChange = !0, t._pendingDirty = !0, t.updateOn === "change" && BS(t, e)
    })
}

function xV(t, e) {
    e.valueAccessor.registerOnTouched(() => {
        t._pendingTouched = !0, t.updateOn === "blur" && t._pendingChange && BS(t, e), t.updateOn !== "submit" && t.markAsTouched()
    })
}

function BS(t, e) {
    t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, {
        emitModelToViewChange: !1
    }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1
}

function AV(t, e) {
    let n = (r, i) => {
        e.valueAccessor.writeValue(r), i && e.viewToModelUpdate(r)
    };
    t.registerOnChange(n), e._registerOnDestroy(() => {
        t._unregisterOnChange(n)
    })
}

function NV(t, e) {
    if (!t.hasOwnProperty("model")) return !1;
    let n = t.model;
    return n.isFirstChange() ? !0 : !Object.is(e, n.currentValue)
}

function RV(t) {
    return Object.getPrototypeOf(t.constructor) === MS
}

function OV(t, e) {
    if (!e) return null;
    Array.isArray(e);
    let n, r, i;
    return e.forEach(s => {
        s.constructor === Yd ? n = s : RV(s) ? r = s : i = s
    }), i || r || n || null
}

function bS(t, e) {
    let n = t.indexOf(e);
    n > -1 && t.splice(n, 1)
}

function DS(t) {
    return typeof t == "object" && t !== null && Object.keys(t).length === 2 && "value" in t && "disabled" in t
}
var Gd = class extends No {
    constructor(e = null, n, r) {
        super(Hy(n), Gy(r, n)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(e), this._setUpdateStrategy(n), this._initObservables(), this.updateValueAndValidity({
            onlySelf: !0,
            emitEvent: !!this.asyncValidator
        }), Jd(n) && (n.nonNullable || n.initialValueIsDefault) && (DS(e) ? this.defaultValue = e.value : this.defaultValue = e)
    }
    setValue(e, n = {}) {
        this.value = this._pendingValue = e, this._onChange.length && n.emitModelToViewChange !== !1 && this._onChange.forEach(r => r(this.value, n.emitViewToModelChange !== !1)), this.updateValueAndValidity(n)
    }
    patchValue(e, n = {}) {
        this.setValue(e, n)
    }
    reset(e = this.defaultValue, n = {}) {
        this._applyFormState(e), this.markAsPristine(n), this.markAsUntouched(n), this.setValue(this.value, n), this._pendingChange = !1
    }
    _updateValue() {}
    _anyControls(e) {
        return !1
    }
    _allControlsDisabled() {
        return this.disabled
    }
    registerOnChange(e) {
        this._onChange.push(e)
    }
    _unregisterOnChange(e) {
        bS(this._onChange, e)
    }
    registerOnDisabledChange(e) {
        this._onDisabledChange.push(e)
    }
    _unregisterOnDisabledChange(e) {
        bS(this._onDisabledChange, e)
    }
    _forEachChild(e) {}
    _syncPendingControls() {
        return this.updateOn === "submit" && (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), this._pendingChange) ? (this.setValue(this._pendingValue, {
            onlySelf: !0,
            emitModelToViewChange: !1
        }), !0) : !1
    }
    _applyFormState(e) {
        DS(e) ? (this.value = this._pendingValue = e.value, e.disabled ? this.disable({
            onlySelf: !0,
            emitEvent: !1
        }) : this.enable({
            onlySelf: !0,
            emitEvent: !1
        })) : this.value = this._pendingValue = e
    }
};
var FV = {
        provide: ec,
        useExisting: uo(() => Qy)
    },
    ES = Promise.resolve(),
    Qy = (() => {
        let e = class e extends ec {
            constructor(r, i, s, o, a, c) {
                super(), this._changeDetectorRef = a, this.callSetDisabledState = c, this.control = new Gd, this._registered = !1, this.name = "", this.update = new oe, this._parent = r, this._setValidators(i), this._setAsyncValidators(s), this.valueAccessor = OV(this, o)
            }
            ngOnChanges(r) {
                if (this._checkForErrors(), !this._registered || "name" in r) {
                    if (this._registered && (this._checkName(), this.formDirective)) {
                        let i = r.name.previousValue;
                        this.formDirective.removeControl({
                            name: i,
                            path: this._getPath(i)
                        })
                    }
                    this._setUpControl()
                }
                "isDisabled" in r && this._updateDisabled(r), NV(r, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model)
            }
            ngOnDestroy() {
                this.formDirective && this.formDirective.removeControl(this)
            }
            get path() {
                return this._getPath(this.name)
            }
            get formDirective() {
                return this._parent ? this._parent.formDirective : null
            }
            viewToModelUpdate(r) {
                this.viewModel = r, this.update.emit(r)
            }
            _setUpControl() {
                this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0
            }
            _setUpdateStrategy() {
                this.options && this.options.updateOn != null && (this.control._updateOn = this.options.updateOn)
            }
            _isStandalone() {
                return !this._parent || !!(this.options && this.options.standalone)
            }
            _setUpStandalone() {
                SV(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({
                    emitEvent: !1
                })
            }
            _checkForErrors() {
                this._isStandalone() || this._checkParentType(), this._checkName()
            }
            _checkParentType() {}
            _checkName() {
                this.options && this.options.name && (this.name = this.options.name), !this._isStandalone() && this.name
            }
            _updateValue(r) {
                ES.then(() => {
                    this.control.setValue(r, {
                        emitViewToModelChange: !1
                    }), this._changeDetectorRef ? .markForCheck()
                })
            }
            _updateDisabled(r) {
                let i = r.isDisabled.currentValue,
                    s = i !== 0 && ud(i);
                ES.then(() => {
                    s && !this.control.disabled ? this.control.disable() : !s && this.control.disabled && this.control.enable(), this._changeDetectorRef ? .markForCheck()
                })
            }
            _getPath(r) {
                return this._parent ? CV(r, this._parent) : [r]
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(O(jy, 9), O(aV, 10), O(cV, 10), O(Wy, 10), O(xt, 8), O(Zy, 8))
        }, e.\u0275dir = et({
            type: e,
            selectors: [
                ["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]
            ],
            inputs: {
                name: "name",
                isDisabled: [Vt.None, "disabled", "isDisabled"],
                model: [Vt.None, "ngModel", "model"],
                options: [Vt.None, "ngModelOptions", "options"]
            },
            outputs: {
                update: "ngModelChange"
            },
            exportAs: ["ngModel"],
            features: [Ji([FV]), Ki, Vn]
        });
        let t = e;
        return t
    })();
var kV = {
        provide: Wy,
        useExisting: uo(() => qy),
        multi: !0
    },
    qy = (() => {
        let e = class e extends MS {
            writeValue(r) {
                let i = r ? ? "";
                this.setProperty("value", i)
            }
            registerOnChange(r) {
                this.onChange = i => {
                    r(i == "" ? null : parseFloat(i))
                }
            }
        };
        e.\u0275fac = (() => {
            let r;
            return function(s) {
                return (r || (r = Xn(e)))(s || e)
            }
        })(), e.\u0275dir = et({
            type: e,
            selectors: [
                ["input", "type", "number", "formControlName", ""],
                ["input", "type", "number", "formControl", ""],
                ["input", "type", "number", "ngModel", ""]
            ],
            hostBindings: function(i, s) {
                i & 1 && we("input", function(a) {
                    return s.onChange(a.target.value)
                })("blur", function() {
                    return s.onTouched()
                })
            },
            features: [Ji([kV]), Ki]
        });
        let t = e;
        return t
    })();
var PV = new R("");
var zS = (() => {
        let e = class e {};
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275mod = xe({
            type: e
        }), e.\u0275inj = Te({});
        let t = e;
        return t
    })(),
    $y = class extends No {
        constructor(e, n, r) {
            super(Hy(n), Gy(r, n)), this.controls = e, this._initObservables(), this._setUpdateStrategy(n), this._setUpControls(), this.updateValueAndValidity({
                onlySelf: !0,
                emitEvent: !!this.asyncValidator
            })
        }
        at(e) {
            return this.controls[this._adjustIndex(e)]
        }
        push(e, n = {}) {
            this.controls.push(e), this._registerControl(e), this.updateValueAndValidity({
                emitEvent: n.emitEvent
            }), this._onCollectionChange()
        }
        insert(e, n, r = {}) {
            this.controls.splice(e, 0, n), this._registerControl(n), this.updateValueAndValidity({
                emitEvent: r.emitEvent
            })
        }
        removeAt(e, n = {}) {
            let r = this._adjustIndex(e);
            r < 0 && (r = 0), this.controls[r] && this.controls[r]._registerOnCollectionChange(() => {}), this.controls.splice(r, 1), this.updateValueAndValidity({
                emitEvent: n.emitEvent
            })
        }
        setControl(e, n, r = {}) {
            let i = this._adjustIndex(e);
            i < 0 && (i = 0), this.controls[i] && this.controls[i]._registerOnCollectionChange(() => {}), this.controls.splice(i, 1), n && (this.controls.splice(i, 0, n), this._registerControl(n)), this.updateValueAndValidity({
                emitEvent: r.emitEvent
            }), this._onCollectionChange()
        }
        get length() {
            return this.controls.length
        }
        setValue(e, n = {}) {
            jS(this, !1, e), e.forEach((r, i) => {
                US(this, !1, i), this.at(i).setValue(r, {
                    onlySelf: !0,
                    emitEvent: n.emitEvent
                })
            }), this.updateValueAndValidity(n)
        }
        patchValue(e, n = {}) {
            e != null && (e.forEach((r, i) => {
                this.at(i) && this.at(i).patchValue(r, {
                    onlySelf: !0,
                    emitEvent: n.emitEvent
                })
            }), this.updateValueAndValidity(n))
        }
        reset(e = [], n = {}) {
            this._forEachChild((r, i) => {
                r.reset(e[i], {
                    onlySelf: !0,
                    emitEvent: n.emitEvent
                })
            }), this._updatePristine(n), this._updateTouched(n), this.updateValueAndValidity(n)
        }
        getRawValue() {
            return this.controls.map(e => e.getRawValue())
        }
        clear(e = {}) {
            this.controls.length < 1 || (this._forEachChild(n => n._registerOnCollectionChange(() => {})), this.controls.splice(0), this.updateValueAndValidity({
                emitEvent: e.emitEvent
            }))
        }
        _adjustIndex(e) {
            return e < 0 ? e + this.length : e
        }
        _syncPendingControls() {
            let e = this.controls.reduce((n, r) => r._syncPendingControls() ? !0 : n, !1);
            return e && this.updateValueAndValidity({
                onlySelf: !0
            }), e
        }
        _forEachChild(e) {
            this.controls.forEach((n, r) => {
                e(n, r)
            })
        }
        _updateValue() {
            this.value = this.controls.filter(e => e.enabled || this.disabled).map(e => e.value)
        }
        _anyControls(e) {
            return this.controls.some(n => n.enabled && e(n))
        }
        _setUpControls() {
            this._forEachChild(e => this._registerControl(e))
        }
        _allControlsDisabled() {
            for (let e of this.controls)
                if (e.enabled) return !1;
            return this.controls.length > 0 || this.disabled
        }
        _registerControl(e) {
            e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange)
        }
        _find(e) {
            return this.at(e) ? ? null
        }
    };

function CS(t) {
    return !!t && (t.asyncValidators !== void 0 || t.validators !== void 0 || t.updateOn !== void 0)
}
var $S = (() => {
    let e = class e {
        constructor() {
            this.useNonNullable = !1
        }
        get nonNullable() {
            let r = new e;
            return r.useNonNullable = !0, r
        }
        group(r, i = null) {
            let s = this._reduceControls(r),
                o = {};
            return CS(i) ? o = i : i !== null && (o.validators = i.validator, o.asyncValidators = i.asyncValidator), new Kd(s, o)
        }
        record(r, i = null) {
            let s = this._reduceControls(r);
            return new zy(s, i)
        }
        control(r, i, s) {
            let o = {};
            return this.useNonNullable ? (CS(i) ? o = i : (o.validators = i, o.asyncValidators = s), new Gd(r, Q(_({}, o), {
                nonNullable: !0
            }))) : new Gd(r, i, s)
        }
        array(r, i, s) {
            let o = r.map(a => this._createControl(a));
            return new $y(o, i, s)
        }
        _reduceControls(r) {
            let i = {};
            return Object.keys(r).forEach(s => {
                i[s] = this._createControl(r[s])
            }), i
        }
        _createControl(r) {
            if (r instanceof Gd) return r;
            if (r instanceof No) return r;
            if (Array.isArray(r)) {
                let i = r[0],
                    s = r.length > 1 ? r[1] : null,
                    o = r.length > 2 ? r[2] : null;
                return this.control(i, s, o)
            } else return this.control(r)
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
})();
var eh = (() => {
        let e = class e {
            static withConfig(r) {
                return {
                    ngModule: e,
                    providers: [{
                        provide: Zy,
                        useValue: r.callSetDisabledState ? ? Xd
                    }]
                }
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275mod = xe({
            type: e
        }), e.\u0275inj = Te({
            imports: [zS]
        });
        let t = e;
        return t
    })(),
    WS = (() => {
        let e = class e {
            static withConfig(r) {
                return {
                    ngModule: e,
                    providers: [{
                        provide: PV,
                        useValue: r.warnOnNgModelWithFormControl ? ? "always"
                    }, {
                        provide: Zy,
                        useValue: r.callSetDisabledState ? ? Xd
                    }]
                }
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275mod = xe({
            type: e
        }), e.\u0275inj = Te({
            imports: [zS]
        });
        let t = e;
        return t
    })();
var se = "primary",
    gc = Symbol("RouteTitle"),
    ev = class {
        constructor(e) {
            this.params = e || {}
        }
        has(e) {
            return Object.prototype.hasOwnProperty.call(this.params, e)
        }
        get(e) {
            if (this.has(e)) {
                let n = this.params[e];
                return Array.isArray(n) ? n[0] : n
            }
            return null
        }
        getAll(e) {
            if (this.has(e)) {
                let n = this.params[e];
                return Array.isArray(n) ? n : [n]
            }
            return []
        }
        get keys() {
            return Object.keys(this.params)
        }
    };

function Po(t) {
    return new ev(t)
}

function UV(t, e, n) {
    let r = n.path.split("/");
    if (r.length > t.length || n.pathMatch === "full" && (e.hasChildren() || r.length < t.length)) return null;
    let i = {};
    for (let s = 0; s < r.length; s++) {
        let o = r[s],
            a = t[s];
        if (o.startsWith(":")) i[o.substring(1)] = a;
        else if (o !== a.path) return null
    }
    return {
        consumed: t.slice(0, r.length),
        posParams: i
    }
}

function jV(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0; n < t.length; ++n)
        if (!sr(t[n], e[n])) return !1;
    return !0
}

function sr(t, e) {
    let n = t ? tv(t) : void 0,
        r = e ? tv(e) : void 0;
    if (!n || !r || n.length != r.length) return !1;
    let i;
    for (let s = 0; s < n.length; s++)
        if (i = n[s], !XS(t[i], e[i])) return !1;
    return !0
}

function tv(t) {
    return [...Object.keys(t), ...Object.getOwnPropertySymbols(t)]
}

function XS(t, e) {
    if (Array.isArray(t) && Array.isArray(e)) {
        if (t.length !== e.length) return !1;
        let n = [...t].sort(),
            r = [...e].sort();
        return n.every((i, s) => r[s] === i)
    } else return t === e
}

function eM(t) {
    return t.length > 0 ? t[t.length - 1] : null
}

function yi(t) {
    return Rt(t) ? t : Xi(t) ? le(Promise.resolve(t)) : k(t)
}
var BV = {
        exact: nM,
        subset: rM
    },
    tM = {
        exact: zV,
        subset: $V,
        ignored: () => !0
    };

function HS(t, e, n) {
    return BV[n.paths](t.root, e.root, n.matrixParams) && tM[n.queryParams](t.queryParams, e.queryParams) && !(n.fragment === "exact" && t.fragment !== e.fragment)
}

function zV(t, e) {
    return sr(t, e)
}

function nM(t, e, n) {
    if (!ds(t.segments, e.segments) || !rh(t.segments, e.segments, n) || t.numberOfChildren !== e.numberOfChildren) return !1;
    for (let r in e.children)
        if (!t.children[r] || !nM(t.children[r], e.children[r], n)) return !1;
    return !0
}

function $V(t, e) {
    return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => XS(t[n], e[n]))
}

function rM(t, e, n) {
    return iM(t, e, e.segments, n)
}

function iM(t, e, n, r) {
    if (t.segments.length > n.length) {
        let i = t.segments.slice(0, n.length);
        return !(!ds(i, n) || e.hasChildren() || !rh(i, n, r))
    } else if (t.segments.length === n.length) {
        if (!ds(t.segments, n) || !rh(t.segments, n, r)) return !1;
        for (let i in e.children)
            if (!t.children[i] || !rM(t.children[i], e.children[i], r)) return !1;
        return !0
    } else {
        let i = n.slice(0, t.segments.length),
            s = n.slice(t.segments.length);
        return !ds(t.segments, i) || !rh(t.segments, i, r) || !t.children[se] ? !1 : iM(t.children[se], e, s, r)
    }
}

function rh(t, e, n) {
    return e.every((r, i) => tM[n](t[i].parameters, r.parameters))
}
var pi = class {
        constructor(e = new Se([], {}), n = {}, r = null) {
            this.root = e, this.queryParams = n, this.fragment = r
        }
        get queryParamMap() {
            return this._queryParamMap ? ? = Po(this.queryParams), this._queryParamMap
        }
        toString() {
            return GV.serialize(this)
        }
    },
    Se = class {
        constructor(e, n) {
            this.segments = e, this.children = n, this.parent = null, Object.values(n).forEach(r => r.parent = this)
        }
        hasChildren() {
            return this.numberOfChildren > 0
        }
        get numberOfChildren() {
            return Object.keys(this.children).length
        }
        toString() {
            return ih(this)
        }
    },
    us = class {
        constructor(e, n) {
            this.path = e, this.parameters = n
        }
        get parameterMap() {
            return this._parameterMap ? ? = Po(this.parameters), this._parameterMap
        }
        toString() {
            return oM(this)
        }
    };

function WV(t, e) {
    return ds(t, e) && t.every((n, r) => sr(n.parameters, e[r].parameters))
}

function ds(t, e) {
    return t.length !== e.length ? !1 : t.every((n, r) => n.path === e[r].path)
}

function HV(t, e) {
    let n = [];
    return Object.entries(t.children).forEach(([r, i]) => {
        r === se && (n = n.concat(e(i, r)))
    }), Object.entries(t.children).forEach(([r, i]) => {
        r !== se && (n = n.concat(e(i, r)))
    }), n
}
var mc = (() => {
        let e = class e {};
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: () => new ac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    ac = class {
        parse(e) {
            let n = new rv(e);
            return new pi(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment())
        }
        serialize(e) {
            let n = `/${tc(e.root,!0)}`,
                r = qV(e.queryParams),
                i = typeof e.fragment == "string" ? `#${ZV(e.fragment)}` : "";
            return `${n}${r}${i}`
        }
    },
    GV = new ac;

function ih(t) {
    return t.segments.map(e => oM(e)).join("/")
}

function tc(t, e) {
    if (!t.hasChildren()) return ih(t);
    if (e) {
        let n = t.children[se] ? tc(t.children[se], !1) : "",
            r = [];
        return Object.entries(t.children).forEach(([i, s]) => {
            i !== se && r.push(`${i}:${tc(s,!1)}`)
        }), r.length > 0 ? `${n}(${r.join("//")})` : n
    } else {
        let n = HV(t, (r, i) => i === se ? [tc(t.children[se], !1)] : [`${i}:${tc(r,!1)}`]);
        return Object.keys(t.children).length === 1 && t.children[se] != null ? `${ih(t)}/${n[0]}` : `${ih(t)}/(${n.join("//")})`
    }
}

function sM(t) {
    return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",")
}

function th(t) {
    return sM(t).replace(/%3B/gi, ";")
}

function ZV(t) {
    return encodeURI(t)
}

function nv(t) {
    return sM(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&")
}

function sh(t) {
    return decodeURIComponent(t)
}

function GS(t) {
    return sh(t.replace(/\+/g, "%20"))
}

function oM(t) {
    return `${nv(t.path)}${QV(t.parameters)}`
}

function QV(t) {
    return Object.entries(t).map(([e, n]) => `;${nv(e)}=${nv(n)}`).join("")
}

function qV(t) {
    let e = Object.entries(t).map(([n, r]) => Array.isArray(r) ? r.map(i => `${th(n)}=${th(i)}`).join("&") : `${th(n)}=${th(r)}`).filter(n => n);
    return e.length ? `?${e.join("&")}` : ""
}
var KV = /^[^\/()?;#]+/;

function Ky(t) {
    let e = t.match(KV);
    return e ? e[0] : ""
}
var YV = /^[^\/()?;=#]+/;

function JV(t) {
    let e = t.match(YV);
    return e ? e[0] : ""
}
var XV = /^[^=?&#]+/;

function eU(t) {
    let e = t.match(XV);
    return e ? e[0] : ""
}
var tU = /^[^&#]+/;

function nU(t) {
    let e = t.match(tU);
    return e ? e[0] : ""
}
var rv = class {
    constructor(e) {
        this.url = e, this.remaining = e
    }
    parseRootSegment() {
        return this.consumeOptional("/"), this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#") ? new Se([], {}) : new Se([], this.parseChildren())
    }
    parseQueryParams() {
        let e = {};
        if (this.consumeOptional("?"))
            do this.parseQueryParam(e); while (this.consumeOptional("&"));
        return e
    }
    parseFragment() {
        return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null
    }
    parseChildren() {
        if (this.remaining === "") return {};
        this.consumeOptional("/");
        let e = [];
        for (this.peekStartsWith("(") || e.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");) this.capture("/"), e.push(this.parseSegment());
        let n = {};
        this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0));
        let r = {};
        return this.peekStartsWith("(") && (r = this.parseParens(!1)), (e.length > 0 || Object.keys(n).length > 0) && (r[se] = new Se(e, n)), r
    }
    parseSegment() {
        let e = Ky(this.remaining);
        if (e === "" && this.peekStartsWith(";")) throw new S(4009, !1);
        return this.capture(e), new us(sh(e), this.parseMatrixParams())
    }
    parseMatrixParams() {
        let e = {};
        for (; this.consumeOptional(";");) this.parseParam(e);
        return e
    }
    parseParam(e) {
        let n = JV(this.remaining);
        if (!n) return;
        this.capture(n);
        let r = "";
        if (this.consumeOptional("=")) {
            let i = Ky(this.remaining);
            i && (r = i, this.capture(r))
        }
        e[sh(n)] = sh(r)
    }
    parseQueryParam(e) {
        let n = eU(this.remaining);
        if (!n) return;
        this.capture(n);
        let r = "";
        if (this.consumeOptional("=")) {
            let o = nU(this.remaining);
            o && (r = o, this.capture(r))
        }
        let i = GS(n),
            s = GS(r);
        if (e.hasOwnProperty(i)) {
            let o = e[i];
            Array.isArray(o) || (o = [o], e[i] = o), o.push(s)
        } else e[i] = s
    }
    parseParens(e) {
        let n = {};
        for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) {
            let r = Ky(this.remaining),
                i = this.remaining[r.length];
            if (i !== "/" && i !== ")" && i !== ";") throw new S(4010, !1);
            let s;
            r.indexOf(":") > -1 ? (s = r.slice(0, r.indexOf(":")), this.capture(s), this.capture(":")) : e && (s = se);
            let o = this.parseChildren();
            n[s] = Object.keys(o).length === 1 ? o[se] : new Se([], o), this.consumeOptional("//")
        }
        return n
    }
    peekStartsWith(e) {
        return this.remaining.startsWith(e)
    }
    consumeOptional(e) {
        return this.peekStartsWith(e) ? (this.remaining = this.remaining.substring(e.length), !0) : !1
    }
    capture(e) {
        if (!this.consumeOptional(e)) throw new S(4011, !1)
    }
};

function aM(t) {
    return t.segments.length > 0 ? new Se([], {
        [se]: t
    }) : t
}

function cM(t) {
    let e = {};
    for (let [r, i] of Object.entries(t.children)) {
        let s = cM(i);
        if (r === se && s.segments.length === 0 && s.hasChildren())
            for (let [o, a] of Object.entries(s.children)) e[o] = a;
        else(s.segments.length > 0 || s.hasChildren()) && (e[r] = s)
    }
    let n = new Se(t.segments, e);
    return rU(n)
}

function rU(t) {
    if (t.numberOfChildren === 1 && t.children[se]) {
        let e = t.children[se];
        return new Se(t.segments.concat(e.segments), e.children)
    }
    return t
}

function Lo(t) {
    return t instanceof pi
}

function iU(t, e, n = null, r = null) {
    let i = lM(t);
    return uM(i, e, n, r)
}

function lM(t) {
    let e;

    function n(s) {
        let o = {};
        for (let c of s.children) {
            let l = n(c);
            o[c.outlet] = l
        }
        let a = new Se(s.url, o);
        return s === t && (e = a), a
    }
    let r = n(t.root),
        i = aM(r);
    return e ? ? i
}

function uM(t, e, n, r) {
    let i = t;
    for (; i.parent;) i = i.parent;
    if (e.length === 0) return Yy(i, i, i, n, r);
    let s = sU(e);
    if (s.toRoot()) return Yy(i, i, new Se([], {}), n, r);
    let o = oU(s, i, t),
        a = o.processChildren ? ic(o.segmentGroup, o.index, s.commands) : hM(o.segmentGroup, o.index, s.commands);
    return Yy(i, o.segmentGroup, a, n, r)
}

function oh(t) {
    return typeof t == "object" && t != null && !t.outlets && !t.segmentPath
}

function cc(t) {
    return typeof t == "object" && t != null && t.outlets
}

function Yy(t, e, n, r, i) {
    let s = {};
    r && Object.entries(r).forEach(([c, l]) => {
        s[c] = Array.isArray(l) ? l.map(u => `${u}`) : `${l}`
    });
    let o;
    t === e ? o = n : o = dM(t, e, n);
    let a = aM(cM(o));
    return new pi(a, s, i)
}

function dM(t, e, n) {
    let r = {};
    return Object.entries(t.children).forEach(([i, s]) => {
        s === e ? r[i] = n : r[i] = dM(s, e, n)
    }), new Se(t.segments, r)
}
var ah = class {
    constructor(e, n, r) {
        if (this.isAbsolute = e, this.numberOfDoubleDots = n, this.commands = r, e && r.length > 0 && oh(r[0])) throw new S(4003, !1);
        let i = r.find(cc);
        if (i && i !== eM(r)) throw new S(4004, !1)
    }
    toRoot() {
        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/"
    }
};

function sU(t) {
    if (typeof t[0] == "string" && t.length === 1 && t[0] === "/") return new ah(!0, 0, t);
    let e = 0,
        n = !1,
        r = t.reduce((i, s, o) => {
            if (typeof s == "object" && s != null) {
                if (s.outlets) {
                    let a = {};
                    return Object.entries(s.outlets).forEach(([c, l]) => {
                        a[c] = typeof l == "string" ? l.split("/") : l
                    }), [...i, {
                        outlets: a
                    }]
                }
                if (s.segmentPath) return [...i, s.segmentPath]
            }
            return typeof s != "string" ? [...i, s] : o === 0 ? (s.split("/").forEach((a, c) => {
                c == 0 && a === "." || (c == 0 && a === "" ? n = !0 : a === ".." ? e++ : a != "" && i.push(a))
            }), i) : [...i, s]
        }, []);
    return new ah(n, e, r)
}
var Fo = class {
    constructor(e, n, r) {
        this.segmentGroup = e, this.processChildren = n, this.index = r
    }
};

function oU(t, e, n) {
    if (t.isAbsolute) return new Fo(e, !0, 0);
    if (!n) return new Fo(e, !1, NaN);
    if (n.parent === null) return new Fo(n, !0, 0);
    let r = oh(t.commands[0]) ? 0 : 1,
        i = n.segments.length - 1 + r;
    return aU(n, i, t.numberOfDoubleDots)
}

function aU(t, e, n) {
    let r = t,
        i = e,
        s = n;
    for (; s > i;) {
        if (s -= i, r = r.parent, !r) throw new S(4005, !1);
        i = r.segments.length
    }
    return new Fo(r, !1, i - s)
}

function cU(t) {
    return cc(t[0]) ? t[0].outlets : {
        [se]: t
    }
}

function hM(t, e, n) {
    if (t ? ? = new Se([], {}), t.segments.length === 0 && t.hasChildren()) return ic(t, e, n);
    let r = lU(t, e, n),
        i = n.slice(r.commandIndex);
    if (r.match && r.pathIndex < t.segments.length) {
        let s = new Se(t.segments.slice(0, r.pathIndex), {});
        return s.children[se] = new Se(t.segments.slice(r.pathIndex), t.children), ic(s, 0, i)
    } else return r.match && i.length === 0 ? new Se(t.segments, {}) : r.match && !t.hasChildren() ? iv(t, e, n) : r.match ? ic(t, 0, i) : iv(t, e, n)
}

function ic(t, e, n) {
    if (n.length === 0) return new Se(t.segments, {}); {
        let r = cU(n),
            i = {};
        if (Object.keys(r).some(s => s !== se) && t.children[se] && t.numberOfChildren === 1 && t.children[se].segments.length === 0) {
            let s = ic(t.children[se], e, n);
            return new Se(t.segments, s.children)
        }
        return Object.entries(r).forEach(([s, o]) => {
            typeof o == "string" && (o = [o]), o !== null && (i[s] = hM(t.children[s], e, o))
        }), Object.entries(t.children).forEach(([s, o]) => {
            r[s] === void 0 && (i[s] = o)
        }), new Se(t.segments, i)
    }
}

function lU(t, e, n) {
    let r = 0,
        i = e,
        s = {
            match: !1,
            pathIndex: 0,
            commandIndex: 0
        };
    for (; i < t.segments.length;) {
        if (r >= n.length) return s;
        let o = t.segments[i],
            a = n[r];
        if (cc(a)) break;
        let c = `${a}`,
            l = r < n.length - 1 ? n[r + 1] : null;
        if (i > 0 && c === void 0) break;
        if (c && l && typeof l == "object" && l.outlets === void 0) {
            if (!QS(c, l, o)) return s;
            r += 2
        } else {
            if (!QS(c, {}, o)) return s;
            r++
        }
        i++
    }
    return {
        match: !0,
        pathIndex: i,
        commandIndex: r
    }
}

function iv(t, e, n) {
    let r = t.segments.slice(0, e),
        i = 0;
    for (; i < n.length;) {
        let s = n[i];
        if (cc(s)) {
            let c = uU(s.outlets);
            return new Se(r, c)
        }
        if (i === 0 && oh(n[0])) {
            let c = t.segments[e];
            r.push(new us(c.path, ZS(n[0]))), i++;
            continue
        }
        let o = cc(s) ? s.outlets[se] : `${s}`,
            a = i < n.length - 1 ? n[i + 1] : null;
        o && a && oh(a) ? (r.push(new us(o, ZS(a))), i += 2) : (r.push(new us(o, {})), i++)
    }
    return new Se(r, {})
}

function uU(t) {
    let e = {};
    return Object.entries(t).forEach(([n, r]) => {
        typeof r == "string" && (r = [r]), r !== null && (e[n] = iv(new Se([], {}), 0, r))
    }), e
}

function ZS(t) {
    let e = {};
    return Object.entries(t).forEach(([n, r]) => e[n] = `${r}`), e
}

function QS(t, e, n) {
    return t == n.path && sr(e, n.parameters)
}
var sc = "imperative",
    dt = function(t) {
        return t[t.NavigationStart = 0] = "NavigationStart", t[t.NavigationEnd = 1] = "NavigationEnd", t[t.NavigationCancel = 2] = "NavigationCancel", t[t.NavigationError = 3] = "NavigationError", t[t.RoutesRecognized = 4] = "RoutesRecognized", t[t.ResolveStart = 5] = "ResolveStart", t[t.ResolveEnd = 6] = "ResolveEnd", t[t.GuardsCheckStart = 7] = "GuardsCheckStart", t[t.GuardsCheckEnd = 8] = "GuardsCheckEnd", t[t.RouteConfigLoadStart = 9] = "RouteConfigLoadStart", t[t.RouteConfigLoadEnd = 10] = "RouteConfigLoadEnd", t[t.ChildActivationStart = 11] = "ChildActivationStart", t[t.ChildActivationEnd = 12] = "ChildActivationEnd", t[t.ActivationStart = 13] = "ActivationStart", t[t.ActivationEnd = 14] = "ActivationEnd", t[t.Scroll = 15] = "Scroll", t[t.NavigationSkipped = 16] = "NavigationSkipped", t
    }(dt || {}),
    bn = class {
        constructor(e, n) {
            this.id = e, this.url = n
        }
    },
    Vo = class extends bn {
        constructor(e, n, r = "imperative", i = null) {
            super(e, n), this.type = dt.NavigationStart, this.navigationTrigger = r, this.restoredState = i
        }
        toString() {
            return `NavigationStart(id: ${this.id}, url: '${this.url}')`
        }
    },
    Fr = class extends bn {
        constructor(e, n, r) {
            super(e, n), this.urlAfterRedirects = r, this.type = dt.NavigationEnd
        }
        toString() {
            return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`
        }
    },
    sn = function(t) {
        return t[t.Redirect = 0] = "Redirect", t[t.SupersededByNewNavigation = 1] = "SupersededByNewNavigation", t[t.NoDataFromResolver = 2] = "NoDataFromResolver", t[t.GuardRejected = 3] = "GuardRejected", t
    }(sn || {}),
    ch = function(t) {
        return t[t.IgnoredSameUrlNavigation = 0] = "IgnoredSameUrlNavigation", t[t.IgnoredByUrlHandlingStrategy = 1] = "IgnoredByUrlHandlingStrategy", t
    }(ch || {}),
    gi = class extends bn {
        constructor(e, n, r, i) {
            super(e, n), this.reason = r, this.code = i, this.type = dt.NavigationCancel
        }
        toString() {
            return `NavigationCancel(id: ${this.id}, url: '${this.url}')`
        }
    },
    mi = class extends bn {
        constructor(e, n, r, i) {
            super(e, n), this.reason = r, this.code = i, this.type = dt.NavigationSkipped
        }
    },
    lc = class extends bn {
        constructor(e, n, r, i) {
            super(e, n), this.error = r, this.target = i, this.type = dt.NavigationError
        }
        toString() {
            return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`
        }
    },
    lh = class extends bn {
        constructor(e, n, r, i) {
            super(e, n), this.urlAfterRedirects = r, this.state = i, this.type = dt.RoutesRecognized
        }
        toString() {
            return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
    },
    sv = class extends bn {
        constructor(e, n, r, i) {
            super(e, n), this.urlAfterRedirects = r, this.state = i, this.type = dt.GuardsCheckStart
        }
        toString() {
            return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
    },
    ov = class extends bn {
        constructor(e, n, r, i, s) {
            super(e, n), this.urlAfterRedirects = r, this.state = i, this.shouldActivate = s, this.type = dt.GuardsCheckEnd
        }
        toString() {
            return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`
        }
    },
    av = class extends bn {
        constructor(e, n, r, i) {
            super(e, n), this.urlAfterRedirects = r, this.state = i, this.type = dt.ResolveStart
        }
        toString() {
            return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
    },
    cv = class extends bn {
        constructor(e, n, r, i) {
            super(e, n), this.urlAfterRedirects = r, this.state = i, this.type = dt.ResolveEnd
        }
        toString() {
            return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`
        }
    },
    lv = class {
        constructor(e) {
            this.route = e, this.type = dt.RouteConfigLoadStart
        }
        toString() {
            return `RouteConfigLoadStart(path: ${this.route.path})`
        }
    },
    uv = class {
        constructor(e) {
            this.route = e, this.type = dt.RouteConfigLoadEnd
        }
        toString() {
            return `RouteConfigLoadEnd(path: ${this.route.path})`
        }
    },
    dv = class {
        constructor(e) {
            this.snapshot = e, this.type = dt.ChildActivationStart
        }
        toString() {
            return `ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
        }
    },
    hv = class {
        constructor(e) {
            this.snapshot = e, this.type = dt.ChildActivationEnd
        }
        toString() {
            return `ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
        }
    },
    fv = class {
        constructor(e) {
            this.snapshot = e, this.type = dt.ActivationStart
        }
        toString() {
            return `ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
        }
    },
    pv = class {
        constructor(e) {
            this.snapshot = e, this.type = dt.ActivationEnd
        }
        toString() {
            return `ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`
        }
    },
    uh = class {
        constructor(e, n, r) {
            this.routerEvent = e, this.position = n, this.anchor = r, this.type = dt.Scroll
        }
        toString() {
            let e = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
            return `Scroll(anchor: '${this.anchor}', position: '${e}')`
        }
    },
    uc = class {},
    dc = class {
        constructor(e) {
            this.url = e
        }
    };
var gv = class {
        constructor() {
            this.outlet = null, this.route = null, this.injector = null, this.children = new yc, this.attachRef = null
        }
    },
    yc = (() => {
        let e = class e {
            constructor() {
                this.contexts = new Map
            }
            onChildOutletCreated(r, i) {
                let s = this.getOrCreateContext(r);
                s.outlet = i, this.contexts.set(r, s)
            }
            onChildOutletDestroyed(r) {
                let i = this.getContext(r);
                i && (i.outlet = null, i.attachRef = null)
            }
            onOutletDeactivated() {
                let r = this.contexts;
                return this.contexts = new Map, r
            }
            onOutletReAttached(r) {
                this.contexts = r
            }
            getOrCreateContext(r) {
                let i = this.getContext(r);
                return i || (i = new gv, this.contexts.set(r, i)), i
            }
            getContext(r) {
                return this.contexts.get(r) || null
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    dh = class {
        constructor(e) {
            this._root = e
        }
        get root() {
            return this._root.value
        }
        parent(e) {
            let n = this.pathFromRoot(e);
            return n.length > 1 ? n[n.length - 2] : null
        }
        children(e) {
            let n = mv(e, this._root);
            return n ? n.children.map(r => r.value) : []
        }
        firstChild(e) {
            let n = mv(e, this._root);
            return n && n.children.length > 0 ? n.children[0].value : null
        }
        siblings(e) {
            let n = yv(e, this._root);
            return n.length < 2 ? [] : n[n.length - 2].children.map(i => i.value).filter(i => i !== e)
        }
        pathFromRoot(e) {
            return yv(e, this._root).map(n => n.value)
        }
    };

function mv(t, e) {
    if (t === e.value) return e;
    for (let n of e.children) {
        let r = mv(t, n);
        if (r) return r
    }
    return null
}

function yv(t, e) {
    if (t === e.value) return [e];
    for (let n of e.children) {
        let r = yv(t, n);
        if (r.length) return r.unshift(e), r
    }
    return []
}
var rn = class {
    constructor(e, n) {
        this.value = e, this.children = n
    }
    toString() {
        return `TreeNode(${this.value})`
    }
};

function Oo(t) {
    let e = {};
    return t && t.children.forEach(n => e[n.value.outlet] = n), e
}
var hh = class extends dh {
    constructor(e, n) {
        super(e), this.snapshot = n, Iv(this, e)
    }
    toString() {
        return this.snapshot.toString()
    }
};

function fM(t) {
    let e = dU(t),
        n = new Ze([new us("", {})]),
        r = new Ze({}),
        i = new Ze({}),
        s = new Ze({}),
        o = new Ze(""),
        a = new or(n, r, s, o, i, se, t, e.root);
    return a.snapshot = e.root, new hh(new rn(a, []), e)
}

function dU(t) {
    let e = {},
        n = {},
        r = {},
        i = "",
        s = new hc([], e, r, i, n, se, t, null, {});
    return new fh("", new rn(s, []))
}
var or = class {
    constructor(e, n, r, i, s, o, a, c) {
        this.urlSubject = e, this.paramsSubject = n, this.queryParamsSubject = r, this.fragmentSubject = i, this.dataSubject = s, this.outlet = o, this.component = a, this._futureSnapshot = c, this.title = this.dataSubject ? .pipe(Z(l => l[gc])) ? ? k(void 0), this.url = e, this.params = n, this.queryParams = r, this.fragment = i, this.data = s
    }
    get routeConfig() {
        return this._futureSnapshot.routeConfig
    }
    get root() {
        return this._routerState.root
    }
    get parent() {
        return this._routerState.parent(this)
    }
    get firstChild() {
        return this._routerState.firstChild(this)
    }
    get children() {
        return this._routerState.children(this)
    }
    get pathFromRoot() {
        return this._routerState.pathFromRoot(this)
    }
    get paramMap() {
        return this._paramMap ? ? = this.params.pipe(Z(e => Po(e))), this._paramMap
    }
    get queryParamMap() {
        return this._queryParamMap ? ? = this.queryParams.pipe(Z(e => Po(e))), this._queryParamMap
    }
    toString() {
        return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`
    }
};

function Mv(t, e, n = "emptyOnly") {
    let r, {
        routeConfig: i
    } = t;
    return e !== null && (n === "always" || i ? .path === "" || !e.component && !e.routeConfig ? .loadComponent) ? r = {
        params: _(_({}, e.params), t.params),
        data: _(_({}, e.data), t.data),
        resolve: _(_(_(_({}, t.data), e.data), i ? .data), t._resolvedData)
    } : r = {
        params: _({}, t.params),
        data: _({}, t.data),
        resolve: _(_({}, t.data), t._resolvedData ? ? {})
    }, i && gM(i) && (r.resolve[gc] = i.title), r
}
var hc = class {
        get title() {
            return this.data ? .[gc]
        }
        constructor(e, n, r, i, s, o, a, c, l) {
            this.url = e, this.params = n, this.queryParams = r, this.fragment = i, this.data = s, this.outlet = o, this.component = a, this.routeConfig = c, this._resolve = l
        }
        get root() {
            return this._routerState.root
        }
        get parent() {
            return this._routerState.parent(this)
        }
        get firstChild() {
            return this._routerState.firstChild(this)
        }
        get children() {
            return this._routerState.children(this)
        }
        get pathFromRoot() {
            return this._routerState.pathFromRoot(this)
        }
        get paramMap() {
            return this._paramMap ? ? = Po(this.params), this._paramMap
        }
        get queryParamMap() {
            return this._queryParamMap ? ? = Po(this.queryParams), this._queryParamMap
        }
        toString() {
            let e = this.url.map(r => r.toString()).join("/"),
                n = this.routeConfig ? this.routeConfig.path : "";
            return `Route(url:'${e}', path:'${n}')`
        }
    },
    fh = class extends dh {
        constructor(e, n) {
            super(n), this.url = e, Iv(this, n)
        }
        toString() {
            return pM(this._root)
        }
    };

function Iv(t, e) {
    e.value._routerState = t, e.children.forEach(n => Iv(t, n))
}

function pM(t) {
    let e = t.children.length > 0 ? ` { ${t.children.map(pM).join(", ")} } ` : "";
    return `${t.value}${e}`
}

function Jy(t) {
    if (t.snapshot) {
        let e = t.snapshot,
            n = t._futureSnapshot;
        t.snapshot = n, sr(e.queryParams, n.queryParams) || t.queryParamsSubject.next(n.queryParams), e.fragment !== n.fragment && t.fragmentSubject.next(n.fragment), sr(e.params, n.params) || t.paramsSubject.next(n.params), jV(e.url, n.url) || t.urlSubject.next(n.url), sr(e.data, n.data) || t.dataSubject.next(n.data)
    } else t.snapshot = t._futureSnapshot, t.dataSubject.next(t._futureSnapshot.data)
}

function vv(t, e) {
    let n = sr(t.params, e.params) && WV(t.url, e.url),
        r = !t.parent != !e.parent;
    return n && !r && (!t.parent || vv(t.parent, e.parent))
}

function gM(t) {
    return typeof t.title == "string" || t.title === null
}
var vc = (() => {
        let e = class e {
            constructor() {
                this.activated = null, this._activatedRoute = null, this.name = se, this.activateEvents = new oe, this.deactivateEvents = new oe, this.attachEvents = new oe, this.detachEvents = new oe, this.parentContexts = M(yc), this.location = M(Un), this.changeDetector = M(xt), this.environmentInjector = M(Ut), this.inputBinder = M(vh, {
                    optional: !0
                }), this.supportsBindingToComponentInputs = !0
            }
            get activatedComponentRef() {
                return this.activated
            }
            ngOnChanges(r) {
                if (r.name) {
                    let {
                        firstChange: i,
                        previousValue: s
                    } = r.name;
                    if (i) return;
                    this.isTrackedInParentContexts(s) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(s)), this.initializeOutletWithName()
                }
            }
            ngOnDestroy() {
                this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder ? .unsubscribeFromRouteData(this)
            }
            isTrackedInParentContexts(r) {
                return this.parentContexts.getContext(r) ? .outlet === this
            }
            ngOnInit() {
                this.initializeOutletWithName()
            }
            initializeOutletWithName() {
                if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return;
                let r = this.parentContexts.getContext(this.name);
                r ? .route && (r.attachRef ? this.attach(r.attachRef, r.route) : this.activateWith(r.route, r.injector))
            }
            get isActivated() {
                return !!this.activated
            }
            get component() {
                if (!this.activated) throw new S(4012, !1);
                return this.activated.instance
            }
            get activatedRoute() {
                if (!this.activated) throw new S(4012, !1);
                return this._activatedRoute
            }
            get activatedRouteData() {
                return this._activatedRoute ? this._activatedRoute.snapshot.data : {}
            }
            detach() {
                if (!this.activated) throw new S(4012, !1);
                this.location.detach();
                let r = this.activated;
                return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(r.instance), r
            }
            attach(r, i) {
                this.activated = r, this._activatedRoute = i, this.location.insert(r.hostView), this.inputBinder ? .bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(r.instance)
            }
            deactivate() {
                if (this.activated) {
                    let r = this.component;
                    this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(r)
                }
            }
            activateWith(r, i) {
                if (this.isActivated) throw new S(4013, !1);
                this._activatedRoute = r;
                let s = this.location,
                    a = r.snapshot.component,
                    c = this.parentContexts.getOrCreateContext(this.name).children,
                    l = new wv(r, c, s.injector);
                this.activated = s.createComponent(a, {
                    index: s.length,
                    injector: l,
                    environmentInjector: i ? ? this.environmentInjector
                }), this.changeDetector.markForCheck(), this.inputBinder ? .bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275dir = et({
            type: e,
            selectors: [
                ["router-outlet"]
            ],
            inputs: {
                name: "name"
            },
            outputs: {
                activateEvents: "activate",
                deactivateEvents: "deactivate",
                attachEvents: "attach",
                detachEvents: "detach"
            },
            exportAs: ["outlet"],
            standalone: !0,
            features: [Vn]
        });
        let t = e;
        return t
    })(),
    wv = class {
        constructor(e, n, r) {
            this.route = e, this.childContexts = n, this.parent = r
        }
        get(e, n) {
            return e === or ? this.route : e === yc ? this.childContexts : this.parent.get(e, n)
        }
    },
    vh = new R(""),
    qS = (() => {
        let e = class e {
            constructor() {
                this.outletDataSubscriptions = new Map
            }
            bindActivatedRouteToOutletComponent(r) {
                this.unsubscribeFromRouteData(r), this.subscribeToRouteData(r)
            }
            unsubscribeFromRouteData(r) {
                this.outletDataSubscriptions.get(r) ? .unsubscribe(), this.outletDataSubscriptions.delete(r)
            }
            subscribeToRouteData(r) {
                let {
                    activatedRoute: i
                } = r, s = Ot([i.queryParams, i.params, i.data]).pipe(Je(([o, a, c], l) => (c = _(_(_({}, o), a), c), l === 0 ? k(c) : Promise.resolve(c)))).subscribe(o => {
                    if (!r.isActivated || !r.activatedComponentRef || r.activatedRoute !== i || i.component === null) {
                        this.unsubscribeFromRouteData(r);
                        return
                    }
                    let a = KE(i.component);
                    if (!a) {
                        this.unsubscribeFromRouteData(r);
                        return
                    }
                    for (let {
                            templateName: c
                        } of a.inputs) r.activatedComponentRef.setInput(c, o[c])
                });
                this.outletDataSubscriptions.set(r, s)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })();

function hU(t, e, n) {
    let r = fc(t, e._root, n ? n._root : void 0);
    return new hh(r, e)
}

function fc(t, e, n) {
    if (n && t.shouldReuseRoute(e.value, n.value.snapshot)) {
        let r = n.value;
        r._futureSnapshot = e.value;
        let i = fU(t, e, n);
        return new rn(r, i)
    } else {
        if (t.shouldAttach(e.value)) {
            let s = t.retrieve(e.value);
            if (s !== null) {
                let o = s.route;
                return o.value._futureSnapshot = e.value, o.children = e.children.map(a => fc(t, a)), o
            }
        }
        let r = pU(e.value),
            i = e.children.map(s => fc(t, s));
        return new rn(r, i)
    }
}

function fU(t, e, n) {
    return e.children.map(r => {
        for (let i of n.children)
            if (t.shouldReuseRoute(r.value, i.value.snapshot)) return fc(t, r, i);
        return fc(t, r)
    })
}

function pU(t) {
    return new or(new Ze(t.url), new Ze(t.params), new Ze(t.queryParams), new Ze(t.fragment), new Ze(t.data), t.outlet, t.component, t)
}
var mM = "ngNavigationCancelingError";

function yM(t, e) {
    let {
        redirectTo: n,
        navigationBehaviorOptions: r
    } = Lo(e) ? {
        redirectTo: e,
        navigationBehaviorOptions: void 0
    } : e, i = vM(!1, sn.Redirect);
    return i.url = n, i.navigationBehaviorOptions = r, i
}

function vM(t, e) {
    let n = new Error(`NavigationCancelingError: ${t||""}`);
    return n[mM] = !0, n.cancellationCode = e, n
}

function gU(t) {
    return wM(t) && Lo(t.url)
}

function wM(t) {
    return !!t && t[mM]
}
var mU = (() => {
    let e = class e {};
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275cmp = He({
        type: e,
        selectors: [
            ["ng-component"]
        ],
        standalone: !0,
        features: [UE],
        decls: 1,
        vars: 0,
        template: function(i, s) {
            i & 1 && fe(0, "router-outlet")
        },
        dependencies: [vc],
        encapsulation: 2
    });
    let t = e;
    return t
})();

function yU(t, e) {
    return t.providers && !t._injector && (t._injector = Gu(t.providers, e, `Route: ${t.path}`)), t._injector ? ? e
}

function Tv(t) {
    let e = t.children && t.children.map(Tv),
        n = e ? Q(_({}, t), {
            children: e
        }) : _({}, t);
    return !n.component && !n.loadComponent && (e || n.loadChildren) && n.outlet && n.outlet !== se && (n.component = mU), n
}

function ar(t) {
    return t.outlet || se
}

function vU(t, e) {
    let n = t.filter(r => ar(r) === e);
    return n.push(...t.filter(r => ar(r) !== e)), n
}

function wc(t) {
    if (!t) return null;
    if (t.routeConfig ? ._injector) return t.routeConfig._injector;
    for (let e = t.parent; e; e = e.parent) {
        let n = e.routeConfig;
        if (n ? ._loadedInjector) return n._loadedInjector;
        if (n ? ._injector) return n._injector
    }
    return null
}
var wU = (t, e, n, r) => Z(i => (new _v(e, i.targetRouterState, i.currentRouterState, n, r).activate(t), i)),
    _v = class {
        constructor(e, n, r, i, s) {
            this.routeReuseStrategy = e, this.futureState = n, this.currState = r, this.forwardEvent = i, this.inputBindingEnabled = s
        }
        activate(e) {
            let n = this.futureState._root,
                r = this.currState ? this.currState._root : null;
            this.deactivateChildRoutes(n, r, e), Jy(this.futureState.root), this.activateChildRoutes(n, r, e)
        }
        deactivateChildRoutes(e, n, r) {
            let i = Oo(n);
            e.children.forEach(s => {
                let o = s.value.outlet;
                this.deactivateRoutes(s, i[o], r), delete i[o]
            }), Object.values(i).forEach(s => {
                this.deactivateRouteAndItsChildren(s, r)
            })
        }
        deactivateRoutes(e, n, r) {
            let i = e.value,
                s = n ? n.value : null;
            if (i === s)
                if (i.component) {
                    let o = r.getContext(i.outlet);
                    o && this.deactivateChildRoutes(e, n, o.children)
                } else this.deactivateChildRoutes(e, n, r);
            else s && this.deactivateRouteAndItsChildren(n, r)
        }
        deactivateRouteAndItsChildren(e, n) {
            e.value.component && this.routeReuseStrategy.shouldDetach(e.value.snapshot) ? this.detachAndStoreRouteSubtree(e, n) : this.deactivateRouteAndOutlet(e, n)
        }
        detachAndStoreRouteSubtree(e, n) {
            let r = n.getContext(e.value.outlet),
                i = r && e.value.component ? r.children : n,
                s = Oo(e);
            for (let o of Object.values(s)) this.deactivateRouteAndItsChildren(o, i);
            if (r && r.outlet) {
                let o = r.outlet.detach(),
                    a = r.children.onOutletDeactivated();
                this.routeReuseStrategy.store(e.value.snapshot, {
                    componentRef: o,
                    route: e,
                    contexts: a
                })
            }
        }
        deactivateRouteAndOutlet(e, n) {
            let r = n.getContext(e.value.outlet),
                i = r && e.value.component ? r.children : n,
                s = Oo(e);
            for (let o of Object.values(s)) this.deactivateRouteAndItsChildren(o, i);
            r && (r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated()), r.attachRef = null, r.route = null)
        }
        activateChildRoutes(e, n, r) {
            let i = Oo(n);
            e.children.forEach(s => {
                this.activateRoutes(s, i[s.value.outlet], r), this.forwardEvent(new pv(s.value.snapshot))
            }), e.children.length && this.forwardEvent(new hv(e.value.snapshot))
        }
        activateRoutes(e, n, r) {
            let i = e.value,
                s = n ? n.value : null;
            if (Jy(i), i === s)
                if (i.component) {
                    let o = r.getOrCreateContext(i.outlet);
                    this.activateChildRoutes(e, n, o.children)
                } else this.activateChildRoutes(e, n, r);
            else if (i.component) {
                let o = r.getOrCreateContext(i.outlet);
                if (this.routeReuseStrategy.shouldAttach(i.snapshot)) {
                    let a = this.routeReuseStrategy.retrieve(i.snapshot);
                    this.routeReuseStrategy.store(i.snapshot, null), o.children.onOutletReAttached(a.contexts), o.attachRef = a.componentRef, o.route = a.route.value, o.outlet && o.outlet.attach(a.componentRef, a.route.value), Jy(a.route.value), this.activateChildRoutes(e, null, o.children)
                } else {
                    let a = wc(i.snapshot);
                    o.attachRef = null, o.route = i, o.injector = a, o.outlet && o.outlet.activateWith(i, o.injector), this.activateChildRoutes(e, null, o.children)
                }
            } else this.activateChildRoutes(e, null, r)
        }
    },
    ph = class {
        constructor(e) {
            this.path = e, this.route = this.path[this.path.length - 1]
        }
    },
    ko = class {
        constructor(e, n) {
            this.component = e, this.route = n
        }
    };

function _U(t, e, n) {
    let r = t._root,
        i = e ? e._root : null;
    return nc(r, i, n, [r.value])
}

function bU(t) {
    let e = t.routeConfig ? t.routeConfig.canActivateChild : null;
    return !e || e.length === 0 ? null : {
        node: t,
        guards: e
    }
}

function jo(t, e) {
    let n = Symbol(),
        r = e.get(t, n);
    return r === n ? typeof t == "function" && !Nb(t) ? t : e.get(t) : r
}

function nc(t, e, n, r, i = {
    canDeactivateChecks: [],
    canActivateChecks: []
}) {
    let s = Oo(e);
    return t.children.forEach(o => {
        DU(o, s[o.value.outlet], n, r.concat([o.value]), i), delete s[o.value.outlet]
    }), Object.entries(s).forEach(([o, a]) => oc(a, n.getContext(o), i)), i
}

function DU(t, e, n, r, i = {
    canDeactivateChecks: [],
    canActivateChecks: []
}) {
    let s = t.value,
        o = e ? e.value : null,
        a = n ? n.getContext(t.value.outlet) : null;
    if (o && s.routeConfig === o.routeConfig) {
        let c = EU(o, s, s.routeConfig.runGuardsAndResolvers);
        c ? i.canActivateChecks.push(new ph(r)) : (s.data = o.data, s._resolvedData = o._resolvedData), s.component ? nc(t, e, a ? a.children : null, r, i) : nc(t, e, n, r, i), c && a && a.outlet && a.outlet.isActivated && i.canDeactivateChecks.push(new ko(a.outlet.component, o))
    } else o && oc(e, a, i), i.canActivateChecks.push(new ph(r)), s.component ? nc(t, null, a ? a.children : null, r, i) : nc(t, null, n, r, i);
    return i
}

function EU(t, e, n) {
    if (typeof n == "function") return n(t, e);
    switch (n) {
        case "pathParamsChange":
            return !ds(t.url, e.url);
        case "pathParamsOrQueryParamsChange":
            return !ds(t.url, e.url) || !sr(t.queryParams, e.queryParams);
        case "always":
            return !0;
        case "paramsOrQueryParamsChange":
            return !vv(t, e) || !sr(t.queryParams, e.queryParams);
        case "paramsChange":
        default:
            return !vv(t, e)
    }
}

function oc(t, e, n) {
    let r = Oo(t),
        i = t.value;
    Object.entries(r).forEach(([s, o]) => {
        i.component ? e ? oc(o, e.children.getContext(s), n) : oc(o, null, n) : oc(o, e, n)
    }), i.component ? e && e.outlet && e.outlet.isActivated ? n.canDeactivateChecks.push(new ko(e.outlet.component, i)) : n.canDeactivateChecks.push(new ko(null, i)) : n.canDeactivateChecks.push(new ko(null, i))
}

function _c(t) {
    return typeof t == "function"
}

function CU(t) {
    return typeof t == "boolean"
}

function SU(t) {
    return t && _c(t.canLoad)
}

function MU(t) {
    return t && _c(t.canActivate)
}

function IU(t) {
    return t && _c(t.canActivateChild)
}

function TU(t) {
    return t && _c(t.canDeactivate)
}

function xU(t) {
    return t && _c(t.canMatch)
}

function _M(t) {
    return t instanceof Nn || t ? .name === "EmptyError"
}
var nh = Symbol("INITIAL_VALUE");

function Uo() {
    return Je(t => Ot(t.map(e => e.pipe(vt(1), _p(nh)))).pipe(Z(e => {
        for (let n of e)
            if (n !== !0) {
                if (n === nh) return nh;
                if (n === !1 || n instanceof pi) return n
            }
        return !0
    }), Fe(e => e !== nh), vt(1)))
}

function AU(t, e) {
    return qe(n => {
        let {
            targetSnapshot: r,
            currentSnapshot: i,
            guards: {
                canActivateChecks: s,
                canDeactivateChecks: o
            }
        } = n;
        return o.length === 0 && s.length === 0 ? k(Q(_({}, n), {
            guardsResult: !0
        })) : NU(o, r, i, t).pipe(qe(a => a && CU(a) ? RU(r, s, t, e) : k(a)), Z(a => Q(_({}, n), {
            guardsResult: a
        })))
    })
}

function NU(t, e, n, r) {
    return le(t).pipe(qe(i => LU(i.component, i.route, n, e, r)), kt(i => i !== !0, !0))
}

function RU(t, e, n, r) {
    return le(e).pipe(nt(i => Dr(FU(i.route.parent, r), OU(i.route, r), PU(t, i.path, n), kU(t, i.route, n))), kt(i => i !== !0, !0))
}

function OU(t, e) {
    return t !== null && e && e(new fv(t)), k(!0)
}

function FU(t, e) {
    return t !== null && e && e(new dv(t)), k(!0)
}

function kU(t, e, n) {
    let r = e.routeConfig ? e.routeConfig.canActivate : null;
    if (!r || r.length === 0) return k(!0);
    let i = r.map(s => mt(() => {
        let o = wc(e) ? ? n,
            a = jo(s, o),
            c = MU(a) ? a.canActivate(e, t) : Ln(o, () => a(e, t));
        return yi(c).pipe(kt())
    }));
    return k(i).pipe(Uo())
}

function PU(t, e, n) {
    let r = e[e.length - 1],
        s = e.slice(0, e.length - 1).reverse().map(o => bU(o)).filter(o => o !== null).map(o => mt(() => {
            let a = o.guards.map(c => {
                let l = wc(o.node) ? ? n,
                    u = jo(c, l),
                    d = IU(u) ? u.canActivateChild(r, t) : Ln(l, () => u(r, t));
                return yi(d).pipe(kt())
            });
            return k(a).pipe(Uo())
        }));
    return k(s).pipe(Uo())
}

function LU(t, e, n, r, i) {
    let s = e && e.routeConfig ? e.routeConfig.canDeactivate : null;
    if (!s || s.length === 0) return k(!0);
    let o = s.map(a => {
        let c = wc(e) ? ? i,
            l = jo(a, c),
            u = TU(l) ? l.canDeactivate(t, e, n, r) : Ln(c, () => l(t, e, n, r));
        return yi(u).pipe(kt())
    });
    return k(o).pipe(Uo())
}

function VU(t, e, n, r) {
    let i = e.canLoad;
    if (i === void 0 || i.length === 0) return k(!0);
    let s = i.map(o => {
        let a = jo(o, t),
            c = SU(a) ? a.canLoad(e, n) : Ln(t, () => a(e, n));
        return yi(c)
    });
    return k(s).pipe(Uo(), bM(r))
}

function bM(t) {
    return sp(ve(e => {
        if (Lo(e)) throw yM(t, e)
    }), Z(e => e === !0))
}

function UU(t, e, n, r) {
    let i = e.canMatch;
    if (!i || i.length === 0) return k(!0);
    let s = i.map(o => {
        let a = jo(o, t),
            c = xU(a) ? a.canMatch(e, n) : Ln(t, () => a(e, n));
        return yi(c)
    });
    return k(s).pipe(Uo(), bM(r))
}
var pc = class {
        constructor(e) {
            this.segmentGroup = e || null
        }
    },
    gh = class extends Error {
        constructor(e) {
            super(), this.urlTree = e
        }
    };

function Ro(t) {
    return Qe(new pc(t))
}

function jU(t) {
    return Qe(new S(4e3, !1))
}

function BU(t) {
    return Qe(vM(!1, sn.GuardRejected))
}
var bv = class {
        constructor(e, n) {
            this.urlSerializer = e, this.urlTree = n
        }
        lineralizeSegments(e, n) {
            let r = [],
                i = n.root;
            for (;;) {
                if (r = r.concat(i.segments), i.numberOfChildren === 0) return k(r);
                if (i.numberOfChildren > 1 || !i.children[se]) return jU(e.redirectTo);
                i = i.children[se]
            }
        }
        applyRedirectCommands(e, n, r) {
            let i = this.applyRedirectCreateUrlTree(n, this.urlSerializer.parse(n), e, r);
            if (n.startsWith("/")) throw new gh(i);
            return i
        }
        applyRedirectCreateUrlTree(e, n, r, i) {
            let s = this.createSegmentGroup(e, n.root, r, i);
            return new pi(s, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment)
        }
        createQueryParams(e, n) {
            let r = {};
            return Object.entries(e).forEach(([i, s]) => {
                if (typeof s == "string" && s.startsWith(":")) {
                    let a = s.substring(1);
                    r[i] = n[a]
                } else r[i] = s
            }), r
        }
        createSegmentGroup(e, n, r, i) {
            let s = this.createSegments(e, n.segments, r, i),
                o = {};
            return Object.entries(n.children).forEach(([a, c]) => {
                o[a] = this.createSegmentGroup(e, c, r, i)
            }), new Se(s, o)
        }
        createSegments(e, n, r, i) {
            return n.map(s => s.path.startsWith(":") ? this.findPosParam(e, s, i) : this.findOrReturn(s, r))
        }
        findPosParam(e, n, r) {
            let i = r[n.path.substring(1)];
            if (!i) throw new S(4001, !1);
            return i
        }
        findOrReturn(e, n) {
            let r = 0;
            for (let i of n) {
                if (i.path === e.path) return n.splice(r), i;
                r++
            }
            return e
        }
    },
    Dv = {
        matched: !1,
        consumedSegments: [],
        remainingSegments: [],
        parameters: {},
        positionalParamSegments: {}
    };

function zU(t, e, n, r, i) {
    let s = xv(t, e, n);
    return s.matched ? (r = yU(e, r), UU(r, e, n, i).pipe(Z(o => o === !0 ? s : _({}, Dv)))) : k(s)
}

function xv(t, e, n) {
    if (e.path === "**") return $U(n);
    if (e.path === "") return e.pathMatch === "full" && (t.hasChildren() || n.length > 0) ? _({}, Dv) : {
        matched: !0,
        consumedSegments: [],
        remainingSegments: n,
        parameters: {},
        positionalParamSegments: {}
    };
    let i = (e.matcher || UV)(n, t, e);
    if (!i) return _({}, Dv);
    let s = {};
    Object.entries(i.posParams ? ? {}).forEach(([a, c]) => {
        s[a] = c.path
    });
    let o = i.consumed.length > 0 ? _(_({}, s), i.consumed[i.consumed.length - 1].parameters) : s;
    return {
        matched: !0,
        consumedSegments: i.consumed,
        remainingSegments: n.slice(i.consumed.length),
        parameters: o,
        positionalParamSegments: i.posParams ? ? {}
    }
}

function $U(t) {
    return {
        matched: !0,
        parameters: t.length > 0 ? eM(t).parameters : {},
        consumedSegments: t,
        remainingSegments: [],
        positionalParamSegments: {}
    }
}

function KS(t, e, n, r) {
    return n.length > 0 && GU(t, n, r) ? {
        segmentGroup: new Se(e, HU(r, new Se(n, t.children))),
        slicedSegments: []
    } : n.length === 0 && ZU(t, n, r) ? {
        segmentGroup: new Se(t.segments, WU(t, n, r, t.children)),
        slicedSegments: n
    } : {
        segmentGroup: new Se(t.segments, t.children),
        slicedSegments: n
    }
}

function WU(t, e, n, r) {
    let i = {};
    for (let s of n)
        if (wh(t, e, s) && !r[ar(s)]) {
            let o = new Se([], {});
            i[ar(s)] = o
        }
    return _(_({}, r), i)
}

function HU(t, e) {
    let n = {};
    n[se] = e;
    for (let r of t)
        if (r.path === "" && ar(r) !== se) {
            let i = new Se([], {});
            n[ar(r)] = i
        }
    return n
}

function GU(t, e, n) {
    return n.some(r => wh(t, e, r) && ar(r) !== se)
}

function ZU(t, e, n) {
    return n.some(r => wh(t, e, r))
}

function wh(t, e, n) {
    return (t.hasChildren() || e.length > 0) && n.pathMatch === "full" ? !1 : n.path === ""
}

function QU(t, e, n, r) {
    return ar(t) !== r && (r === se || !wh(e, n, t)) ? !1 : xv(e, t, n).matched
}

function qU(t, e, n) {
    return e.length === 0 && !t.children[n]
}
var Ev = class {};

function KU(t, e, n, r, i, s, o = "emptyOnly") {
    return new Cv(t, e, n, r, i, o, s).recognize()
}
var YU = 31,
    Cv = class {
        constructor(e, n, r, i, s, o, a) {
            this.injector = e, this.configLoader = n, this.rootComponentType = r, this.config = i, this.urlTree = s, this.paramsInheritanceStrategy = o, this.urlSerializer = a, this.applyRedirects = new bv(this.urlSerializer, this.urlTree), this.absoluteRedirectCount = 0, this.allowRedirects = !0
        }
        noMatchError(e) {
            return new S(4002, `'${e.segmentGroup}'`)
        }
        recognize() {
            let e = KS(this.urlTree.root, [], [], this.config).segmentGroup;
            return this.match(e).pipe(Z(n => {
                let r = new hc([], Object.freeze({}), Object.freeze(_({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, se, this.rootComponentType, null, {}),
                    i = new rn(r, n),
                    s = new fh("", i),
                    o = iU(r, [], this.urlTree.queryParams, this.urlTree.fragment);
                return o.queryParams = this.urlTree.queryParams, s.url = this.urlSerializer.serialize(o), this.inheritParamsAndData(s._root, null), {
                    state: s,
                    tree: o
                }
            }))
        }
        match(e) {
            return this.processSegmentGroup(this.injector, this.config, e, se).pipe(yt(r => {
                if (r instanceof gh) return this.urlTree = r.urlTree, this.match(r.urlTree.root);
                throw r instanceof pc ? this.noMatchError(r) : r
            }))
        }
        inheritParamsAndData(e, n) {
            let r = e.value,
                i = Mv(r, n, this.paramsInheritanceStrategy);
            r.params = Object.freeze(i.params), r.data = Object.freeze(i.data), e.children.forEach(s => this.inheritParamsAndData(s, r))
        }
        processSegmentGroup(e, n, r, i) {
            return r.segments.length === 0 && r.hasChildren() ? this.processChildren(e, n, r) : this.processSegment(e, n, r, r.segments, i, !0).pipe(Z(s => s instanceof rn ? [s] : []))
        }
        processChildren(e, n, r) {
            let i = [];
            for (let s of Object.keys(r.children)) s === "primary" ? i.unshift(s) : i.push(s);
            return le(i).pipe(nt(s => {
                let o = r.children[s],
                    a = vU(n, s);
                return this.processSegmentGroup(e, a, o, s)
            }), vp((s, o) => (s.push(...o), s)), qr(null), yp(), qe(s => {
                if (s === null) return Ro(r);
                let o = DM(s);
                return JU(o), k(o)
            }))
        }
        processSegment(e, n, r, i, s, o) {
            return le(n).pipe(nt(a => this.processSegmentAgainstRoute(a._injector ? ? e, n, a, r, i, s, o).pipe(yt(c => {
                if (c instanceof pc) return k(null);
                throw c
            }))), kt(a => !!a), yt(a => {
                if (_M(a)) return qU(r, i, s) ? k(new Ev) : Ro(r);
                throw a
            }))
        }
        processSegmentAgainstRoute(e, n, r, i, s, o, a) {
            return QU(r, i, s, o) ? r.redirectTo === void 0 ? this.matchSegmentAgainstRoute(e, i, r, s, o) : this.allowRedirects && a ? this.expandSegmentAgainstRouteUsingRedirect(e, i, n, r, s, o) : Ro(i) : Ro(i)
        }
        expandSegmentAgainstRouteUsingRedirect(e, n, r, i, s, o) {
            let {
                matched: a,
                consumedSegments: c,
                positionalParamSegments: l,
                remainingSegments: u
            } = xv(n, i, s);
            if (!a) return Ro(n);
            i.redirectTo.startsWith("/") && (this.absoluteRedirectCount++, this.absoluteRedirectCount > YU && (this.allowRedirects = !1));
            let d = this.applyRedirects.applyRedirectCommands(c, i.redirectTo, l);
            return this.applyRedirects.lineralizeSegments(i, d).pipe(qe(h => this.processSegment(e, r, n, h.concat(u), o, !1)))
        }
        matchSegmentAgainstRoute(e, n, r, i, s) {
            let o = zU(n, r, i, e, this.urlSerializer);
            return r.path === "**" && (n.children = {}), o.pipe(Je(a => a.matched ? (e = r._injector ? ? e, this.getChildConfig(e, r, i).pipe(Je(({
                routes: c
            }) => {
                let l = r._loadedInjector ? ? e,
                    {
                        consumedSegments: u,
                        remainingSegments: d,
                        parameters: h
                    } = a,
                    f = new hc(u, h, Object.freeze(_({}, this.urlTree.queryParams)), this.urlTree.fragment, e2(r), ar(r), r.component ? ? r._loadedComponent ? ? null, r, t2(r)),
                    {
                        segmentGroup: p,
                        slicedSegments: g
                    } = KS(n, u, d, c);
                if (g.length === 0 && p.hasChildren()) return this.processChildren(l, c, p).pipe(Z(y => y === null ? null : new rn(f, y)));
                if (c.length === 0 && g.length === 0) return k(new rn(f, []));
                let m = ar(r) === s;
                return this.processSegment(l, c, p, g, m ? se : s, !0).pipe(Z(y => new rn(f, y instanceof rn ? [y] : [])))
            }))) : Ro(n)))
        }
        getChildConfig(e, n, r) {
            return n.children ? k({
                routes: n.children,
                injector: e
            }) : n.loadChildren ? n._loadedRoutes !== void 0 ? k({
                routes: n._loadedRoutes,
                injector: n._loadedInjector
            }) : VU(e, n, r, this.urlSerializer).pipe(qe(i => i ? this.configLoader.loadChildren(e, n).pipe(ve(s => {
                n._loadedRoutes = s.routes, n._loadedInjector = s.injector
            })) : BU(n))) : k({
                routes: [],
                injector: e
            })
        }
    };

function JU(t) {
    t.sort((e, n) => e.value.outlet === se ? -1 : n.value.outlet === se ? 1 : e.value.outlet.localeCompare(n.value.outlet))
}

function XU(t) {
    let e = t.value.routeConfig;
    return e && e.path === ""
}

function DM(t) {
    let e = [],
        n = new Set;
    for (let r of t) {
        if (!XU(r)) {
            e.push(r);
            continue
        }
        let i = e.find(s => r.value.routeConfig === s.value.routeConfig);
        i !== void 0 ? (i.children.push(...r.children), n.add(i)) : e.push(r)
    }
    for (let r of n) {
        let i = DM(r.children);
        e.push(new rn(r.value, i))
    }
    return e.filter(r => !n.has(r))
}

function e2(t) {
    return t.data || {}
}

function t2(t) {
    return t.resolve || {}
}

function n2(t, e, n, r, i, s) {
    return qe(o => KU(t, e, n, r, o.extractedUrl, i, s).pipe(Z(({
        state: a,
        tree: c
    }) => Q(_({}, o), {
        targetSnapshot: a,
        urlAfterRedirects: c
    }))))
}

function r2(t, e) {
    return qe(n => {
        let {
            targetSnapshot: r,
            guards: {
                canActivateChecks: i
            }
        } = n;
        if (!i.length) return k(n);
        let s = new Set(i.map(c => c.route)),
            o = new Set;
        for (let c of s)
            if (!o.has(c))
                for (let l of EM(c)) o.add(l);
        let a = 0;
        return le(o).pipe(nt(c => s.has(c) ? i2(c, r, t, e) : (c.data = Mv(c, c.parent, t).resolve, k(void 0))), ve(() => a++), Gs(1), qe(c => a === o.size ? k(n) : Ye))
    })
}

function EM(t) {
    let e = t.children.map(n => EM(n)).flat();
    return [t, ...e]
}

function i2(t, e, n, r) {
    let i = t.routeConfig,
        s = t._resolve;
    return i ? .title !== void 0 && !gM(i) && (s[gc] = i.title), s2(s, t, e, r).pipe(Z(o => (t._resolvedData = o, t.data = Mv(t, t.parent, n).resolve, null)))
}

function s2(t, e, n, r) {
    let i = tv(t);
    if (i.length === 0) return k({});
    let s = {};
    return le(i).pipe(qe(o => o2(t[o], e, n, r).pipe(kt(), ve(a => {
        s[o] = a
    }))), Gs(1), gp(s), yt(o => _M(o) ? Ye : Qe(o)))
}

function o2(t, e, n, r) {
    let i = wc(e) ? ? r,
        s = jo(t, i),
        o = s.resolve ? s.resolve(e, n) : Ln(i, () => s(e, n));
    return yi(o)
}

function Xy(t) {
    return Je(e => {
        let n = t(e);
        return n ? le(n).pipe(Z(() => e)) : k(e)
    })
}
var CM = (() => {
        let e = class e {
            buildTitle(r) {
                let i, s = r.root;
                for (; s !== void 0;) i = this.getResolvedTitleForRoute(s) ? ? i, s = s.children.find(o => o.outlet === se);
                return i
            }
            getResolvedTitleForRoute(r) {
                return r.data[gc]
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: () => M(a2),
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    a2 = (() => {
        let e = class e extends CM {
            constructor(r) {
                super(), this.title = r
            }
            updateTitle(r) {
                let i = this.buildTitle(r);
                i !== void 0 && this.title.setTitle(i)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(NC))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    bc = new R("", {
        providedIn: "root",
        factory: () => ({})
    }),
    mh = new R(""),
    Av = (() => {
        let e = class e {
            constructor() {
                this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap, this.compiler = M(ad)
            }
            loadComponent(r) {
                if (this.componentLoaders.get(r)) return this.componentLoaders.get(r);
                if (r._loadedComponent) return k(r._loadedComponent);
                this.onLoadStartListener && this.onLoadStartListener(r);
                let i = yi(r.loadComponent()).pipe(Z(SM), ve(o => {
                        this.onLoadEndListener && this.onLoadEndListener(r), r._loadedComponent = o
                    }), Ft(() => {
                        this.componentLoaders.delete(r)
                    })),
                    s = new js(i, () => new Me).pipe(Us());
                return this.componentLoaders.set(r, s), s
            }
            loadChildren(r, i) {
                if (this.childrenLoaders.get(i)) return this.childrenLoaders.get(i);
                if (i._loadedRoutes) return k({
                    routes: i._loadedRoutes,
                    injector: i._loadedInjector
                });
                this.onLoadStartListener && this.onLoadStartListener(i);
                let o = c2(i, this.compiler, r, this.onLoadEndListener).pipe(Ft(() => {
                        this.childrenLoaders.delete(i)
                    })),
                    a = new js(o, () => new Me).pipe(Us());
                return this.childrenLoaders.set(i, a), a
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })();

function c2(t, e, n, r) {
    return yi(t.loadChildren()).pipe(Z(SM), qe(i => i instanceof Ia || Array.isArray(i) ? k(i) : le(e.compileModuleAsync(i))), Z(i => {
        r && r(t);
        let s, o, a = !1;
        return Array.isArray(i) ? (o = i, a = !0) : (s = i.create(n).injector, o = s.get(mh, [], {
            optional: !0,
            self: !0
        }).flat()), {
            routes: o.map(Tv),
            injector: s
        }
    }))
}

function l2(t) {
    return t && typeof t == "object" && "default" in t
}

function SM(t) {
    return l2(t) ? t.default : t
}
var Nv = (() => {
        let e = class e {};
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: () => M(u2),
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    u2 = (() => {
        let e = class e {
            shouldProcessUrl(r) {
                return !0
            }
            extract(r) {
                return r
            }
            merge(r, i) {
                return r
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    MM = new R(""),
    IM = new R("");

function d2(t, e, n) {
    let r = t.get(IM),
        i = t.get(ke);
    return t.get(ye).runOutsideAngular(() => {
        if (!i.startViewTransition || r.skipNextTransition) return r.skipNextTransition = !1, Promise.resolve();
        let s, o = new Promise(l => {
                s = l
            }),
            a = i.startViewTransition(() => (s(), h2(t))),
            {
                onViewTransitionCreated: c
            } = r;
        return c && Ln(t, () => c({
            transition: a,
            from: e,
            to: n
        })), o
    })
}

function h2(t) {
    return new Promise(e => {
        _m(e, {
            injector: t
        })
    })
}
var Rv = (() => {
    let e = class e {
        get hasRequestedNavigation() {
            return this.navigationId !== 0
        }
        constructor() {
            this.currentNavigation = null, this.currentTransition = null, this.lastSuccessfulNavigation = null, this.events = new Me, this.transitionAbortSubject = new Me, this.configLoader = M(Av), this.environmentInjector = M(Ut), this.urlSerializer = M(mc), this.rootContexts = M(yc), this.location = M(ai), this.inputBindingEnabled = M(vh, {
                optional: !0
            }) !== null, this.titleStrategy = M(CM), this.options = M(bc, {
                optional: !0
            }) || {}, this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlHandlingStrategy = M(Nv), this.createViewTransition = M(MM, {
                optional: !0
            }), this.navigationId = 0, this.afterPreactivation = () => k(void 0), this.rootComponentType = null;
            let r = s => this.events.next(new lv(s)),
                i = s => this.events.next(new uv(s));
            this.configLoader.onLoadEndListener = i, this.configLoader.onLoadStartListener = r
        }
        complete() {
            this.transitions ? .complete()
        }
        handleNavigationRequest(r) {
            let i = ++this.navigationId;
            this.transitions ? .next(Q(_(_({}, this.transitions.value), r), {
                id: i
            }))
        }
        setupNavigations(r, i, s) {
            return this.transitions = new Ze({
                id: 0,
                currentUrlTree: i,
                currentRawUrl: i,
                extractedUrl: this.urlHandlingStrategy.extract(i),
                urlAfterRedirects: this.urlHandlingStrategy.extract(i),
                rawUrl: i,
                extras: {},
                resolve: null,
                reject: null,
                promise: Promise.resolve(!0),
                source: sc,
                restoredState: null,
                currentSnapshot: s.snapshot,
                targetSnapshot: null,
                currentRouterState: s,
                targetRouterState: null,
                guards: {
                    canActivateChecks: [],
                    canDeactivateChecks: []
                },
                guardsResult: null
            }), this.transitions.pipe(Fe(o => o.id !== 0), Z(o => Q(_({}, o), {
                extractedUrl: this.urlHandlingStrategy.extract(o.rawUrl)
            })), Je(o => {
                let a = !1,
                    c = !1;
                return k(o).pipe(Je(l => {
                    if (this.navigationId > o.id) return this.cancelNavigationTransition(o, "", sn.SupersededByNewNavigation), Ye;
                    this.currentTransition = o, this.currentNavigation = {
                        id: l.id,
                        initialUrl: l.rawUrl,
                        extractedUrl: l.extractedUrl,
                        trigger: l.source,
                        extras: l.extras,
                        previousNavigation: this.lastSuccessfulNavigation ? Q(_({}, this.lastSuccessfulNavigation), {
                            previousNavigation: null
                        }) : null
                    };
                    let u = !r.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl(),
                        d = l.extras.onSameUrlNavigation ? ? r.onSameUrlNavigation;
                    if (!u && d !== "reload") {
                        let h = "";
                        return this.events.next(new mi(l.id, this.urlSerializer.serialize(l.rawUrl), h, ch.IgnoredSameUrlNavigation)), l.resolve(null), Ye
                    }
                    if (this.urlHandlingStrategy.shouldProcessUrl(l.rawUrl)) return k(l).pipe(Je(h => {
                        let f = this.transitions ? .getValue();
                        return this.events.next(new Vo(h.id, this.urlSerializer.serialize(h.extractedUrl), h.source, h.restoredState)), f !== this.transitions ? .getValue() ? Ye : Promise.resolve(h)
                    }), n2(this.environmentInjector, this.configLoader, this.rootComponentType, r.config, this.urlSerializer, this.paramsInheritanceStrategy), ve(h => {
                        o.targetSnapshot = h.targetSnapshot, o.urlAfterRedirects = h.urlAfterRedirects, this.currentNavigation = Q(_({}, this.currentNavigation), {
                            finalUrl: h.urlAfterRedirects
                        });
                        let f = new lh(h.id, this.urlSerializer.serialize(h.extractedUrl), this.urlSerializer.serialize(h.urlAfterRedirects), h.targetSnapshot);
                        this.events.next(f)
                    }));
                    if (u && this.urlHandlingStrategy.shouldProcessUrl(l.currentRawUrl)) {
                        let {
                            id: h,
                            extractedUrl: f,
                            source: p,
                            restoredState: g,
                            extras: m
                        } = l, y = new Vo(h, this.urlSerializer.serialize(f), p, g);
                        this.events.next(y);
                        let E = fM(this.rootComponentType).snapshot;
                        return this.currentTransition = o = Q(_({}, l), {
                            targetSnapshot: E,
                            urlAfterRedirects: f,
                            extras: Q(_({}, m), {
                                skipLocationChange: !1,
                                replaceUrl: !1
                            })
                        }), this.currentNavigation.finalUrl = f, k(o)
                    } else {
                        let h = "";
                        return this.events.next(new mi(l.id, this.urlSerializer.serialize(l.extractedUrl), h, ch.IgnoredByUrlHandlingStrategy)), l.resolve(null), Ye
                    }
                }), ve(l => {
                    let u = new sv(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot);
                    this.events.next(u)
                }), Z(l => (this.currentTransition = o = Q(_({}, l), {
                    guards: _U(l.targetSnapshot, l.currentSnapshot, this.rootContexts)
                }), o)), AU(this.environmentInjector, l => this.events.next(l)), ve(l => {
                    if (o.guardsResult = l.guardsResult, Lo(l.guardsResult)) throw yM(this.urlSerializer, l.guardsResult);
                    let u = new ov(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot, !!l.guardsResult);
                    this.events.next(u)
                }), Fe(l => l.guardsResult ? !0 : (this.cancelNavigationTransition(l, "", sn.GuardRejected), !1)), Xy(l => {
                    if (l.guards.canActivateChecks.length) return k(l).pipe(ve(u => {
                        let d = new av(u.id, this.urlSerializer.serialize(u.extractedUrl), this.urlSerializer.serialize(u.urlAfterRedirects), u.targetSnapshot);
                        this.events.next(d)
                    }), Je(u => {
                        let d = !1;
                        return k(u).pipe(r2(this.paramsInheritanceStrategy, this.environmentInjector), ve({
                            next: () => d = !0,
                            complete: () => {
                                d || this.cancelNavigationTransition(u, "", sn.NoDataFromResolver)
                            }
                        }))
                    }), ve(u => {
                        let d = new cv(u.id, this.urlSerializer.serialize(u.extractedUrl), this.urlSerializer.serialize(u.urlAfterRedirects), u.targetSnapshot);
                        this.events.next(d)
                    }))
                }), Xy(l => {
                    let u = d => {
                        let h = [];
                        d.routeConfig ? .loadComponent && !d.routeConfig._loadedComponent && h.push(this.configLoader.loadComponent(d.routeConfig).pipe(ve(f => {
                            d.component = f
                        }), Z(() => {})));
                        for (let f of d.children) h.push(...u(f));
                        return h
                    };
                    return Ot(u(l.targetSnapshot.root)).pipe(qr(null), vt(1))
                }), Xy(() => this.afterPreactivation()), Je(() => {
                    let {
                        currentSnapshot: l,
                        targetSnapshot: u
                    } = o, d = this.createViewTransition ? .(this.environmentInjector, l.root, u.root);
                    return d ? le(d).pipe(Z(() => o)) : k(o)
                }), Z(l => {
                    let u = hU(r.routeReuseStrategy, l.targetSnapshot, l.currentRouterState);
                    return this.currentTransition = o = Q(_({}, l), {
                        targetRouterState: u
                    }), this.currentNavigation.targetRouterState = u, o
                }), ve(() => {
                    this.events.next(new uc)
                }), wU(this.rootContexts, r.routeReuseStrategy, l => this.events.next(l), this.inputBindingEnabled), vt(1), ve({
                    next: l => {
                        a = !0, this.lastSuccessfulNavigation = this.currentNavigation, this.events.next(new Fr(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects))), this.titleStrategy ? .updateTitle(l.targetRouterState.snapshot), l.resolve(!0)
                    },
                    complete: () => {
                        a = !0
                    }
                }), Rn(this.transitionAbortSubject.pipe(ve(l => {
                    throw l
                }))), Ft(() => {
                    !a && !c && this.cancelNavigationTransition(o, "", sn.SupersededByNewNavigation), this.currentTransition ? .id === o.id && (this.currentNavigation = null, this.currentTransition = null)
                }), yt(l => {
                    if (c = !0, wM(l)) this.events.next(new gi(o.id, this.urlSerializer.serialize(o.extractedUrl), l.message, l.cancellationCode)), gU(l) ? this.events.next(new dc(l.url)) : o.resolve(!1);
                    else {
                        this.events.next(new lc(o.id, this.urlSerializer.serialize(o.extractedUrl), l, o.targetSnapshot ? ? void 0));
                        try {
                            o.resolve(r.errorHandler(l))
                        } catch (u) {
                            this.options.resolveNavigationPromiseOnError ? o.resolve(!1) : o.reject(u)
                        }
                    }
                    return Ye
                }))
            }))
        }
        cancelNavigationTransition(r, i, s) {
            let o = new gi(r.id, this.urlSerializer.serialize(r.extractedUrl), i, s);
            this.events.next(o), r.resolve(!1)
        }
        isUpdatingInternalState() {
            return this.currentTransition ? .extractedUrl.toString() !== this.currentTransition ? .currentUrlTree.toString()
        }
        isUpdatedBrowserUrl() {
            return this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))).toString() !== this.currentTransition ? .extractedUrl.toString() && !this.currentTransition ? .extras.skipLocationChange
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
})();

function f2(t) {
    return t !== sc
}
var p2 = (() => {
        let e = class e {};
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: () => M(g2),
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    Sv = class {
        shouldDetach(e) {
            return !1
        }
        store(e, n) {}
        shouldAttach(e) {
            return !1
        }
        retrieve(e) {
            return null
        }
        shouldReuseRoute(e, n) {
            return e.routeConfig === n.routeConfig
        }
    },
    g2 = (() => {
        let e = class e extends Sv {};
        e.\u0275fac = (() => {
            let r;
            return function(s) {
                return (r || (r = Xn(e)))(s || e)
            }
        })(), e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    TM = (() => {
        let e = class e {};
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: () => M(m2),
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    m2 = (() => {
        let e = class e extends TM {
            constructor() {
                super(...arguments), this.location = M(ai), this.urlSerializer = M(mc), this.options = M(bc, {
                    optional: !0
                }) || {}, this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.urlHandlingStrategy = M(Nv), this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.currentUrlTree = new pi, this.rawUrlTree = this.currentUrlTree, this.currentPageId = 0, this.lastSuccessfulId = -1, this.routerState = fM(null), this.stateMemento = this.createStateMemento()
            }
            getCurrentUrlTree() {
                return this.currentUrlTree
            }
            getRawUrlTree() {
                return this.rawUrlTree
            }
            restoredState() {
                return this.location.getState()
            }
            get browserPageId() {
                return this.canceledNavigationResolution !== "computed" ? this.currentPageId : this.restoredState() ? .\u0275routerPageId ? ? this.currentPageId
            }
            getRouterState() {
                return this.routerState
            }
            createStateMemento() {
                return {
                    rawUrlTree: this.rawUrlTree,
                    currentUrlTree: this.currentUrlTree,
                    routerState: this.routerState
                }
            }
            registerNonRouterCurrentEntryChangeListener(r) {
                return this.location.subscribe(i => {
                    i.type === "popstate" && r(i.url, i.state)
                })
            }
            handleRouterEvent(r, i) {
                if (r instanceof Vo) this.stateMemento = this.createStateMemento();
                else if (r instanceof mi) this.rawUrlTree = i.initialUrl;
                else if (r instanceof lh) {
                    if (this.urlUpdateStrategy === "eager" && !i.extras.skipLocationChange) {
                        let s = this.urlHandlingStrategy.merge(i.finalUrl, i.initialUrl);
                        this.setBrowserUrl(s, i)
                    }
                } else r instanceof uc ? (this.currentUrlTree = i.finalUrl, this.rawUrlTree = this.urlHandlingStrategy.merge(i.finalUrl, i.initialUrl), this.routerState = i.targetRouterState, this.urlUpdateStrategy === "deferred" && (i.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, i))) : r instanceof gi && (r.code === sn.GuardRejected || r.code === sn.NoDataFromResolver) ? this.restoreHistory(i) : r instanceof lc ? this.restoreHistory(i, !0) : r instanceof Fr && (this.lastSuccessfulId = r.id, this.currentPageId = this.browserPageId)
            }
            setBrowserUrl(r, i) {
                let s = this.urlSerializer.serialize(r);
                if (this.location.isCurrentPathEqualTo(s) || i.extras.replaceUrl) {
                    let o = this.browserPageId,
                        a = _(_({}, i.extras.state), this.generateNgRouterState(i.id, o));
                    this.location.replaceState(s, "", a)
                } else {
                    let o = _(_({}, i.extras.state), this.generateNgRouterState(i.id, this.browserPageId + 1));
                    this.location.go(s, "", o)
                }
            }
            restoreHistory(r, i = !1) {
                if (this.canceledNavigationResolution === "computed") {
                    let s = this.browserPageId,
                        o = this.currentPageId - s;
                    o !== 0 ? this.location.historyGo(o) : this.currentUrlTree === r.finalUrl && o === 0 && (this.resetState(r), this.resetUrlToCurrentUrlTree())
                } else this.canceledNavigationResolution === "replace" && (i && this.resetState(r), this.resetUrlToCurrentUrlTree())
            }
            resetState(r) {
                this.routerState = this.stateMemento.routerState, this.currentUrlTree = this.stateMemento.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, r.finalUrl ? ? this.rawUrlTree)
            }
            resetUrlToCurrentUrlTree() {
                this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId))
            }
            generateNgRouterState(r, i) {
                return this.canceledNavigationResolution === "computed" ? {
                    navigationId: r,
                    \u0275routerPageId: i
                } : {
                    navigationId: r
                }
            }
        };
        e.\u0275fac = (() => {
            let r;
            return function(s) {
                return (r || (r = Xn(e)))(s || e)
            }
        })(), e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    rc = function(t) {
        return t[t.COMPLETE = 0] = "COMPLETE", t[t.FAILED = 1] = "FAILED", t[t.REDIRECTING = 2] = "REDIRECTING", t
    }(rc || {});

function xM(t, e) {
    t.events.pipe(Fe(n => n instanceof Fr || n instanceof gi || n instanceof lc || n instanceof mi), Z(n => n instanceof Fr || n instanceof mi ? rc.COMPLETE : (n instanceof gi ? n.code === sn.Redirect || n.code === sn.SupersededByNewNavigation : !1) ? rc.REDIRECTING : rc.FAILED), Fe(n => n !== rc.REDIRECTING), vt(1)).subscribe(() => {
        e()
    })
}

function y2(t) {
    throw t
}
var v2 = {
        paths: "exact",
        fragment: "ignored",
        matrixParams: "ignored",
        queryParams: "exact"
    },
    w2 = {
        paths: "subset",
        fragment: "ignored",
        matrixParams: "ignored",
        queryParams: "subset"
    },
    hs = (() => {
        let e = class e {
            get currentUrlTree() {
                return this.stateManager.getCurrentUrlTree()
            }
            get rawUrlTree() {
                return this.stateManager.getRawUrlTree()
            }
            get events() {
                return this._events
            }
            get routerState() {
                return this.stateManager.getRouterState()
            }
            constructor() {
                this.disposed = !1, this.isNgZoneEnabled = !1, this.console = M(nd), this.stateManager = M(TM), this.options = M(bc, {
                    optional: !0
                }) || {}, this.pendingTasks = M(Yi), this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.navigationTransitions = M(Rv), this.urlSerializer = M(mc), this.location = M(ai), this.urlHandlingStrategy = M(Nv), this._events = new Me, this.errorHandler = this.options.errorHandler || y2, this.navigated = !1, this.routeReuseStrategy = M(p2), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.config = M(mh, {
                    optional: !0
                }) ? .flat() ? ? [], this.componentInputBindingEnabled = !!M(vh, {
                    optional: !0
                }), this.eventsSubscription = new Oe, this.isNgZoneEnabled = M(ye) instanceof ye && ye.isInAngularZone(), this.resetConfig(this.config), this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe({
                    error: r => {
                        this.console.warn(r)
                    }
                }), this.subscribeToNavigationEvents()
            }
            subscribeToNavigationEvents() {
                let r = this.navigationTransitions.events.subscribe(i => {
                    try {
                        let s = this.navigationTransitions.currentTransition,
                            o = this.navigationTransitions.currentNavigation;
                        if (s !== null && o !== null) {
                            if (this.stateManager.handleRouterEvent(i, o), i instanceof gi && i.code !== sn.Redirect && i.code !== sn.SupersededByNewNavigation) this.navigated = !0;
                            else if (i instanceof Fr) this.navigated = !0;
                            else if (i instanceof dc) {
                                let a = this.urlHandlingStrategy.merge(i.url, s.currentRawUrl),
                                    c = {
                                        info: s.extras.info,
                                        skipLocationChange: s.extras.skipLocationChange,
                                        replaceUrl: this.urlUpdateStrategy === "eager" || f2(s.source)
                                    };
                                this.scheduleNavigation(a, sc, null, c, {
                                    resolve: s.resolve,
                                    reject: s.reject,
                                    promise: s.promise
                                })
                            }
                        }
                        b2(i) && this._events.next(i)
                    } catch (s) {
                        this.navigationTransitions.transitionAbortSubject.next(s)
                    }
                });
                this.eventsSubscription.add(r)
            }
            resetRootComponentType(r) {
                this.routerState.root.component = r, this.navigationTransitions.rootComponentType = r
            }
            initialNavigation() {
                this.setUpLocationChangeListener(), this.navigationTransitions.hasRequestedNavigation || this.navigateToSyncWithBrowser(this.location.path(!0), sc, this.stateManager.restoredState())
            }
            setUpLocationChangeListener() {
                this.nonRouterCurrentEntryChangeSubscription ? ? = this.stateManager.registerNonRouterCurrentEntryChangeListener((r, i) => {
                    setTimeout(() => {
                        this.navigateToSyncWithBrowser(r, "popstate", i)
                    }, 0)
                })
            }
            navigateToSyncWithBrowser(r, i, s) {
                let o = {
                        replaceUrl: !0
                    },
                    a = s ? .navigationId ? s : null;
                if (s) {
                    let l = _({}, s);
                    delete l.navigationId, delete l.\u0275routerPageId, Object.keys(l).length !== 0 && (o.state = l)
                }
                let c = this.parseUrl(r);
                this.scheduleNavigation(c, i, a, o)
            }
            get url() {
                return this.serializeUrl(this.currentUrlTree)
            }
            getCurrentNavigation() {
                return this.navigationTransitions.currentNavigation
            }
            get lastSuccessfulNavigation() {
                return this.navigationTransitions.lastSuccessfulNavigation
            }
            resetConfig(r) {
                this.config = r.map(Tv), this.navigated = !1
            }
            ngOnDestroy() {
                this.dispose()
            }
            dispose() {
                this.navigationTransitions.complete(), this.nonRouterCurrentEntryChangeSubscription && (this.nonRouterCurrentEntryChangeSubscription.unsubscribe(), this.nonRouterCurrentEntryChangeSubscription = void 0), this.disposed = !0, this.eventsSubscription.unsubscribe()
            }
            createUrlTree(r, i = {}) {
                let {
                    relativeTo: s,
                    queryParams: o,
                    fragment: a,
                    queryParamsHandling: c,
                    preserveFragment: l
                } = i, u = l ? this.currentUrlTree.fragment : a, d = null;
                switch (c) {
                    case "merge":
                        d = _(_({}, this.currentUrlTree.queryParams), o);
                        break;
                    case "preserve":
                        d = this.currentUrlTree.queryParams;
                        break;
                    default:
                        d = o || null
                }
                d !== null && (d = this.removeEmptyProps(d));
                let h;
                try {
                    let f = s ? s.snapshot : this.routerState.snapshot.root;
                    h = lM(f)
                } catch {
                    (typeof r[0] != "string" || !r[0].startsWith("/")) && (r = []), h = this.currentUrlTree.root
                }
                return uM(h, r, d, u ? ? null)
            }
            navigateByUrl(r, i = {
                skipLocationChange: !1
            }) {
                let s = Lo(r) ? r : this.parseUrl(r),
                    o = this.urlHandlingStrategy.merge(s, this.rawUrlTree);
                return this.scheduleNavigation(o, sc, null, i)
            }
            navigate(r, i = {
                skipLocationChange: !1
            }) {
                return _2(r), this.navigateByUrl(this.createUrlTree(r, i), i)
            }
            serializeUrl(r) {
                return this.urlSerializer.serialize(r)
            }
            parseUrl(r) {
                try {
                    return this.urlSerializer.parse(r)
                } catch {
                    return this.urlSerializer.parse("/")
                }
            }
            isActive(r, i) {
                let s;
                if (i === !0 ? s = _({}, v2) : i === !1 ? s = _({}, w2) : s = i, Lo(r)) return HS(this.currentUrlTree, r, s);
                let o = this.parseUrl(r);
                return HS(this.currentUrlTree, o, s)
            }
            removeEmptyProps(r) {
                return Object.entries(r).reduce((i, [s, o]) => (o != null && (i[s] = o), i), {})
            }
            scheduleNavigation(r, i, s, o, a) {
                if (this.disposed) return Promise.resolve(!1);
                let c, l, u;
                a ? (c = a.resolve, l = a.reject, u = a.promise) : u = new Promise((h, f) => {
                    c = h, l = f
                });
                let d = this.pendingTasks.add();
                return xM(this, () => {
                    queueMicrotask(() => this.pendingTasks.remove(d))
                }), this.navigationTransitions.handleNavigationRequest({
                    source: i,
                    restoredState: s,
                    currentUrlTree: this.currentUrlTree,
                    currentRawUrl: this.currentUrlTree,
                    rawUrl: r,
                    extras: o,
                    resolve: c,
                    reject: l,
                    promise: u,
                    currentSnapshot: this.routerState.snapshot,
                    currentRouterState: this.routerState
                }), u.catch(h => Promise.reject(h))
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })();

function _2(t) {
    for (let e = 0; e < t.length; e++)
        if (t[e] == null) throw new S(4008, !1)
}

function b2(t) {
    return !(t instanceof uc) && !(t instanceof dc)
}
var yh = class {};
var D2 = (() => {
        let e = class e {
            constructor(r, i, s, o, a) {
                this.router = r, this.injector = s, this.preloadingStrategy = o, this.loader = a
            }
            setUpPreloading() {
                this.subscription = this.router.events.pipe(Fe(r => r instanceof Fr), nt(() => this.preload())).subscribe(() => {})
            }
            preload() {
                return this.processRoutes(this.injector, this.router.config)
            }
            ngOnDestroy() {
                this.subscription && this.subscription.unsubscribe()
            }
            processRoutes(r, i) {
                let s = [];
                for (let o of i) {
                    o.providers && !o._injector && (o._injector = Gu(o.providers, r, `Route: ${o.path}`));
                    let a = o._injector ? ? r,
                        c = o._loadedInjector ? ? a;
                    (o.loadChildren && !o._loadedRoutes && o.canLoad === void 0 || o.loadComponent && !o._loadedComponent) && s.push(this.preloadConfig(a, o)), (o.children || o._loadedRoutes) && s.push(this.processRoutes(c, o.children ? ? o._loadedRoutes))
                }
                return le(s).pipe(Qr())
            }
            preloadConfig(r, i) {
                return this.preloadingStrategy.preload(i, () => {
                    let s;
                    i.loadChildren && i.canLoad === void 0 ? s = this.loader.loadChildren(r, i) : s = k(null);
                    let o = s.pipe(qe(a => a === null ? k(void 0) : (i._loadedRoutes = a.routes, i._loadedInjector = a.injector, this.processRoutes(a.injector ? ? r, a.routes))));
                    if (i.loadComponent && !i._loadedComponent) {
                        let a = this.loader.loadComponent(i);
                        return le([o, a]).pipe(Qr())
                    } else return o
                })
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(hs), C(ad), C(Ut), C(yh), C(Av))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac,
            providedIn: "root"
        });
        let t = e;
        return t
    })(),
    AM = new R(""),
    E2 = (() => {
        let e = class e {
            constructor(r, i, s, o, a = {}) {
                this.urlSerializer = r, this.transitions = i, this.viewportScroller = s, this.zone = o, this.options = a, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, a.scrollPositionRestoration || = "disabled", a.anchorScrolling || = "disabled"
            }
            init() {
                this.options.scrollPositionRestoration !== "disabled" && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents()
            }
            createScrollEvents() {
                return this.transitions.events.subscribe(r => {
                    r instanceof Vo ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = r.navigationTrigger, this.restoredId = r.restoredState ? r.restoredState.navigationId : 0) : r instanceof Fr ? (this.lastId = r.id, this.scheduleScrollEvent(r, this.urlSerializer.parse(r.urlAfterRedirects).fragment)) : r instanceof mi && r.code === ch.IgnoredSameUrlNavigation && (this.lastSource = void 0, this.restoredId = 0, this.scheduleScrollEvent(r, this.urlSerializer.parse(r.url).fragment))
                })
            }
            consumeScrollEvents() {
                return this.transitions.events.subscribe(r => {
                    r instanceof uh && (r.position ? this.options.scrollPositionRestoration === "top" ? this.viewportScroller.scrollToPosition([0, 0]) : this.options.scrollPositionRestoration === "enabled" && this.viewportScroller.scrollToPosition(r.position) : r.anchor && this.options.anchorScrolling === "enabled" ? this.viewportScroller.scrollToAnchor(r.anchor) : this.options.scrollPositionRestoration !== "disabled" && this.viewportScroller.scrollToPosition([0, 0]))
                })
            }
            scheduleScrollEvent(r, i) {
                this.zone.runOutsideAngular(() => {
                    setTimeout(() => {
                        this.zone.run(() => {
                            this.transitions.events.next(new uh(r, this.lastSource === "popstate" ? this.store[this.restoredId] : null, i))
                        })
                    }, 0)
                })
            }
            ngOnDestroy() {
                this.routerEventsSubscription ? .unsubscribe(), this.scrollEventsSubscription ? .unsubscribe()
            }
        };
        e.\u0275fac = function(i) {
            nE()
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })();

function C2(t) {
    return t.routerState.root
}

function Dc(t, e) {
    return {\
        u0275kind: t,
        \u0275providers: e
    }
}

function S2() {
    let t = M(bt);
    return e => {
        let n = t.get(Nr);
        if (e !== n.components[0]) return;
        let r = t.get(hs),
            i = t.get(NM);
        t.get(Ov) === 1 && r.initialNavigation(), t.get(RM, null, ue.Optional) ? .setUpPreloading(), t.get(AM, null, ue.Optional) ? .init(), r.resetRootComponentType(n.componentTypes[0]), i.closed || (i.next(), i.complete(), i.unsubscribe())
    }
}
var NM = new R("", {
        factory: () => new Me
    }),
    Ov = new R("", {
        providedIn: "root",
        factory: () => 1
    });

function M2() {
    return Dc(2, [{
        provide: Ov,
        useValue: 0
    }, {
        provide: sd,
        multi: !0,
        deps: [bt],
        useFactory: e => {
            let n = e.get(sC, Promise.resolve());
            return () => n.then(() => new Promise(r => {
                let i = e.get(hs),
                    s = e.get(NM);
                xM(i, () => {
                    r(!0)
                }), e.get(Rv).afterPreactivation = () => (r(!0), s.closed ? k(void 0) : s), i.initialNavigation()
            }))
        }
    }])
}

function I2() {
    return Dc(3, [{
        provide: sd,
        multi: !0,
        useFactory: () => {
            let e = M(hs);
            return () => {
                e.setUpLocationChangeListener()
            }
        }
    }, {
        provide: Ov,
        useValue: 2
    }])
}
var RM = new R("");

function T2(t) {
    return Dc(0, [{
        provide: RM,
        useExisting: D2
    }, {
        provide: yh,
        useExisting: t
    }])
}

function x2() {
    return Dc(8, [qS, {
        provide: vh,
        useExisting: qS
    }])
}

function A2(t) {
    let e = [{
        provide: MM,
        useValue: d2
    }, {
        provide: IM,
        useValue: _({
            skipNextTransition: !!t ? .skipInitialTransition
        }, t)
    }];
    return Dc(9, e)
}
var YS = new R("ROUTER_FORROOT_GUARD"),
    N2 = [ai, {
        provide: mc,
        useClass: ac
    }, hs, yc, {
        provide: or,
        useFactory: C2,
        deps: [hs]
    }, Av, []],
    Fv = (() => {
        let e = class e {
            constructor(r) {}
            static forRoot(r, i) {
                return {
                    ngModule: e,
                    providers: [N2, [], {
                        provide: mh,
                        multi: !0,
                        useValue: r
                    }, {
                        provide: YS,
                        useFactory: k2,
                        deps: [
                            [hs, new Sr, new ho]
                        ]
                    }, {
                        provide: bc,
                        useValue: i || {}
                    }, i ? .useHash ? O2() : F2(), R2(), i ? .preloadingStrategy ? T2(i.preloadingStrategy).\u0275providers : [], i ? .initialNavigation ? P2(i) : [], i ? .bindToComponentInputs ? x2().\u0275providers : [], i ? .enableViewTransitions ? A2().\u0275providers : [], L2()]
                }
            }
            static forChild(r) {
                return {
                    ngModule: e,
                    providers: [{
                        provide: mh,
                        multi: !0,
                        useValue: r
                    }]
                }
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(YS, 8))
        }, e.\u0275mod = xe({
            type: e
        }), e.\u0275inj = Te({});
        let t = e;
        return t
    })();

function R2() {
    return {
        provide: AM,
        useFactory: () => {
            let t = M(uC),
                e = M(ye),
                n = M(bc),
                r = M(Rv),
                i = M(mc);
            return n.scrollOffset && t.setOffset(n.scrollOffset), new E2(i, r, t, e, n)
        }
    }
}

function O2() {
    return {
        provide: es,
        useClass: aC
    }
}

function F2() {
    return {
        provide: es,
        useClass: Vm
    }
}

function k2(t) {
    return "guarded"
}

function P2(t) {
    return [t.initialNavigation === "disabled" ? I2().\u0275providers : [], t.initialNavigation === "enabledBlocking" ? M2().\u0275providers : []]
}
var JS = new R("");

function L2() {
    return [{
        provide: JS,
        useFactory: S2
    }, {
        provide: od,
        multi: !0,
        useExisting: JS
    }]
}
var Pv = [{
    name: "Arabic",
    value: "ar",
    country: "AR",
    flag: "ar"
}, {
    name: "Bulgarian",
    value: "bg",
    country: "BGR",
    flag: "bg"
}, {
    name: "English",
    value: "en",
    country: "US",
    flag: "en"
}, {
    name: "Chinese (simplified)",
    value: "zh-hans",
    country: "CHN",
    flag: "cn"
}, {
    name: "Chinese (traditional) ",
    value: "zh-hant",
    country: "CHN",
    flag: "cn"
}, {
    name: "Czech",
    value: "cz",
    country: "CZE",
    flag: "cz"
}, {
    name: "Dutch",
    value: "nl",
    country: "DT",
    flag: "nl"
}, {
    name: "French",
    value: "fr",
    country: "FR",
    flag: "fr"
}, {
    name: "German",
    value: "de",
    country: "DEU",
    flag: "de"
}, {
    name: "Greek",
    value: "el",
    country: "GRC",
    flag: "el"
}, {
    name: "Hungarian",
    value: "hu",
    country: "HUN",
    flag: "hu"
}, {
    name: "Indonesian",
    value: "id",
    country: "IND",
    flag: "id"
}, {
    name: "Italian",
    value: "it",
    country: "ITA",
    flag: "it"
}, {
    name: "Japanese",
    value: "jp",
    country: "JPN",
    flag: "jp"
}, {
    name: "Korean",
    value: "kr",
    country: "KOR",
    flag: "kr"
}, {
    name: "Polish",
    value: "pl",
    country: "POL",
    flag: "pl"
}, {
    name: "Portuguese",
    value: "pt",
    country: "PRT",
    flag: "pt"
}, {
    name: "Russian",
    value: "ru",
    country: "RUS",
    flag: "ru"
}, {
    name: "Slovak",
    value: "sk",
    country: "SVK",
    flag: "sk"
}, {
    name: "Spanish",
    value: "es",
    country: "ESP",
    flag: "es"
}, {
    name: "Thai",
    value: "th",
    country: "THA",
    flag: "th"
}, {
    name: "Turkish",
    value: "tr",
    country: "TUR",
    flag: "tr"
}, {
    name: "Vietnamese",
    value: "vn",
    country: "VNM",
    flag: "vn"
}];

function cr(t) {
    let e = i => {
            let s = document.cookie.match(new RegExp("(?:^|; )" + i.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1") + "=([^;]*)"));
            return s ? decodeURIComponent(s[1]) : void 0
        },
        n = new URLSearchParams(document.location.search),
        r = e(t);
    return n.get(t) && (r = n.get(t), document.cookie = t + "=" + r + ";max-age=15778462"), r || ""
}

function _h(t) {
    return Pv.filter(n => n.value === t).length > 0
}
var lr = (() => {
    let e = class e {
        constructor(r) {
            this.translate = r, this.isConnected = !1, this.eventsSubject = new Me, this.count = 0, this.endValue = 60 * 15, this.langUpdated = new Me, this.netWork = new Ze(!0), this.selectedLanguage = "en", this.ignoreList = ["api.moonpay", "ramp_transaction", "coingecko"], this.daysCounter = new Ze({
                _days: 0,
                _hours: 0,
                _minutes: 0,
                _seconds: 0,
                _diff: 0
            }), this.stopper = new Me
        }
        broadcastEvent(r, i) {
            this.eventsSubject.next({
                key: r,
                value: i
            })
        }
        getEvent(r) {
            return this.eventsSubject.asObservable().pipe(Fe(i => i.key === r), Z(i => i.value))
        }
        checkList(r) {
            return !(this.ignoreList.filter(s => r.includes(s)).length > 0)
        }
        setNetwork() {
            this.netWork.next(!0)
        }
        getNetwork() {
            return this.netWork.asObservable()
        }
        getLang() {
            return this.langUpdated.asObservable()
        }
        setLang(r) {
            localStorage.setItem("currentlang", r), this.currentLanguage = r, this.langUpdated.next(r || "en")
        }
        scrollToFn(r) {
            window.location.hash = r, console.log(window.location.hash, "window.location.hash"), window.location.pathname = "/" + this.currentLanguage
        }
        setCounter(r) {
            console.log("endDate", r);
            let i;
            pp(1e3).pipe(Rn(this.stopper), Z(s => {
                i = r - Date.parse(new Date().toString())
            })).subscribe(s => {
                if (i <= 0) this.broadcastEvent("PRESALE-END", !0), this.stopper.next(!1);
                else {
                    let o = {
                        _days: this.getDays(i) < 10 ? "0" + this.getDays(i) : this.getDays(i),
                        _hours: this.getHours(i) < 10 ? "0" + this.getHours(i) : this.getHours(i),
                        _minutes: this.getMinutes(i) < 10 ? "0" + this.getMinutes(i) : this.getMinutes(i),
                        _seconds: this.getSeconds(i) < 10 ? "0" + this.getSeconds(i) : this.getSeconds(i),
                        _diff: i
                    };
                    this.daysCounter.next(o)
                }
            })
        }
        getCounter() {
            return this.daysCounter.asObservable()
        }
        getDays(r) {
            return Math.floor(r / (1e3 * 60 * 60 * 24))
        }
        getHours(r) {
            return Math.floor(r / (1e3 * 60 * 60) % 24)
        }
        getMinutes(r) {
            return Math.floor(r / 1e3 / 60 % 60)
        }
        getSeconds(r) {
            return Math.floor(r / 1e3 % 60)
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)(C(rr))
    }, e.\u0275prov = I({
        token: e,
        factory: e.\u0275fac,
        providedIn: "root"
    });
    let t = e;
    return t
})();
var OM = (() => {
    let e = class e {
        constructor(r, i, s) {
            this.route = r, this.translate = i, this.eventService = s, this.route.params.subscribe(o => {
                let a = o.lang;
                if (a && _h(a)) this.lang = a;
                else {
                    let c = localStorage.getItem("currentlang");
                    if (c && _h(c)) this.lang = c;
                    else {
                        let l = navigator.language ? .split("-")[0];
                        this.lang = l && _h(l) ? l : "en"
                    }
                }
            }), this.translate.setDefaultLang("en"), this.translate.use(this.lang), this.eventService.setLang(this.lang)
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)(O(or), O(rr), O(lr))
    }, e.\u0275cmp = He({
        type: e,
        selectors: [
            ["app-language"]
        ],
        decls: 1,
        vars: 0,
        template: function(i, s) {
            i & 1 && fe(0, "router-outlet")
        },
        dependencies: [vc]
    });
    let t = e;
    return t
})();
_r();
var Mn = Hn(vA());
_r();
_r();
var d0 = Hn(Hf()),
    L$ = Hn(Hf()),
    Jo = Hn(Q0()),
    Le = Hn(jM()),
    z = Hn($M());
wA();

function Qo(t) {
    let e = t.length;
    for (; --e >= 0;) t[e] = 0
}
var uj = 0,
    TI = 1,
    dj = 2,
    hj = 3,
    fj = 258,
    mw = 29,
    zc = 256,
    Fc = zc + 1 + mw,
    Ho = 30,
    yw = 19,
    xI = 2 * Fc + 1,
    ps = 15,
    Zv = 16,
    pj = 7,
    vw = 256,
    AI = 16,
    NI = 17,
    RI = 18,
    aw = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
    Bh = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
    gj = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
    OI = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
    mj = 512,
    Vr = new Array((Fc + 2) * 2);
Qo(Vr);
var Nc = new Array(Ho * 2);
Qo(Nc);
var kc = new Array(mj);
Qo(kc);
var Pc = new Array(fj - hj + 1);
Qo(Pc);
var ww = new Array(mw);
Qo(ww);
var zh = new Array(Ho);
Qo(zh);

function Qv(t, e, n, r, i) {
    this.static_tree = t, this.extra_bits = e, this.extra_base = n, this.elems = r, this.max_length = i, this.has_stree = t && t.length
}
var FI, kI, PI;

function qv(t, e) {
    this.dyn_tree = t, this.max_code = 0, this.stat_desc = e
}
var LI = t => t < 256 ? kc[t] : kc[256 + (t >>> 7)],
    Lc = (t, e) => {
        t.pending_buf[t.pending++] = e & 255, t.pending_buf[t.pending++] = e >>> 8 & 255
    },
    Ht = (t, e, n) => {
        t.bi_valid > Zv - n ? (t.bi_buf |= e << t.bi_valid & 65535, Lc(t, t.bi_buf), t.bi_buf = e >> Zv - t.bi_valid, t.bi_valid += n - Zv) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += n)
    },
    hr = (t, e, n) => {
        Ht(t, n[e * 2], n[e * 2 + 1])
    },
    VI = (t, e) => {
        let n = 0;
        do n |= t & 1, t >>>= 1, n <<= 1; while (--e > 0);
        return n >>> 1
    },
    yj = t => {
        t.bi_valid === 16 ? (Lc(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = t.bi_buf & 255, t.bi_buf >>= 8, t.bi_valid -= 8)
    },
    vj = (t, e) => {
        let n = e.dyn_tree,
            r = e.max_code,
            i = e.stat_desc.static_tree,
            s = e.stat_desc.has_stree,
            o = e.stat_desc.extra_bits,
            a = e.stat_desc.extra_base,
            c = e.stat_desc.max_length,
            l, u, d, h, f, p, g = 0;
        for (h = 0; h <= ps; h++) t.bl_count[h] = 0;
        for (n[t.heap[t.heap_max] * 2 + 1] = 0, l = t.heap_max + 1; l < xI; l++) u = t.heap[l], h = n[n[u * 2 + 1] * 2 + 1] + 1, h > c && (h = c, g++), n[u * 2 + 1] = h, !(u > r) && (t.bl_count[h]++, f = 0, u >= a && (f = o[u - a]), p = n[u * 2], t.opt_len += p * (h + f), s && (t.static_len += p * (i[u * 2 + 1] + f)));
        if (g !== 0) {
            do {
                for (h = c - 1; t.bl_count[h] === 0;) h--;
                t.bl_count[h]--, t.bl_count[h + 1] += 2, t.bl_count[c]--, g -= 2
            } while (g > 0);
            for (h = c; h !== 0; h--)
                for (u = t.bl_count[h]; u !== 0;) d = t.heap[--l], !(d > r) && (n[d * 2 + 1] !== h && (t.opt_len += (h - n[d * 2 + 1]) * n[d * 2], n[d * 2 + 1] = h), u--)
        }
    },
    UI = (t, e, n) => {
        let r = new Array(ps + 1),
            i = 0,
            s, o;
        for (s = 1; s <= ps; s++) i = i + n[s - 1] << 1, r[s] = i;
        for (o = 0; o <= e; o++) {
            let a = t[o * 2 + 1];
            a !== 0 && (t[o * 2] = VI(r[a]++, a))
        }
    },
    wj = () => {
        let t, e, n, r, i, s = new Array(ps + 1);
        for (n = 0, r = 0; r < mw - 1; r++)
            for (ww[r] = n, t = 0; t < 1 << aw[r]; t++) Pc[n++] = r;
        for (Pc[n - 1] = r, i = 0, r = 0; r < 16; r++)
            for (zh[r] = i, t = 0; t < 1 << Bh[r]; t++) kc[i++] = r;
        for (i >>= 7; r < Ho; r++)
            for (zh[r] = i << 7, t = 0; t < 1 << Bh[r] - 7; t++) kc[256 + i++] = r;
        for (e = 0; e <= ps; e++) s[e] = 0;
        for (t = 0; t <= 143;) Vr[t * 2 + 1] = 8, t++, s[8]++;
        for (; t <= 255;) Vr[t * 2 + 1] = 9, t++, s[9]++;
        for (; t <= 279;) Vr[t * 2 + 1] = 7, t++, s[7]++;
        for (; t <= 287;) Vr[t * 2 + 1] = 8, t++, s[8]++;
        for (UI(Vr, Fc + 1, s), t = 0; t < Ho; t++) Nc[t * 2 + 1] = 5, Nc[t * 2] = VI(t, 5);
        FI = new Qv(Vr, aw, zc + 1, Fc, ps), kI = new Qv(Nc, Bh, 0, Ho, ps), PI = new Qv(new Array(0), gj, 0, yw, pj)
    },
    jI = t => {
        let e;
        for (e = 0; e < Fc; e++) t.dyn_ltree[e * 2] = 0;
        for (e = 0; e < Ho; e++) t.dyn_dtree[e * 2] = 0;
        for (e = 0; e < yw; e++) t.bl_tree[e * 2] = 0;
        t.dyn_ltree[vw * 2] = 1, t.opt_len = t.static_len = 0, t.sym_next = t.matches = 0
    },
    BI = t => {
        t.bi_valid > 8 ? Lc(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0
    },
    WM = (t, e, n, r) => {
        let i = e * 2,
            s = n * 2;
        return t[i] < t[s] || t[i] === t[s] && r[e] <= r[n]
    },
    Kv = (t, e, n) => {
        let r = t.heap[n],
            i = n << 1;
        for (; i <= t.heap_len && (i < t.heap_len && WM(e, t.heap[i + 1], t.heap[i], t.depth) && i++, !WM(e, r, t.heap[i], t.depth));) t.heap[n] = t.heap[i], n = i, i <<= 1;
        t.heap[n] = r
    },
    HM = (t, e, n) => {
        let r, i, s = 0,
            o, a;
        if (t.sym_next !== 0)
            do r = t.pending_buf[t.sym_buf + s++] & 255, r += (t.pending_buf[t.sym_buf + s++] & 255) << 8, i = t.pending_buf[t.sym_buf + s++], r === 0 ? hr(t, i, e) : (o = Pc[i], hr(t, o + zc + 1, e), a = aw[o], a !== 0 && (i -= ww[o], Ht(t, i, a)), r--, o = LI(r), hr(t, o, n), a = Bh[o], a !== 0 && (r -= zh[o], Ht(t, r, a))); while (s < t.sym_next);
        hr(t, vw, e)
    },
    cw = (t, e) => {
        let n = e.dyn_tree,
            r = e.stat_desc.static_tree,
            i = e.stat_desc.has_stree,
            s = e.stat_desc.elems,
            o, a, c = -1,
            l;
        for (t.heap_len = 0, t.heap_max = xI, o = 0; o < s; o++) n[o * 2] !== 0 ? (t.heap[++t.heap_len] = c = o, t.depth[o] = 0) : n[o * 2 + 1] = 0;
        for (; t.heap_len < 2;) l = t.heap[++t.heap_len] = c < 2 ? ++c : 0, n[l * 2] = 1, t.depth[l] = 0, t.opt_len--, i && (t.static_len -= r[l * 2 + 1]);
        for (e.max_code = c, o = t.heap_len >> 1; o >= 1; o--) Kv(t, n, o);
        l = s;
        do o = t.heap[1], t.heap[1] = t.heap[t.heap_len--], Kv(t, n, 1), a = t.heap[1], t.heap[--t.heap_max] = o, t.heap[--t.heap_max] = a, n[l * 2] = n[o * 2] + n[a * 2], t.depth[l] = (t.depth[o] >= t.depth[a] ? t.depth[o] : t.depth[a]) + 1, n[o * 2 + 1] = n[a * 2 + 1] = l, t.heap[1] = l++, Kv(t, n, 1); while (t.heap_len >= 2);
        t.heap[--t.heap_max] = t.heap[1], vj(t, e), UI(n, c, t.bl_count)
    },
    GM = (t, e, n) => {
        let r, i = -1,
            s, o = e[0 * 2 + 1],
            a = 0,
            c = 7,
            l = 4;
        for (o === 0 && (c = 138, l = 3), e[(n + 1) * 2 + 1] = 65535, r = 0; r <= n; r++) s = o, o = e[(r + 1) * 2 + 1], !(++a < c && s === o) && (a < l ? t.bl_tree[s * 2] += a : s !== 0 ? (s !== i && t.bl_tree[s * 2]++, t.bl_tree[AI * 2]++) : a <= 10 ? t.bl_tree[NI * 2]++ : t.bl_tree[RI * 2]++, a = 0, i = s, o === 0 ? (c = 138, l = 3) : s === o ? (c = 6, l = 3) : (c = 7, l = 4))
    },
    ZM = (t, e, n) => {
        let r, i = -1,
            s, o = e[0 * 2 + 1],
            a = 0,
            c = 7,
            l = 4;
        for (o === 0 && (c = 138, l = 3), r = 0; r <= n; r++)
            if (s = o, o = e[(r + 1) * 2 + 1], !(++a < c && s === o)) {
                if (a < l)
                    do hr(t, s, t.bl_tree); while (--a !== 0);
                else s !== 0 ? (s !== i && (hr(t, s, t.bl_tree), a--), hr(t, AI, t.bl_tree), Ht(t, a - 3, 2)) : a <= 10 ? (hr(t, NI, t.bl_tree), Ht(t, a - 3, 3)) : (hr(t, RI, t.bl_tree), Ht(t, a - 11, 7));
                a = 0, i = s, o === 0 ? (c = 138, l = 3) : s === o ? (c = 6, l = 3) : (c = 7, l = 4)
            }
    },
    _j = t => {
        let e;
        for (GM(t, t.dyn_ltree, t.l_desc.max_code), GM(t, t.dyn_dtree, t.d_desc.max_code), cw(t, t.bl_desc), e = yw - 1; e >= 3 && t.bl_tree[OI[e] * 2 + 1] === 0; e--);
        return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e
    },
    bj = (t, e, n, r) => {
        let i;
        for (Ht(t, e - 257, 5), Ht(t, n - 1, 5), Ht(t, r - 4, 4), i = 0; i < r; i++) Ht(t, t.bl_tree[OI[i] * 2 + 1], 3);
        ZM(t, t.dyn_ltree, e - 1), ZM(t, t.dyn_dtree, n - 1)
    },
    Dj = t => {
        let e = 4093624447,
            n;
        for (n = 0; n <= 31; n++, e >>>= 1)
            if (e & 1 && t.dyn_ltree[n * 2] !== 0) return 0;
        if (t.dyn_ltree[9 * 2] !== 0 || t.dyn_ltree[10 * 2] !== 0 || t.dyn_ltree[13 * 2] !== 0) return 1;
        for (n = 32; n < zc; n++)
            if (t.dyn_ltree[n * 2] !== 0) return 1;
        return 0
    },
    QM = !1,
    Ej = t => {
        QM || (wj(), QM = !0), t.l_desc = new qv(t.dyn_ltree, FI), t.d_desc = new qv(t.dyn_dtree, kI), t.bl_desc = new qv(t.bl_tree, PI), t.bi_buf = 0, t.bi_valid = 0, jI(t)
    },
    zI = (t, e, n, r) => {
        Ht(t, (uj << 1) + (r ? 1 : 0), 3), BI(t), Lc(t, n), Lc(t, ~n), n && t.pending_buf.set(t.window.subarray(e, e + n), t.pending), t.pending += n
    },
    Cj = t => {
        Ht(t, TI << 1, 3), hr(t, vw, Vr), yj(t)
    },
    Sj = (t, e, n, r) => {
        let i, s, o = 0;
        t.level > 0 ? (t.strm.data_type === 2 && (t.strm.data_type = Dj(t)), cw(t, t.l_desc), cw(t, t.d_desc), o = _j(t), i = t.opt_len + 3 + 7 >>> 3, s = t.static_len + 3 + 7 >>> 3, s <= i && (i = s)) : i = s = n + 5, n + 4 <= i && e !== -1 ? zI(t, e, n, r) : t.strategy === 4 || s === i ? (Ht(t, (TI << 1) + (r ? 1 : 0), 3), HM(t, Vr, Nc)) : (Ht(t, (dj << 1) + (r ? 1 : 0), 3), bj(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, o + 1), HM(t, t.dyn_ltree, t.dyn_dtree)), jI(t), r && BI(t)
    },
    Mj = (t, e, n) => (t.pending_buf[t.sym_buf + t.sym_next++] = e, t.pending_buf[t.sym_buf + t.sym_next++] = e >> 8, t.pending_buf[t.sym_buf + t.sym_next++] = n, e === 0 ? t.dyn_ltree[n * 2]++ : (t.matches++, e--, t.dyn_ltree[(Pc[n] + zc + 1) * 2]++, t.dyn_dtree[LI(e) * 2]++), t.sym_next === t.sym_end),
    Ij = Ej,
    Tj = zI,
    xj = Sj,
    Aj = Mj,
    Nj = Cj,
    Rj = {
        _tr_init: Ij,
        _tr_stored_block: Tj,
        _tr_flush_block: xj,
        _tr_tally: Aj,
        _tr_align: Nj
    },
    Oj = (t, e, n, r) => {
        let i = t & 65535 | 0,
            s = t >>> 16 & 65535 | 0,
            o = 0;
        for (; n !== 0;) {
            o = n > 2e3 ? 2e3 : n, n -= o;
            do i = i + e[r++] | 0, s = s + i | 0; while (--o);
            i %= 65521, s %= 65521
        }
        return i | s << 16 | 0
    },
    Vc = Oj,
    Fj = () => {
        let t, e = [];
        for (var n = 0; n < 256; n++) {
            t = n;
            for (var r = 0; r < 8; r++) t = t & 1 ? 3988292384 ^ t >>> 1 : t >>> 1;
            e[n] = t
        }
        return e
    },
    kj = new Uint32Array(Fj()),
    Pj = (t, e, n, r) => {
        let i = kj,
            s = r + n;
        t ^= -1;
        for (let o = r; o < s; o++) t = t >>> 8 ^ i[(t ^ e[o]) & 255];
        return t ^ -1
    },
    ht = Pj,
    ys = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
    },
    qo = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
    },
    {
        _tr_init: Lj,
        _tr_stored_block: lw,
        _tr_flush_block: Vj,
        _tr_tally: Di,
        _tr_align: Uj
    } = Rj,
    {
        Z_NO_FLUSH: Ei,
        Z_PARTIAL_FLUSH: jj,
        Z_FULL_FLUSH: Bj,
        Z_FINISH: En,
        Z_BLOCK: qM,
        Z_OK: Dt,
        Z_STREAM_END: KM,
        Z_STREAM_ERROR: fr,
        Z_DATA_ERROR: zj,
        Z_BUF_ERROR: Yv,
        Z_DEFAULT_COMPRESSION: $j,
        Z_FILTERED: Wj,
        Z_HUFFMAN_ONLY: Ph,
        Z_RLE: Hj,
        Z_FIXED: Gj,
        Z_DEFAULT_STRATEGY: Zj,
        Z_UNKNOWN: Qj,
        Z_DEFLATED: Hh
    } = qo,
    qj = 9,
    Kj = 15,
    Yj = 8,
    Jj = 29,
    Xj = 256,
    uw = Xj + 1 + Jj,
    eB = 30,
    tB = 19,
    nB = 2 * uw + 1,
    rB = 15,
    ge = 3,
    bi = 258,
    pr = bi + ge + 1,
    iB = 32,
    Go = 42,
    _w = 57,
    dw = 69,
    hw = 73,
    fw = 91,
    pw = 103,
    gs = 113,
    xc = 666,
    jt = 1,
    Ko = 2,
    vs = 3,
    Yo = 4,
    sB = 3,
    ms = (t, e) => (t.msg = ys[e], e),
    YM = t => t * 2 - (t > 4 ? 9 : 0),
    _i = t => {
        let e = t.length;
        for (; --e >= 0;) t[e] = 0
    },
    oB = t => {
        let e, n, r, i = t.w_size;
        e = t.hash_size, r = e;
        do n = t.head[--r], t.head[r] = n >= i ? n - i : 0; while (--e);
        e = i, r = e;
        do n = t.prev[--r], t.prev[r] = n >= i ? n - i : 0; while (--e)
    },
    aB = (t, e, n) => (e << t.hash_shift ^ n) & t.hash_mask,
    Ci = aB,
    on = t => {
        let e = t.state,
            n = e.pending;
        n > t.avail_out && (n = t.avail_out), n !== 0 && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + n), t.next_out), t.next_out += n, e.pending_out += n, t.total_out += n, t.avail_out -= n, e.pending -= n, e.pending === 0 && (e.pending_out = 0))
    },
    an = (t, e) => {
        Vj(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, on(t.strm)
    },
    Ce = (t, e) => {
        t.pending_buf[t.pending++] = e
    },
    Tc = (t, e) => {
        t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = e & 255
    },
    gw = (t, e, n, r) => {
        let i = t.avail_in;
        return i > r && (i = r), i === 0 ? 0 : (t.avail_in -= i, e.set(t.input.subarray(t.next_in, t.next_in + i), n), t.state.wrap === 1 ? t.adler = Vc(t.adler, e, i, n) : t.state.wrap === 2 && (t.adler = ht(t.adler, e, i, n)), t.next_in += i, t.total_in += i, i)
    },
    $I = (t, e) => {
        let n = t.max_chain_length,
            r = t.strstart,
            i, s, o = t.prev_length,
            a = t.nice_match,
            c = t.strstart > t.w_size - pr ? t.strstart - (t.w_size - pr) : 0,
            l = t.window,
            u = t.w_mask,
            d = t.prev,
            h = t.strstart + bi,
            f = l[r + o - 1],
            p = l[r + o];
        t.prev_length >= t.good_match && (n >>= 2), a > t.lookahead && (a = t.lookahead);
        do
            if (i = e, !(l[i + o] !== p || l[i + o - 1] !== f || l[i] !== l[r] || l[++i] !== l[r + 1])) {
                r += 2, i++;
                do; while (l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && r < h);
                if (s = bi - (h - r), r = h - bi, s > o) {
                    if (t.match_start = e, o = s, s >= a) break;
                    f = l[r + o - 1], p = l[r + o]
                }
            }
        while ((e = d[e & u]) > c && --n !== 0);
        return o <= t.lookahead ? o : t.lookahead
    },
    Zo = t => {
        let e = t.w_size,
            n, r, i;
        do {
            if (r = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - pr) && (t.window.set(t.window.subarray(e, e + e - r), 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, t.insert > t.strstart && (t.insert = t.strstart), oB(t), r += e), t.strm.avail_in === 0) break;
            if (n = gw(t.strm, t.window, t.strstart + t.lookahead, r), t.lookahead += n, t.lookahead + t.insert >= ge)
                for (i = t.strstart - t.insert, t.ins_h = t.window[i], t.ins_h = Ci(t, t.ins_h, t.window[i + 1]); t.insert && (t.ins_h = Ci(t, t.ins_h, t.window[i + ge - 1]), t.prev[i & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = i, i++, t.insert--, !(t.lookahead + t.insert < ge)););
        } while (t.lookahead < pr && t.strm.avail_in !== 0)
    },
    WI = (t, e) => {
        let n = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5,
            r, i, s, o = 0,
            a = t.strm.avail_in;
        do {
            if (r = 65535, s = t.bi_valid + 42 >> 3, t.strm.avail_out < s || (s = t.strm.avail_out - s, i = t.strstart - t.block_start, r > i + t.strm.avail_in && (r = i + t.strm.avail_in), r > s && (r = s), r < n && (r === 0 && e !== En || e === Ei || r !== i + t.strm.avail_in))) break;
            o = e === En && r === i + t.strm.avail_in ? 1 : 0, lw(t, 0, 0, o), t.pending_buf[t.pending - 4] = r, t.pending_buf[t.pending - 3] = r >> 8, t.pending_buf[t.pending - 2] = ~r, t.pending_buf[t.pending - 1] = ~r >> 8, on(t.strm), i && (i > r && (i = r), t.strm.output.set(t.window.subarray(t.block_start, t.block_start + i), t.strm.next_out), t.strm.next_out += i, t.strm.avail_out -= i, t.strm.total_out += i, t.block_start += i, r -= i), r && (gw(t.strm, t.strm.output, t.strm.next_out, r), t.strm.next_out += r, t.strm.avail_out -= r, t.strm.total_out += r)
        } while (o === 0);
        return a -= t.strm.avail_in, a && (a >= t.w_size ? (t.matches = 2, t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0), t.strstart = t.w_size, t.insert = t.strstart) : (t.window_size - t.strstart <= a && (t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, t.insert > t.strstart && (t.insert = t.strstart)), t.window.set(t.strm.input.subarray(t.strm.next_in - a, t.strm.next_in), t.strstart), t.strstart += a, t.insert += a > t.w_size - t.insert ? t.w_size - t.insert : a), t.block_start = t.strstart), t.high_water < t.strstart && (t.high_water = t.strstart), o ? Yo : e !== Ei && e !== En && t.strm.avail_in === 0 && t.strstart === t.block_start ? Ko : (s = t.window_size - t.strstart, t.strm.avail_in > s && t.block_start >= t.w_size && (t.block_start -= t.w_size, t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, s += t.w_size, t.insert > t.strstart && (t.insert = t.strstart)), s > t.strm.avail_in && (s = t.strm.avail_in), s && (gw(t.strm, t.window, t.strstart, s), t.strstart += s, t.insert += s > t.w_size - t.insert ? t.w_size - t.insert : s), t.high_water < t.strstart && (t.high_water = t.strstart), s = t.bi_valid + 42 >> 3, s = t.pending_buf_size - s > 65535 ? 65535 : t.pending_buf_size - s, n = s > t.w_size ? t.w_size : s, i = t.strstart - t.block_start, (i >= n || (i || e === En) && e !== Ei && t.strm.avail_in === 0 && i <= s) && (r = i > s ? s : i, o = e === En && t.strm.avail_in === 0 && r === i ? 1 : 0, lw(t, t.block_start, r, o), t.block_start += r, on(t.strm)), o ? vs : jt)
    },
    Jv = (t, e) => {
        let n, r;
        for (;;) {
            if (t.lookahead < pr) {
                if (Zo(t), t.lookahead < pr && e === Ei) return jt;
                if (t.lookahead === 0) break
            }
            if (n = 0, t.lookahead >= ge && (t.ins_h = Ci(t, t.ins_h, t.window[t.strstart + ge - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), n !== 0 && t.strstart - n <= t.w_size - pr && (t.match_length = $I(t, n)), t.match_length >= ge)
                if (r = Di(t, t.strstart - t.match_start, t.match_length - ge), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= ge) {
                    t.match_length--;
                    do t.strstart++, t.ins_h = Ci(t, t.ins_h, t.window[t.strstart + ge - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart; while (--t.match_length !== 0);
                    t.strstart++
                } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = Ci(t, t.ins_h, t.window[t.strstart + 1]);
            else r = Di(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
            if (r && (an(t, !1), t.strm.avail_out === 0)) return jt
        }
        return t.insert = t.strstart < ge - 1 ? t.strstart : ge - 1, e === En ? (an(t, !0), t.strm.avail_out === 0 ? vs : Yo) : t.sym_next && (an(t, !1), t.strm.avail_out === 0) ? jt : Ko
    },
    $o = (t, e) => {
        let n, r, i;
        for (;;) {
            if (t.lookahead < pr) {
                if (Zo(t), t.lookahead < pr && e === Ei) return jt;
                if (t.lookahead === 0) break
            }
            if (n = 0, t.lookahead >= ge && (t.ins_h = Ci(t, t.ins_h, t.window[t.strstart + ge - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = ge - 1, n !== 0 && t.prev_length < t.max_lazy_match && t.strstart - n <= t.w_size - pr && (t.match_length = $I(t, n), t.match_length <= 5 && (t.strategy === Wj || t.match_length === ge && t.strstart - t.match_start > 4096) && (t.match_length = ge - 1)), t.prev_length >= ge && t.match_length <= t.prev_length) {
                i = t.strstart + t.lookahead - ge, r = Di(t, t.strstart - 1 - t.prev_match, t.prev_length - ge), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
                do ++t.strstart <= i && (t.ins_h = Ci(t, t.ins_h, t.window[t.strstart + ge - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart); while (--t.prev_length !== 0);
                if (t.match_available = 0, t.match_length = ge - 1, t.strstart++, r && (an(t, !1), t.strm.avail_out === 0)) return jt
            } else if (t.match_available) {
                if (r = Di(t, 0, t.window[t.strstart - 1]), r && an(t, !1), t.strstart++, t.lookahead--, t.strm.avail_out === 0) return jt
            } else t.match_available = 1, t.strstart++, t.lookahead--
        }
        return t.match_available && (r = Di(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < ge - 1 ? t.strstart : ge - 1, e === En ? (an(t, !0), t.strm.avail_out === 0 ? vs : Yo) : t.sym_next && (an(t, !1), t.strm.avail_out === 0) ? jt : Ko
    },
    cB = (t, e) => {
        let n, r, i, s, o = t.window;
        for (;;) {
            if (t.lookahead <= bi) {
                if (Zo(t), t.lookahead <= bi && e === Ei) return jt;
                if (t.lookahead === 0) break
            }
            if (t.match_length = 0, t.lookahead >= ge && t.strstart > 0 && (i = t.strstart - 1, r = o[i], r === o[++i] && r === o[++i] && r === o[++i])) {
                s = t.strstart + bi;
                do; while (r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && i < s);
                t.match_length = bi - (s - i), t.match_length > t.lookahead && (t.match_length = t.lookahead)
            }
            if (t.match_length >= ge ? (n = Di(t, 1, t.match_length - ge), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (n = Di(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), n && (an(t, !1), t.strm.avail_out === 0)) return jt
        }
        return t.insert = 0, e === En ? (an(t, !0), t.strm.avail_out === 0 ? vs : Yo) : t.sym_next && (an(t, !1), t.strm.avail_out === 0) ? jt : Ko
    },
    lB = (t, e) => {
        let n;
        for (;;) {
            if (t.lookahead === 0 && (Zo(t), t.lookahead === 0)) {
                if (e === Ei) return jt;
                break
            }
            if (t.match_length = 0, n = Di(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, n && (an(t, !1), t.strm.avail_out === 0)) return jt
        }
        return t.insert = 0, e === En ? (an(t, !0), t.strm.avail_out === 0 ? vs : Yo) : t.sym_next && (an(t, !1), t.strm.avail_out === 0) ? jt : Ko
    };

function dr(t, e, n, r, i) {
    this.good_length = t, this.max_lazy = e, this.nice_length = n, this.max_chain = r, this.func = i
}
var Ac = [new dr(0, 0, 0, 0, WI), new dr(4, 4, 8, 4, Jv), new dr(4, 5, 16, 8, Jv), new dr(4, 6, 32, 32, Jv), new dr(4, 4, 16, 16, $o), new dr(8, 16, 32, 32, $o), new dr(8, 16, 128, 128, $o), new dr(8, 32, 128, 256, $o), new dr(32, 128, 258, 1024, $o), new dr(32, 258, 258, 4096, $o)],
    uB = t => {
        t.window_size = 2 * t.w_size, _i(t.head), t.max_lazy_match = Ac[t.level].max_lazy, t.good_match = Ac[t.level].good_length, t.nice_match = Ac[t.level].nice_length, t.max_chain_length = Ac[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = ge - 1, t.match_available = 0, t.ins_h = 0
    };

function dB() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Hh, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(nB * 2), this.dyn_dtree = new Uint16Array((2 * eB + 1) * 2), this.bl_tree = new Uint16Array((2 * tB + 1) * 2), _i(this.dyn_ltree), _i(this.dyn_dtree), _i(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(rB + 1), this.heap = new Uint16Array(2 * uw + 1), _i(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * uw + 1), _i(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
}
var $c = t => {
        if (!t) return 1;
        let e = t.state;
        return !e || e.strm !== t || e.status !== Go && e.status !== _w && e.status !== dw && e.status !== hw && e.status !== fw && e.status !== pw && e.status !== gs && e.status !== xc ? 1 : 0
    },
    HI = t => {
        if ($c(t)) return ms(t, fr);
        t.total_in = t.total_out = 0, t.data_type = Qj;
        let e = t.state;
        return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap === 2 ? _w : e.wrap ? Go : gs, t.adler = e.wrap === 2 ? 0 : 1, e.last_flush = -2, Lj(e), Dt
    },
    GI = t => {
        let e = HI(t);
        return e === Dt && uB(t.state), e
    },
    hB = (t, e) => $c(t) || t.state.wrap !== 2 ? fr : (t.state.gzhead = e, Dt),
    ZI = (t, e, n, r, i, s) => {
        if (!t) return fr;
        let o = 1;
        if (e === $j && (e = 6), r < 0 ? (o = 0, r = -r) : r > 15 && (o = 2, r -= 16), i < 1 || i > qj || n !== Hh || r < 8 || r > 15 || e < 0 || e > 9 || s < 0 || s > Gj || r === 8 && o !== 1) return ms(t, fr);
        r === 8 && (r = 9);
        let a = new dB;
        return t.state = a, a.strm = t, a.status = Go, a.wrap = o, a.gzhead = null, a.w_bits = r, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = i + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + ge - 1) / ge), a.window = new Uint8Array(a.w_size * 2), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << i + 6, a.pending_buf_size = a.lit_bufsize * 4, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = (a.lit_bufsize - 1) * 3, a.level = e, a.strategy = s, a.method = n, GI(t)
    },
    fB = (t, e) => ZI(t, e, Hh, Kj, Yj, Zj),
    pB = (t, e) => {
        if ($c(t) || e > qM || e < 0) return t ? ms(t, fr) : fr;
        let n = t.state;
        if (!t.output || t.avail_in !== 0 && !t.input || n.status === xc && e !== En) return ms(t, t.avail_out === 0 ? Yv : fr);
        let r = n.last_flush;
        if (n.last_flush = e, n.pending !== 0) {
            if (on(t), t.avail_out === 0) return n.last_flush = -1, Dt
        } else if (t.avail_in === 0 && YM(e) <= YM(r) && e !== En) return ms(t, Yv);
        if (n.status === xc && t.avail_in !== 0) return ms(t, Yv);
        if (n.status === Go && n.wrap === 0 && (n.status = gs), n.status === Go) {
            let i = Hh + (n.w_bits - 8 << 4) << 8,
                s = -1;
            if (n.strategy >= Ph || n.level < 2 ? s = 0 : n.level < 6 ? s = 1 : n.level === 6 ? s = 2 : s = 3, i |= s << 6, n.strstart !== 0 && (i |= iB), i += 31 - i % 31, Tc(n, i), n.strstart !== 0 && (Tc(n, t.adler >>> 16), Tc(n, t.adler & 65535)), t.adler = 1, n.status = gs, on(t), n.pending !== 0) return n.last_flush = -1, Dt
        }
        if (n.status === _w) {
            if (t.adler = 0, Ce(n, 31), Ce(n, 139), Ce(n, 8), n.gzhead) Ce(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), Ce(n, n.gzhead.time & 255), Ce(n, n.gzhead.time >> 8 & 255), Ce(n, n.gzhead.time >> 16 & 255), Ce(n, n.gzhead.time >> 24 & 255), Ce(n, n.level === 9 ? 2 : n.strategy >= Ph || n.level < 2 ? 4 : 0), Ce(n, n.gzhead.os & 255), n.gzhead.extra && n.gzhead.extra.length && (Ce(n, n.gzhead.extra.length & 255), Ce(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (t.adler = ht(t.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = dw;
            else if (Ce(n, 0), Ce(n, 0), Ce(n, 0), Ce(n, 0), Ce(n, 0), Ce(n, n.level === 9 ? 2 : n.strategy >= Ph || n.level < 2 ? 4 : 0), Ce(n, sB), n.status = gs, on(t), n.pending !== 0) return n.last_flush = -1, Dt
        }
        if (n.status === dw) {
            if (n.gzhead.extra) {
                let i = n.pending,
                    s = (n.gzhead.extra.length & 65535) - n.gzindex;
                for (; n.pending + s > n.pending_buf_size;) {
                    let a = n.pending_buf_size - n.pending;
                    if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + a), n.pending), n.pending = n.pending_buf_size, n.gzhead.hcrc && n.pending > i && (t.adler = ht(t.adler, n.pending_buf, n.pending - i, i)), n.gzindex += a, on(t), n.pending !== 0) return n.last_flush = -1, Dt;
                    i = 0, s -= a
                }
                let o = new Uint8Array(n.gzhead.extra);
                n.pending_buf.set(o.subarray(n.gzindex, n.gzindex + s), n.pending), n.pending += s, n.gzhead.hcrc && n.pending > i && (t.adler = ht(t.adler, n.pending_buf, n.pending - i, i)), n.gzindex = 0
            }
            n.status = hw
        }
        if (n.status === hw) {
            if (n.gzhead.name) {
                let i = n.pending,
                    s;
                do {
                    if (n.pending === n.pending_buf_size) {
                        if (n.gzhead.hcrc && n.pending > i && (t.adler = ht(t.adler, n.pending_buf, n.pending - i, i)), on(t), n.pending !== 0) return n.last_flush = -1, Dt;
                        i = 0
                    }
                    n.gzindex < n.gzhead.name.length ? s = n.gzhead.name.charCodeAt(n.gzindex++) & 255 : s = 0, Ce(n, s)
                } while (s !== 0);
                n.gzhead.hcrc && n.pending > i && (t.adler = ht(t.adler, n.pending_buf, n.pending - i, i)), n.gzindex = 0
            }
            n.status = fw
        }
        if (n.status === fw) {
            if (n.gzhead.comment) {
                let i = n.pending,
                    s;
                do {
                    if (n.pending === n.pending_buf_size) {
                        if (n.gzhead.hcrc && n.pending > i && (t.adler = ht(t.adler, n.pending_buf, n.pending - i, i)), on(t), n.pending !== 0) return n.last_flush = -1, Dt;
                        i = 0
                    }
                    n.gzindex < n.gzhead.comment.length ? s = n.gzhead.comment.charCodeAt(n.gzindex++) & 255 : s = 0, Ce(n, s)
                } while (s !== 0);
                n.gzhead.hcrc && n.pending > i && (t.adler = ht(t.adler, n.pending_buf, n.pending - i, i))
            }
            n.status = pw
        }
        if (n.status === pw) {
            if (n.gzhead.hcrc) {
                if (n.pending + 2 > n.pending_buf_size && (on(t), n.pending !== 0)) return n.last_flush = -1, Dt;
                Ce(n, t.adler & 255), Ce(n, t.adler >> 8 & 255), t.adler = 0
            }
            if (n.status = gs, on(t), n.pending !== 0) return n.last_flush = -1, Dt
        }
        if (t.avail_in !== 0 || n.lookahead !== 0 || e !== Ei && n.status !== xc) {
            let i = n.level === 0 ? WI(n, e) : n.strategy === Ph ? lB(n, e) : n.strategy === Hj ? cB(n, e) : Ac[n.level].func(n, e);
            if ((i === vs || i === Yo) && (n.status = xc), i === jt || i === vs) return t.avail_out === 0 && (n.last_flush = -1), Dt;
            if (i === Ko && (e === jj ? Uj(n) : e !== qM && (lw(n, 0, 0, !1), e === Bj && (_i(n.head), n.lookahead === 0 && (n.strstart = 0, n.block_start = 0, n.insert = 0))), on(t), t.avail_out === 0)) return n.last_flush = -1, Dt
        }
        return e !== En ? Dt : n.wrap <= 0 ? KM : (n.wrap === 2 ? (Ce(n, t.adler & 255), Ce(n, t.adler >> 8 & 255), Ce(n, t.adler >> 16 & 255), Ce(n, t.adler >> 24 & 255), Ce(n, t.total_in & 255), Ce(n, t.total_in >> 8 & 255), Ce(n, t.total_in >> 16 & 255), Ce(n, t.total_in >> 24 & 255)) : (Tc(n, t.adler >>> 16), Tc(n, t.adler & 65535)), on(t), n.wrap > 0 && (n.wrap = -n.wrap), n.pending !== 0 ? Dt : KM)
    },
    gB = t => {
        if ($c(t)) return fr;
        let e = t.state.status;
        return t.state = null, e === gs ? ms(t, zj) : Dt
    },
    mB = (t, e) => {
        let n = e.length;
        if ($c(t)) return fr;
        let r = t.state,
            i = r.wrap;
        if (i === 2 || i === 1 && r.status !== Go || r.lookahead) return fr;
        if (i === 1 && (t.adler = Vc(t.adler, e, n, 0)), r.wrap = 0, n >= r.w_size) {
            i === 0 && (_i(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0);
            let c = new Uint8Array(r.w_size);
            c.set(e.subarray(n - r.w_size, n), 0), e = c, n = r.w_size
        }
        let s = t.avail_in,
            o = t.next_in,
            a = t.input;
        for (t.avail_in = n, t.next_in = 0, t.input = e, Zo(r); r.lookahead >= ge;) {
            let c = r.strstart,
                l = r.lookahead - (ge - 1);
            do r.ins_h = Ci(r, r.ins_h, r.window[c + ge - 1]), r.prev[c & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = c, c++; while (--l);
            r.strstart = c, r.lookahead = ge - 1, Zo(r)
        }
        return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = ge - 1, r.match_available = 0, t.next_in = o, t.input = a, t.avail_in = s, r.wrap = i, Dt
    },
    yB = fB,
    vB = ZI,
    wB = GI,
    _B = HI,
    bB = hB,
    DB = pB,
    EB = gB,
    CB = mB,
    SB = "pako deflate (from Nodeca project)",
    Rc = {
        deflateInit: yB,
        deflateInit2: vB,
        deflateReset: wB,
        deflateResetKeep: _B,
        deflateSetHeader: bB,
        deflate: DB,
        deflateEnd: EB,
        deflateSetDictionary: CB,
        deflateInfo: SB
    },
    MB = (t, e) => Object.prototype.hasOwnProperty.call(t, e),
    IB = function(t) {
        let e = Array.prototype.slice.call(arguments, 1);
        for (; e.length;) {
            let n = e.shift();
            if (n) {
                if (typeof n != "object") throw new TypeError(n + "must be non-object");
                for (let r in n) MB(n, r) && (t[r] = n[r])
            }
        }
        return t
    },
    TB = t => {
        let e = 0;
        for (let r = 0, i = t.length; r < i; r++) e += t[r].length;
        let n = new Uint8Array(e);
        for (let r = 0, i = 0, s = t.length; r < s; r++) {
            let o = t[r];
            n.set(o, i), i += o.length
        }
        return n
    },
    Gh = {
        assign: IB,
        flattenChunks: TB
    },
    QI = !0;
try {
    String.fromCharCode.apply(null, new Uint8Array(1))
} catch {
    QI = !1
}
var Uc = new Uint8Array(256);
for (let t = 0; t < 256; t++) Uc[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
Uc[254] = Uc[254] = 1;
var xB = t => {
        if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(t);
        let e, n, r, i, s, o = t.length,
            a = 0;
        for (i = 0; i < o; i++) n = t.charCodeAt(i), (n & 64512) === 55296 && i + 1 < o && (r = t.charCodeAt(i + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), i++)), a += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
        for (e = new Uint8Array(a), s = 0, i = 0; s < a; i++) n = t.charCodeAt(i), (n & 64512) === 55296 && i + 1 < o && (r = t.charCodeAt(i + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), i++)), n < 128 ? e[s++] = n : n < 2048 ? (e[s++] = 192 | n >>> 6, e[s++] = 128 | n & 63) : n < 65536 ? (e[s++] = 224 | n >>> 12, e[s++] = 128 | n >>> 6 & 63, e[s++] = 128 | n & 63) : (e[s++] = 240 | n >>> 18, e[s++] = 128 | n >>> 12 & 63, e[s++] = 128 | n >>> 6 & 63, e[s++] = 128 | n & 63);
        return e
    },
    AB = (t, e) => {
        if (e < 65534 && t.subarray && QI) return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));
        let n = "";
        for (let r = 0; r < e; r++) n += String.fromCharCode(t[r]);
        return n
    },
    NB = (t, e) => {
        let n = e || t.length;
        if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(t.subarray(0, e));
        let r, i, s = new Array(n * 2);
        for (i = 0, r = 0; r < n;) {
            let o = t[r++];
            if (o < 128) {
                s[i++] = o;
                continue
            }
            let a = Uc[o];
            if (a > 4) {
                s[i++] = 65533, r += a - 1;
                continue
            }
            for (o &= a === 2 ? 31 : a === 3 ? 15 : 7; a > 1 && r < n;) o = o << 6 | t[r++] & 63, a--;
            if (a > 1) {
                s[i++] = 65533;
                continue
            }
            o < 65536 ? s[i++] = o : (o -= 65536, s[i++] = 55296 | o >> 10 & 1023, s[i++] = 56320 | o & 1023)
        }
        return AB(s, i)
    },
    RB = (t, e) => {
        e = e || t.length, e > t.length && (e = t.length);
        let n = e - 1;
        for (; n >= 0 && (t[n] & 192) === 128;) n--;
        return n < 0 || n === 0 ? e : n + Uc[t[n]] > e ? n : e
    },
    jc = {
        string2buf: xB,
        buf2string: NB,
        utf8border: RB
    };

function OB() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
}
var qI = OB,
    KI = Object.prototype.toString,
    {
        Z_NO_FLUSH: FB,
        Z_SYNC_FLUSH: kB,
        Z_FULL_FLUSH: PB,
        Z_FINISH: LB,
        Z_OK: $h,
        Z_STREAM_END: VB,
        Z_DEFAULT_COMPRESSION: UB,
        Z_DEFAULT_STRATEGY: jB,
        Z_DEFLATED: BB
    } = qo;

function Wc(t) {
    this.options = Gh.assign({
        level: UB,
        method: BB,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: jB
    }, t || {});
    let e = this.options;
    e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new qI, this.strm.avail_out = 0;
    let n = Rc.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
    if (n !== $h) throw new Error(ys[n]);
    if (e.header && Rc.deflateSetHeader(this.strm, e.header), e.dictionary) {
        let r;
        if (typeof e.dictionary == "string" ? r = jc.string2buf(e.dictionary) : KI.call(e.dictionary) === "[object ArrayBuffer]" ? r = new Uint8Array(e.dictionary) : r = e.dictionary, n = Rc.deflateSetDictionary(this.strm, r), n !== $h) throw new Error(ys[n]);
        this._dict_set = !0
    }
}
Wc.prototype.push = function(t, e) {
    let n = this.strm,
        r = this.options.chunkSize,
        i, s;
    if (this.ended) return !1;
    for (e === ~~e ? s = e : s = e === !0 ? LB : FB, typeof t == "string" ? n.input = jc.string2buf(t) : KI.call(t) === "[object ArrayBuffer]" ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;;) {
        if (n.avail_out === 0 && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), (s === kB || s === PB) && n.avail_out <= 6) {
            this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
            continue
        }
        if (i = Rc.deflate(n, s), i === VB) return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), i = Rc.deflateEnd(this.strm), this.onEnd(i), this.ended = !0, i === $h;
        if (n.avail_out === 0) {
            this.onData(n.output);
            continue
        }
        if (s > 0 && n.next_out > 0) {
            this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
            continue
        }
        if (n.avail_in === 0) break
    }
    return !0
};
Wc.prototype.onData = function(t) {
    this.chunks.push(t)
};
Wc.prototype.onEnd = function(t) {
    t === $h && (this.result = Gh.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
};

function bw(t, e) {
    let n = new Wc(e);
    if (n.push(t, !0), n.err) throw n.msg || ys[n.err];
    return n.result
}

function zB(t, e) {
    return e = e || {}, e.raw = !0, bw(t, e)
}

function $B(t, e) {
    return e = e || {}, e.gzip = !0, bw(t, e)
}
var WB = Wc,
    HB = bw,
    GB = zB,
    ZB = $B,
    QB = qo,
    qB = {
        Deflate: WB,
        deflate: HB,
        deflateRaw: GB,
        gzip: ZB,
        constants: QB
    },
    Lh = 16209,
    KB = 16191,
    YB = function(e, n) {
        let r, i, s, o, a, c, l, u, d, h, f, p, g, m, y, E, T, w, N, L, D, j, Y, H, G = e.state;
        r = e.next_in, Y = e.input, i = r + (e.avail_in - 5), s = e.next_out, H = e.output, o = s - (n - e.avail_out), a = s + (e.avail_out - 257), c = G.dmax, l = G.wsize, u = G.whave, d = G.wnext, h = G.window, f = G.hold, p = G.bits, g = G.lencode, m = G.distcode, y = (1 << G.lenbits) - 1, E = (1 << G.distbits) - 1;
        e: do {
            p < 15 && (f += Y[r++] << p, p += 8, f += Y[r++] << p, p += 8), T = g[f & y];
            t: for (;;) {
                if (w = T >>> 24, f >>>= w, p -= w, w = T >>> 16 & 255, w === 0) H[s++] = T & 65535;
                else if (w & 16) {
                    N = T & 65535, w &= 15, w && (p < w && (f += Y[r++] << p, p += 8), N += f & (1 << w) - 1, f >>>= w, p -= w), p < 15 && (f += Y[r++] << p, p += 8, f += Y[r++] << p, p += 8), T = m[f & E];
                    n: for (;;) {
                        if (w = T >>> 24, f >>>= w, p -= w, w = T >>> 16 & 255, w & 16) {
                            if (L = T & 65535, w &= 15, p < w && (f += Y[r++] << p, p += 8, p < w && (f += Y[r++] << p, p += 8)), L += f & (1 << w) - 1, L > c) {
                                e.msg = "invalid distance too far back", G.mode = Lh;
                                break e
                            }
                            if (f >>>= w, p -= w, w = s - o, L > w) {
                                if (w = L - w, w > u && G.sane) {
                                    e.msg = "invalid distance too far back", G.mode = Lh;
                                    break e
                                }
                                if (D = 0, j = h, d === 0) {
                                    if (D += l - w, w < N) {
                                        N -= w;
                                        do H[s++] = h[D++]; while (--w);
                                        D = s - L, j = H
                                    }
                                } else if (d < w) {
                                    if (D += l + d - w, w -= d, w < N) {
                                        N -= w;
                                        do H[s++] = h[D++]; while (--w);
                                        if (D = 0, d < N) {
                                            w = d, N -= w;
                                            do H[s++] = h[D++]; while (--w);
                                            D = s - L, j = H
                                        }
                                    }
                                } else if (D += d - w, w < N) {
                                    N -= w;
                                    do H[s++] = h[D++]; while (--w);
                                    D = s - L, j = H
                                }
                                for (; N > 2;) H[s++] = j[D++], H[s++] = j[D++], H[s++] = j[D++], N -= 3;
                                N && (H[s++] = j[D++], N > 1 && (H[s++] = j[D++]))
                            } else {
                                D = s - L;
                                do H[s++] = H[D++], H[s++] = H[D++], H[s++] = H[D++], N -= 3; while (N > 2);
                                N && (H[s++] = H[D++], N > 1 && (H[s++] = H[D++]))
                            }
                        } else if (w & 64) {
                            e.msg = "invalid distance code", G.mode = Lh;
                            break e
                        } else {
                            T = m[(T & 65535) + (f & (1 << w) - 1)];
                            continue n
                        }
                        break
                    }
                } else if (w & 64)
                    if (w & 32) {
                        G.mode = KB;
                        break e
                    } else {
                        e.msg = "invalid literal/length code", G.mode = Lh;
                        break e
                    }
                else {
                    T = g[(T & 65535) + (f & (1 << w) - 1)];
                    continue t
                }
                break
            }
        } while (r < i && s < a);
        N = p >> 3, r -= N, p -= N << 3, f &= (1 << p) - 1, e.next_in = r, e.next_out = s, e.avail_in = r < i ? 5 + (i - r) : 5 - (r - i), e.avail_out = s < a ? 257 + (a - s) : 257 - (s - a), G.hold = f, G.bits = p
    },
    Wo = 15,
    JM = 852,
    XM = 592,
    eI = 0,
    Xv = 1,
    tI = 2,
    JB = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
    XB = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
    ez = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
    tz = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),
    nz = (t, e, n, r, i, s, o, a) => {
        let c = a.bits,
            l = 0,
            u = 0,
            d = 0,
            h = 0,
            f = 0,
            p = 0,
            g = 0,
            m = 0,
            y = 0,
            E = 0,
            T, w, N, L, D, j = null,
            Y, H = new Uint16Array(Wo + 1),
            G = new Uint16Array(Wo + 1),
            Ue = null,
            qt, v, A;
        for (l = 0; l <= Wo; l++) H[l] = 0;
        for (u = 0; u < r; u++) H[e[n + u]]++;
        for (f = c, h = Wo; h >= 1 && H[h] === 0; h--);
        if (f > h && (f = h), h === 0) return i[s++] = 1 << 24 | 64 << 16 | 0, i[s++] = 1 << 24 | 64 << 16 | 0, a.bits = 1, 0;
        for (d = 1; d < h && H[d] === 0; d++);
        for (f < d && (f = d), m = 1, l = 1; l <= Wo; l++)
            if (m <<= 1, m -= H[l], m < 0) return -1;
        if (m > 0 && (t === eI || h !== 1)) return -1;
        for (G[1] = 0, l = 1; l < Wo; l++) G[l + 1] = G[l] + H[l];
        for (u = 0; u < r; u++) e[n + u] !== 0 && (o[G[e[n + u]]++] = u);
        if (t === eI ? (j = Ue = o, Y = 20) : t === Xv ? (j = JB, Ue = XB, Y = 257) : (j = ez, Ue = tz, Y = 0), E = 0, u = 0, l = d, D = s, p = f, g = 0, N = -1, y = 1 << f, L = y - 1, t === Xv && y > JM || t === tI && y > XM) return 1;
        for (;;) {
            qt = l - g, o[u] + 1 < Y ? (v = 0, A = o[u]) : o[u] >= Y ? (v = Ue[o[u] - Y], A = j[o[u] - Y]) : (v = 96, A = 0), T = 1 << l - g, w = 1 << p, d = w;
            do w -= T, i[D + (E >> g) + w] = qt << 24 | v << 16 | A | 0; while (w !== 0);
            for (T = 1 << l - 1; E & T;) T >>= 1;
            if (T !== 0 ? (E &= T - 1, E += T) : E = 0, u++, --H[l] === 0) {
                if (l === h) break;
                l = e[n + o[u]]
            }
            if (l > f && (E & L) !== N) {
                for (g === 0 && (g = f), D += d, p = l - g, m = 1 << p; p + g < h && (m -= H[p + g], !(m <= 0));) p++, m <<= 1;
                if (y += 1 << p, t === Xv && y > JM || t === tI && y > XM) return 1;
                N = E & L, i[N] = f << 24 | p << 16 | D - s | 0
            }
        }
        return E !== 0 && (i[D + E] = l - g << 24 | 64 << 16 | 0), a.bits = f, 0
    },
    Oc = nz,
    rz = 0,
    YI = 1,
    JI = 2,
    {
        Z_FINISH: nI,
        Z_BLOCK: iz,
        Z_TREES: Vh,
        Z_OK: ws,
        Z_STREAM_END: sz,
        Z_NEED_DICT: oz,
        Z_STREAM_ERROR: Cn,
        Z_DATA_ERROR: XI,
        Z_MEM_ERROR: eT,
        Z_BUF_ERROR: az,
        Z_DEFLATED: rI
    } = qo,
    Zh = 16180,
    iI = 16181,
    sI = 16182,
    oI = 16183,
    aI = 16184,
    cI = 16185,
    lI = 16186,
    uI = 16187,
    dI = 16188,
    hI = 16189,
    Wh = 16190,
    Lr = 16191,
    ew = 16192,
    fI = 16193,
    tw = 16194,
    pI = 16195,
    gI = 16196,
    mI = 16197,
    yI = 16198,
    Uh = 16199,
    jh = 16200,
    vI = 16201,
    wI = 16202,
    _I = 16203,
    bI = 16204,
    DI = 16205,
    nw = 16206,
    EI = 16207,
    CI = 16208,
    Be = 16209,
    tT = 16210,
    nT = 16211,
    cz = 852,
    lz = 592,
    uz = 15,
    dz = uz,
    SI = t => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((t & 65280) << 8) + ((t & 255) << 24);

function hz() {
    this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
}
var _s = t => {
        if (!t) return 1;
        let e = t.state;
        return !e || e.strm !== t || e.mode < Zh || e.mode > nT ? 1 : 0
    },
    rT = t => {
        if (_s(t)) return Cn;
        let e = t.state;
        return t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = e.wrap & 1), e.mode = Zh, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(cz), e.distcode = e.distdyn = new Int32Array(lz), e.sane = 1, e.back = -1, ws
    },
    iT = t => {
        if (_s(t)) return Cn;
        let e = t.state;
        return e.wsize = 0, e.whave = 0, e.wnext = 0, rT(t)
    },
    sT = (t, e) => {
        let n;
        if (_s(t)) return Cn;
        let r = t.state;
        return e < 0 ? (n = 0, e = -e) : (n = (e >> 4) + 5, e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? Cn : (r.window !== null && r.wbits !== e && (r.window = null), r.wrap = n, r.wbits = e, iT(t))
    },
    oT = (t, e) => {
        if (!t) return Cn;
        let n = new hz;
        t.state = n, n.strm = t, n.window = null, n.mode = Zh;
        let r = sT(t, e);
        return r !== ws && (t.state = null), r
    },
    fz = t => oT(t, dz),
    MI = !0,
    rw, iw, pz = t => {
        if (MI) {
            rw = new Int32Array(512), iw = new Int32Array(32);
            let e = 0;
            for (; e < 144;) t.lens[e++] = 8;
            for (; e < 256;) t.lens[e++] = 9;
            for (; e < 280;) t.lens[e++] = 7;
            for (; e < 288;) t.lens[e++] = 8;
            for (Oc(YI, t.lens, 0, 288, rw, 0, t.work, {
                    bits: 9
                }), e = 0; e < 32;) t.lens[e++] = 5;
            Oc(JI, t.lens, 0, 32, iw, 0, t.work, {
                bits: 5
            }), MI = !1
        }
        t.lencode = rw, t.lenbits = 9, t.distcode = iw, t.distbits = 5
    },
    aT = (t, e, n, r) => {
        let i, s = t.state;
        return s.window === null && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), r >= s.wsize ? (s.window.set(e.subarray(n - s.wsize, n), 0), s.wnext = 0, s.whave = s.wsize) : (i = s.wsize - s.wnext, i > r && (i = r), s.window.set(e.subarray(n - r, n - r + i), s.wnext), r -= i, r ? (s.window.set(e.subarray(n - r, n), 0), s.wnext = r, s.whave = s.wsize) : (s.wnext += i, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += i))), 0
    },
    gz = (t, e) => {
        let n, r, i, s, o, a, c, l, u, d, h, f, p, g, m = 0,
            y, E, T, w, N, L, D, j, Y = new Uint8Array(4),
            H, G, Ue = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (_s(t) || !t.output || !t.input && t.avail_in !== 0) return Cn;
        n = t.state, n.mode === Lr && (n.mode = ew), o = t.next_out, i = t.output, c = t.avail_out, s = t.next_in, r = t.input, a = t.avail_in, l = n.hold, u = n.bits, d = a, h = c, j = ws;
        e: for (;;) switch (n.mode) {
            case Zh:
                if (n.wrap === 0) {
                    n.mode = ew;
                    break
                }
                for (; u < 16;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if (n.wrap & 2 && l === 35615) {
                    n.wbits === 0 && (n.wbits = 15), n.check = 0, Y[0] = l & 255, Y[1] = l >>> 8 & 255, n.check = ht(n.check, Y, 2, 0), l = 0, u = 0, n.mode = iI;
                    break
                }
                if (n.head && (n.head.done = !1), !(n.wrap & 1) || (((l & 255) << 8) + (l >> 8)) % 31) {
                    t.msg = "incorrect header check", n.mode = Be;
                    break
                }
                if ((l & 15) !== rI) {
                    t.msg = "unknown compression method", n.mode = Be;
                    break
                }
                if (l >>>= 4, u -= 4, D = (l & 15) + 8, n.wbits === 0 && (n.wbits = D), D > 15 || D > n.wbits) {
                    t.msg = "invalid window size", n.mode = Be;
                    break
                }
                n.dmax = 1 << n.wbits, n.flags = 0, t.adler = n.check = 1, n.mode = l & 512 ? hI : Lr, l = 0, u = 0;
                break;
            case iI:
                for (; u < 16;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if (n.flags = l, (n.flags & 255) !== rI) {
                    t.msg = "unknown compression method", n.mode = Be;
                    break
                }
                if (n.flags & 57344) {
                    t.msg = "unknown header flags set", n.mode = Be;
                    break
                }
                n.head && (n.head.text = l >> 8 & 1), n.flags & 512 && n.wrap & 4 && (Y[0] = l & 255, Y[1] = l >>> 8 & 255, n.check = ht(n.check, Y, 2, 0)), l = 0, u = 0, n.mode = sI;
            case sI:
                for (; u < 32;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                n.head && (n.head.time = l), n.flags & 512 && n.wrap & 4 && (Y[0] = l & 255, Y[1] = l >>> 8 & 255, Y[2] = l >>> 16 & 255, Y[3] = l >>> 24 & 255, n.check = ht(n.check, Y, 4, 0)), l = 0, u = 0, n.mode = oI;
            case oI:
                for (; u < 16;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                n.head && (n.head.xflags = l & 255, n.head.os = l >> 8), n.flags & 512 && n.wrap & 4 && (Y[0] = l & 255, Y[1] = l >>> 8 & 255, n.check = ht(n.check, Y, 2, 0)), l = 0, u = 0, n.mode = aI;
            case aI:
                if (n.flags & 1024) {
                    for (; u < 16;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    n.length = l, n.head && (n.head.extra_len = l), n.flags & 512 && n.wrap & 4 && (Y[0] = l & 255, Y[1] = l >>> 8 & 255, n.check = ht(n.check, Y, 2, 0)), l = 0, u = 0
                } else n.head && (n.head.extra = null);
                n.mode = cI;
            case cI:
                if (n.flags & 1024 && (f = n.length, f > a && (f = a), f && (n.head && (D = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(r.subarray(s, s + f), D)), n.flags & 512 && n.wrap & 4 && (n.check = ht(n.check, r, f, s)), a -= f, s += f, n.length -= f), n.length)) break e;
                n.length = 0, n.mode = lI;
            case lI:
                if (n.flags & 2048) {
                    if (a === 0) break e;
                    f = 0;
                    do D = r[s + f++], n.head && D && n.length < 65536 && (n.head.name += String.fromCharCode(D)); while (D && f < a);
                    if (n.flags & 512 && n.wrap & 4 && (n.check = ht(n.check, r, f, s)), a -= f, s += f, D) break e
                } else n.head && (n.head.name = null);
                n.length = 0, n.mode = uI;
            case uI:
                if (n.flags & 4096) {
                    if (a === 0) break e;
                    f = 0;
                    do D = r[s + f++], n.head && D && n.length < 65536 && (n.head.comment += String.fromCharCode(D)); while (D && f < a);
                    if (n.flags & 512 && n.wrap & 4 && (n.check = ht(n.check, r, f, s)), a -= f, s += f, D) break e
                } else n.head && (n.head.comment = null);
                n.mode = dI;
            case dI:
                if (n.flags & 512) {
                    for (; u < 16;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    if (n.wrap & 4 && l !== (n.check & 65535)) {
                        t.msg = "header crc mismatch", n.mode = Be;
                        break
                    }
                    l = 0, u = 0
                }
                n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), t.adler = n.check = 0, n.mode = Lr;
                break;
            case hI:
                for (; u < 32;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                t.adler = n.check = SI(l), l = 0, u = 0, n.mode = Wh;
            case Wh:
                if (n.havedict === 0) return t.next_out = o, t.avail_out = c, t.next_in = s, t.avail_in = a, n.hold = l, n.bits = u, oz;
                t.adler = n.check = 1, n.mode = Lr;
            case Lr:
                if (e === iz || e === Vh) break e;
            case ew:
                if (n.last) {
                    l >>>= u & 7, u -= u & 7, n.mode = nw;
                    break
                }
                for (; u < 3;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                switch (n.last = l & 1, l >>>= 1, u -= 1, l & 3) {
                    case 0:
                        n.mode = fI;
                        break;
                    case 1:
                        if (pz(n), n.mode = Uh, e === Vh) {
                            l >>>= 2, u -= 2;
                            break e
                        }
                        break;
                    case 2:
                        n.mode = gI;
                        break;
                    case 3:
                        t.msg = "invalid block type", n.mode = Be
                }
                l >>>= 2, u -= 2;
                break;
            case fI:
                for (l >>>= u & 7, u -= u & 7; u < 32;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if ((l & 65535) !== (l >>> 16 ^ 65535)) {
                    t.msg = "invalid stored block lengths", n.mode = Be;
                    break
                }
                if (n.length = l & 65535, l = 0, u = 0, n.mode = tw, e === Vh) break e;
            case tw:
                n.mode = pI;
            case pI:
                if (f = n.length, f) {
                    if (f > a && (f = a), f > c && (f = c), f === 0) break e;
                    i.set(r.subarray(s, s + f), o), a -= f, s += f, c -= f, o += f, n.length -= f;
                    break
                }
                n.mode = Lr;
                break;
            case gI:
                for (; u < 14;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if (n.nlen = (l & 31) + 257, l >>>= 5, u -= 5, n.ndist = (l & 31) + 1, l >>>= 5, u -= 5, n.ncode = (l & 15) + 4, l >>>= 4, u -= 4, n.nlen > 286 || n.ndist > 30) {
                    t.msg = "too many length or distance symbols", n.mode = Be;
                    break
                }
                n.have = 0, n.mode = mI;
            case mI:
                for (; n.have < n.ncode;) {
                    for (; u < 3;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    n.lens[Ue[n.have++]] = l & 7, l >>>= 3, u -= 3
                }
                for (; n.have < 19;) n.lens[Ue[n.have++]] = 0;
                if (n.lencode = n.lendyn, n.lenbits = 7, H = {
                        bits: n.lenbits
                    }, j = Oc(rz, n.lens, 0, 19, n.lencode, 0, n.work, H), n.lenbits = H.bits, j) {
                    t.msg = "invalid code lengths set", n.mode = Be;
                    break
                }
                n.have = 0, n.mode = yI;
            case yI:
                for (; n.have < n.nlen + n.ndist;) {
                    for (; m = n.lencode[l & (1 << n.lenbits) - 1], y = m >>> 24, E = m >>> 16 & 255, T = m & 65535, !(y <= u);) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    if (T < 16) l >>>= y, u -= y, n.lens[n.have++] = T;
                    else {
                        if (T === 16) {
                            for (G = y + 2; u < G;) {
                                if (a === 0) break e;
                                a--, l += r[s++] << u, u += 8
                            }
                            if (l >>>= y, u -= y, n.have === 0) {
                                t.msg = "invalid bit length repeat", n.mode = Be;
                                break
                            }
                            D = n.lens[n.have - 1], f = 3 + (l & 3), l >>>= 2, u -= 2
                        } else if (T === 17) {
                            for (G = y + 3; u < G;) {
                                if (a === 0) break e;
                                a--, l += r[s++] << u, u += 8
                            }
                            l >>>= y, u -= y, D = 0, f = 3 + (l & 7), l >>>= 3, u -= 3
                        } else {
                            for (G = y + 7; u < G;) {
                                if (a === 0) break e;
                                a--, l += r[s++] << u, u += 8
                            }
                            l >>>= y, u -= y, D = 0, f = 11 + (l & 127), l >>>= 7, u -= 7
                        }
                        if (n.have + f > n.nlen + n.ndist) {
                            t.msg = "invalid bit length repeat", n.mode = Be;
                            break
                        }
                        for (; f--;) n.lens[n.have++] = D
                    }
                }
                if (n.mode === Be) break;
                if (n.lens[256] === 0) {
                    t.msg = "invalid code -- missing end-of-block", n.mode = Be;
                    break
                }
                if (n.lenbits = 9, H = {
                        bits: n.lenbits
                    }, j = Oc(YI, n.lens, 0, n.nlen, n.lencode, 0, n.work, H), n.lenbits = H.bits, j) {
                    t.msg = "invalid literal/lengths set", n.mode = Be;
                    break
                }
                if (n.distbits = 6, n.distcode = n.distdyn, H = {
                        bits: n.distbits
                    }, j = Oc(JI, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, H), n.distbits = H.bits, j) {
                    t.msg = "invalid distances set", n.mode = Be;
                    break
                }
                if (n.mode = Uh, e === Vh) break e;
            case Uh:
                n.mode = jh;
            case jh:
                if (a >= 6 && c >= 258) {
                    t.next_out = o, t.avail_out = c, t.next_in = s, t.avail_in = a, n.hold = l, n.bits = u, YB(t, h), o = t.next_out, i = t.output, c = t.avail_out, s = t.next_in, r = t.input, a = t.avail_in, l = n.hold, u = n.bits, n.mode === Lr && (n.back = -1);
                    break
                }
                for (n.back = 0; m = n.lencode[l & (1 << n.lenbits) - 1], y = m >>> 24, E = m >>> 16 & 255, T = m & 65535, !(y <= u);) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if (E && !(E & 240)) {
                    for (w = y, N = E, L = T; m = n.lencode[L + ((l & (1 << w + N) - 1) >> w)], y = m >>> 24, E = m >>> 16 & 255, T = m & 65535, !(w + y <= u);) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    l >>>= w, u -= w, n.back += w
                }
                if (l >>>= y, u -= y, n.back += y, n.length = T, E === 0) {
                    n.mode = DI;
                    break
                }
                if (E & 32) {
                    n.back = -1, n.mode = Lr;
                    break
                }
                if (E & 64) {
                    t.msg = "invalid literal/length code", n.mode = Be;
                    break
                }
                n.extra = E & 15, n.mode = vI;
            case vI:
                if (n.extra) {
                    for (G = n.extra; u < G;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    n.length += l & (1 << n.extra) - 1, l >>>= n.extra, u -= n.extra, n.back += n.extra
                }
                n.was = n.length, n.mode = wI;
            case wI:
                for (; m = n.distcode[l & (1 << n.distbits) - 1], y = m >>> 24, E = m >>> 16 & 255, T = m & 65535, !(y <= u);) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if (!(E & 240)) {
                    for (w = y, N = E, L = T; m = n.distcode[L + ((l & (1 << w + N) - 1) >> w)], y = m >>> 24, E = m >>> 16 & 255, T = m & 65535, !(w + y <= u);) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    l >>>= w, u -= w, n.back += w
                }
                if (l >>>= y, u -= y, n.back += y, E & 64) {
                    t.msg = "invalid distance code", n.mode = Be;
                    break
                }
                n.offset = T, n.extra = E & 15, n.mode = _I;
            case _I:
                if (n.extra) {
                    for (G = n.extra; u < G;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    n.offset += l & (1 << n.extra) - 1, l >>>= n.extra, u -= n.extra, n.back += n.extra
                }
                if (n.offset > n.dmax) {
                    t.msg = "invalid distance too far back", n.mode = Be;
                    break
                }
                n.mode = bI;
            case bI:
                if (c === 0) break e;
                if (f = h - c, n.offset > f) {
                    if (f = n.offset - f, f > n.whave && n.sane) {
                        t.msg = "invalid distance too far back", n.mode = Be;
                        break
                    }
                    f > n.wnext ? (f -= n.wnext, p = n.wsize - f) : p = n.wnext - f, f > n.length && (f = n.length), g = n.window
                } else g = i, p = o - n.offset, f = n.length;
                f > c && (f = c), c -= f, n.length -= f;
                do i[o++] = g[p++]; while (--f);
                n.length === 0 && (n.mode = jh);
                break;
            case DI:
                if (c === 0) break e;
                i[o++] = n.length, c--, n.mode = jh;
                break;
            case nw:
                if (n.wrap) {
                    for (; u < 32;) {
                        if (a === 0) break e;
                        a--, l |= r[s++] << u, u += 8
                    }
                    if (h -= c, t.total_out += h, n.total += h, n.wrap & 4 && h && (t.adler = n.check = n.flags ? ht(n.check, i, h, o - h) : Vc(n.check, i, h, o - h)), h = c, n.wrap & 4 && (n.flags ? l : SI(l)) !== n.check) {
                        t.msg = "incorrect data check", n.mode = Be;
                        break
                    }
                    l = 0, u = 0
                }
                n.mode = EI;
            case EI:
                if (n.wrap && n.flags) {
                    for (; u < 32;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    if (n.wrap & 4 && l !== (n.total & 4294967295)) {
                        t.msg = "incorrect length check", n.mode = Be;
                        break
                    }
                    l = 0, u = 0
                }
                n.mode = CI;
            case CI:
                j = sz;
                break e;
            case Be:
                j = XI;
                break e;
            case tT:
                return eT;
            case nT:
            default:
                return Cn
        }
        return t.next_out = o, t.avail_out = c, t.next_in = s, t.avail_in = a, n.hold = l, n.bits = u, (n.wsize || h !== t.avail_out && n.mode < Be && (n.mode < nw || e !== nI)) && aT(t, t.output, t.next_out, h - t.avail_out), d -= t.avail_in, h -= t.avail_out, t.total_in += d, t.total_out += h, n.total += h, n.wrap & 4 && h && (t.adler = n.check = n.flags ? ht(n.check, i, h, t.next_out - h) : Vc(n.check, i, h, t.next_out - h)), t.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === Lr ? 128 : 0) + (n.mode === Uh || n.mode === tw ? 256 : 0), (d === 0 && h === 0 || e === nI) && j === ws && (j = az), j
    },
    mz = t => {
        if (_s(t)) return Cn;
        let e = t.state;
        return e.window && (e.window = null), t.state = null, ws
    },
    yz = (t, e) => {
        if (_s(t)) return Cn;
        let n = t.state;
        return n.wrap & 2 ? (n.head = e, e.done = !1, ws) : Cn
    },
    vz = (t, e) => {
        let n = e.length,
            r, i, s;
        return _s(t) || (r = t.state, r.wrap !== 0 && r.mode !== Wh) ? Cn : r.mode === Wh && (i = 1, i = Vc(i, e, n, 0), i !== r.check) ? XI : (s = aT(t, e, n, n), s ? (r.mode = tT, eT) : (r.havedict = 1, ws))
    },
    wz = iT,
    _z = sT,
    bz = rT,
    Dz = fz,
    Ez = oT,
    Cz = gz,
    Sz = mz,
    Mz = yz,
    Iz = vz,
    Tz = "pako inflate (from Nodeca project)",
    Ur = {
        inflateReset: wz,
        inflateReset2: _z,
        inflateResetKeep: bz,
        inflateInit: Dz,
        inflateInit2: Ez,
        inflate: Cz,
        inflateEnd: Sz,
        inflateGetHeader: Mz,
        inflateSetDictionary: Iz,
        inflateInfo: Tz
    };

function xz() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
}
var Az = xz,
    cT = Object.prototype.toString,
    {
        Z_NO_FLUSH: Nz,
        Z_FINISH: Rz,
        Z_OK: Bc,
        Z_STREAM_END: sw,
        Z_NEED_DICT: ow,
        Z_STREAM_ERROR: Oz,
        Z_DATA_ERROR: II,
        Z_MEM_ERROR: Fz
    } = qo;

function Hc(t) {
    this.options = Gh.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
    }, t || {});
    let e = this.options;
    e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, e.windowBits === 0 && (e.windowBits = -15)), e.windowBits >= 0 && e.windowBits < 16 && !(t && t.windowBits) && (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (e.windowBits & 15 || (e.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new qI, this.strm.avail_out = 0;
    let n = Ur.inflateInit2(this.strm, e.windowBits);
    if (n !== Bc) throw new Error(ys[n]);
    if (this.header = new Az, Ur.inflateGetHeader(this.strm, this.header), e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = jc.string2buf(e.dictionary) : cT.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (n = Ur.inflateSetDictionary(this.strm, e.dictionary), n !== Bc))) throw new Error(ys[n])
}
Hc.prototype.push = function(t, e) {
    let n = this.strm,
        r = this.options.chunkSize,
        i = this.options.dictionary,
        s, o, a;
    if (this.ended) return !1;
    for (e === ~~e ? o = e : o = e === !0 ? Rz : Nz, cT.call(t) === "[object ArrayBuffer]" ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;;) {
        for (n.avail_out === 0 && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), s = Ur.inflate(n, o), s === ow && i && (s = Ur.inflateSetDictionary(n, i), s === Bc ? s = Ur.inflate(n, o) : s === II && (s = ow)); n.avail_in > 0 && s === sw && n.state.wrap > 0 && t[n.next_in] !== 0;) Ur.inflateReset(n), s = Ur.inflate(n, o);
        switch (s) {
            case Oz:
            case II:
            case ow:
            case Fz:
                return this.onEnd(s), this.ended = !0, !1
        }
        if (a = n.avail_out, n.next_out && (n.avail_out === 0 || s === sw))
            if (this.options.to === "string") {
                let c = jc.utf8border(n.output, n.next_out),
                    l = n.next_out - c,
                    u = jc.buf2string(n.output, c);
                n.next_out = l, n.avail_out = r - l, l && n.output.set(n.output.subarray(c, c + l), 0), this.onData(u)
            } else this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
        if (!(s === Bc && a === 0)) {
            if (s === sw) return s = Ur.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
            if (n.avail_in === 0) break
        }
    }
    return !0
};
Hc.prototype.onData = function(t) {
    this.chunks.push(t)
};
Hc.prototype.onEnd = function(t) {
    t === Bc && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Gh.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
};

function Dw(t, e) {
    let n = new Hc(e);
    if (n.push(t), n.err) throw n.msg || ys[n.err];
    return n.result
}

function kz(t, e) {
    return e = e || {}, e.raw = !0, Dw(t, e)
}
var Pz = Hc,
    Lz = Dw,
    Vz = kz,
    Uz = Dw,
    jz = qo,
    Bz = {
        Inflate: Pz,
        inflate: Lz,
        inflateRaw: Vz,
        ungzip: Uz,
        constants: jz
    },
    {
        Deflate: sY,
        deflate: oY,
        deflateRaw: aY,
        gzip: cY
    } = qB,
    {
        Inflate: lY,
        inflate: zz,
        inflateRaw: uY,
        ungzip: dY
    } = Bz;
var lT = zz;
var DT = Hn(q0());

function $z(t, e) {
    return Array.apply(0, new Array(Math.ceil(t.length / e))).map((n, r) => t.slice(r * e, (r + 1) * e))
}
var Gc = t => "version" in t;

function Wz(t) {
    return new TextDecoder("utf-8").decode(t)
}

function Hz(t) {
    return new TextEncoder().encode(t)
}

function uT(t) {
    return Jo.default.encode(t)
}

function dT(t) {
    return t.toString("base64")
}

function ET(t) {
    return Mn.Buffer.from(t, "base64")
}

function Gz(t) {
    let e = new Map;
    return t.errors && t.errors.forEach(n => {
        var r;
        let i = (r = n.msg) !== null && r !== void 0 ? r : n.name;
        e.set(n.code, i)
    }), e
}

function Zz(t, ...e) {
    if (t.args.length != e.length) throw new Error("Invalid argument length");
    let n = {},
        r = 0;
    return t.args.forEach(i => {
        n[i.name] = e[r], r += 1
    }), n
}

function CT(t, e = {}) {
    t.forEach(n => {
        if ("accounts" in n) CT(n.accounts, e[n.name]);
        else if (e[n.name] === void 0) throw new Error(`Invalid arguments: ${n.name} not provided.`)
    })
}

function Sn(t) {
    return t instanceof me ? t : new me(t)
}
var Mw = class extends TypeError {
    constructor(e, n) {
        let r, c = e,
            {
                message: i
            } = c,
            s = Tn(c, ["message"]),
            {
                path: o
            } = e,
            a = o.length === 0 ? i : "At path: " + o.join(".") + " -- " + i;
        super(a), this.value = void 0, this.key = void 0, this.type = void 0, this.refinement = void 0, this.path = void 0, this.branch = void 0, this.failures = void 0, Object.assign(this, s), this.name = this.constructor.name, this.failures = () => {
            var l;
            return (l = r) != null ? l : r = [e, ...n()]
        }
    }
};

function Qz(t) {
    return Xo(t) && typeof t[Symbol.iterator] == "function"
}

function Xo(t) {
    return typeof t == "object" && t != null
}

function Mi(t) {
    return typeof t == "string" ? JSON.stringify(t) : "" + t
}

function qz(t) {
    let {
        done: e,
        value: n
    } = t.next();
    return e ? void 0 : n
}

function Kz(t, e, n, r) {
    if (t === !0) return;
    t === !1 ? t = {} : typeof t == "string" && (t = {
        message: t
    });
    let {
        path: i,
        branch: s
    } = e, {
        type: o
    } = n, {
        refinement: a,
        message: c = "Expected a value of type `" + o + "`" + (a ? " with refinement `" + a + "`" : "") + ", but received: `" + Mi(r) + "`"
    } = t;
    return Q(_({
        value: r,
        type: o,
        refinement: a,
        key: i[i.length - 1],
        path: i,
        branch: s
    }, t), {
        message: c
    })
}

function* hT(t, e, n, r) {
    Qz(t) || (t = [t]);
    for (let i of t) {
        let s = Kz(i, e, n, r);
        s && (yield s)
    }
}

function* h0(t, e, n) {
    n === void 0 && (n = {});
    let {
        path: r = [],
        branch: i = [t],
        coerce: s = !1,
        mask: o = !1
    } = n, a = {
        path: r,
        branch: i
    };
    if (s && (t = e.coercer(t, a), o && e.type !== "type" && Xo(e.schema) && Xo(t) && !Array.isArray(t)))
        for (let l in t) e.schema[l] === void 0 && delete t[l];
    let c = !0;
    for (let l of e.validator(t, a)) c = !1, yield [l, void 0];
    for (let [l, u, d] of e.entries(t, a)) {
        let h = h0(u, d, {
            path: l === void 0 ? r : [...r, l],
            branch: l === void 0 ? i : [...i, u],
            coerce: s,
            mask: o
        });
        for (let f of h) f[0] ? (c = !1, yield [f[0], void 0]) : s && (u = f[1], l === void 0 ? t = u : t instanceof Map ? t.set(l, u) : t instanceof Set ? t.add(u) : Xo(t) && (t[l] = u))
    }
    if (c)
        for (let l of e.refiner(t, a)) c = !1, yield [l, void 0];
    c && (yield [void 0, t])
}
var gr = class {
    constructor(e) {
        this.TYPE = void 0, this.type = void 0, this.schema = void 0, this.coercer = void 0, this.validator = void 0, this.refiner = void 0, this.entries = void 0;
        let {
            type: n,
            schema: r,
            validator: i,
            refiner: s,
            coercer: o = c => c,
            entries: a = function*() {}
        } = e;
        this.type = n, this.schema = r, this.entries = a, this.coercer = o, i ? this.validator = (c, l) => {
            let u = i(c, l);
            return hT(u, l, this, c)
        } : this.validator = () => [], s ? this.refiner = (c, l) => {
            let u = s(c, l);
            return hT(u, l, this, c)
        } : this.refiner = () => []
    }
    assert(e) {
        return Yz(e, this)
    }
    create(e) {
        return f0(e, this)
    }
    is(e) {
        return ST(e, this)
    }
    mask(e) {
        return Jz(e, this)
    }
    validate(e, n) {
        return n === void 0 && (n = {}), Yc(e, this, n)
    }
};

function Yz(t, e) {
    let n = Yc(t, e);
    if (n[0]) throw n[0]
}

function f0(t, e) {
    let n = Yc(t, e, {
        coerce: !0
    });
    if (n[0]) throw n[0];
    return n[1]
}

function Jz(t, e) {
    let n = Yc(t, e, {
        coerce: !0,
        mask: !0
    });
    if (n[0]) throw n[0];
    return n[1]
}

function ST(t, e) {
    return !Yc(t, e)[0]
}

function Yc(t, e, n) {
    n === void 0 && (n = {});
    let r = h0(t, e, n),
        i = qz(r);
    return i[0] ? [new Mw(i[0], function*() {
        for (let o of r) o[0] && (yield o[0])
    }), void 0] : [void 0, i[1]]
}

function Jc(t, e) {
    return new gr({
        type: t,
        schema: null,
        validator: e
    })
}

function Xz() {
    return Jc("any", () => !0)
}

function Ew(t) {
    return new gr({
        type: "array",
        schema: t,
        * entries(e) {
            if (t && Array.isArray(e))
                for (let [n, r] of e.entries()) yield [n, r, t]
        },
        coercer(e) {
            return Array.isArray(e) ? e.slice() : e
        },
        validator(e) {
            return Array.isArray(e) || "Expected an array value, but received: " + Mi(e)
        }
    })
}

function e$() {
    return Jc("boolean", t => typeof t == "boolean")
}

function fT(t) {
    let e = Mi(t),
        n = typeof t;
    return new gr({
        type: "literal",
        schema: n === "string" || n === "number" || n === "boolean" ? t : null,
        validator(r) {
            return r === t || "Expected the literal `" + e + "`, but received: " + Mi(r)
        }
    })
}

function Qh(t) {
    return new gr(Q(_({}, t), {
        validator: (e, n) => e === null || t.validator(e, n),
        refiner: (e, n) => e === null || t.refiner(e, n)
    }))
}

function Kh() {
    return Jc("number", t => typeof t == "number" && !isNaN(t) || "Expected a number, but received: " + Mi(t))
}

function Yh(t) {
    return new gr(Q(_({}, t), {
        validator: (e, n) => e === void 0 || t.validator(e, n),
        refiner: (e, n) => e === void 0 || t.refiner(e, n)
    }))
}

function bs() {
    return Jc("string", t => typeof t == "string" || "Expected a string, but received: " + Mi(t))
}

function Si(t) {
    let e = Object.keys(t);
    return new gr({
        type: "type",
        schema: t,
        * entries(n) {
            if (Xo(n))
                for (let r of e) yield [r, n[r], t[r]]
        },
        validator(n) {
            return Xo(n) || "Expected an object, but received: " + Mi(n)
        }
    })
}

function MT(t) {
    let e = t.map(n => n.type).join(" | ");
    return new gr({
        type: "union",
        schema: null,
        coercer(n, r) {
            return (t.find(s => {
                let [o] = s.validate(n, {
                    coerce: !0
                });
                return !o
            }) || p0()).coercer(n, r)
        },
        validator(n, r) {
            let i = [];
            for (let s of t) {
                let [...o] = h0(n, s, r), [a] = o;
                if (a[0])
                    for (let [c] of o) c && i.push(c);
                else return []
            }
            return ["Expected the value to satisfy a union of `" + e + "`, but received: " + Mi(n), ...i]
        }
    })
}

function p0() {
    return Jc("unknown", () => !0)
}

function t$(t, e, n) {
    return new gr(Q(_({}, t), {
        coercer: (r, i) => ST(r, e) ? t.coercer(n(r, i), i) : t.coercer(r, i)
    }))
}
var pT = 99;

function n$(t, e, n) {
    return x(this, null, function*() {
        if (e.length <= pT) return yield gT(t, e, n); {
            let r = $z(e, pT);
            return (yield Promise.all(r.map(s => gT(t, s, n)))).flat()
        }
    })
}

function gT(t, e, n) {
    return x(this, null, function*() {
        let r = n ? ? t.commitment,
            {
                value: i,
                context: s
            } = yield t.getMultipleAccountsInfoAndContext(e, r);
        return i.map((a, c) => a === null ? null : {
            publicKey: e[c],
            account: a,
            context: s
        })
    })
}

function r$(t, e, n, r, i) {
    return x(this, null, function*() {
        var s;
        n && n.length > 0 && e.sign(...n);
        let o = e._compile(),
            a = o.serialize(),
            l = e._serialize(a).toString("base64"),
            u = {
                encoding: "base64",
                commitment: r ? ? t.commitment
            };
        if (i) {
            let p = (Array.isArray(i) ? i : o.nonProgramIds()).map(g => g.toBase58());
            u.accounts = {
                encoding: "base64",
                addresses: p
            }
        }
        n && (u.sigVerify = !0);
        let d = [l, u],
            h = yield t._rpcRequest("simulateTransaction", d), f = f0(h, a$);
        if ("error" in f) {
            let p;
            if ("data" in f.error && (p = (s = f.error.data) === null || s === void 0 ? void 0 : s.logs, p && Array.isArray(p))) {
                let g = `
    `,
                    m = g + p.join(g);
                console.error(f.error.message, m)
            }
            throw new fl("failed to simulate transaction: " + f.error.message, p)
        }
        return f.result
    })
}

function i$(t) {
    return t$(IT(t), s$, e => "error" in e ? e : Q(_({}, e), {
        result: f0(e.result, t)
    }))
}
var s$ = IT(p0());

function IT(t) {
    return MT([Si({
        jsonrpc: fT("2.0"),
        id: bs(),
        result: t
    }), Si({
        jsonrpc: fT("2.0"),
        id: bs(),
        error: Si({
            code: p0(),
            message: bs(),
            data: Yh(Xz())
        })
    })])
}

function o$(t) {
    return i$(Si({
        context: Si({
            slot: Kh()
        }),
        value: t
    }))
}
var a$ = o$(Si({
    err: Qh(MT([Si({}), bs()])),
    logs: Qh(Ew(bs())),
    accounts: Yh(Qh(Ew(Qh(Si({
        executable: e$(),
        owner: bs(),
        lamports: Kh(),
        data: Ew(bs()),
        rentEpoch: Yh(Kh())
    }))))),
    unitsConsumed: Yh(Kh())
}));
var Qc = class {
        constructor(e, n, r) {
            this.connection = e, this.wallet = n, this.opts = r, this.publicKey = n ? .publicKey
        }
        static defaultOptions() {
            return {
                preflightCommitment: "processed",
                commitment: "processed"
            }
        }
        static local(e, n) {
            throw new Error("Provider local is not available on browser.")
        }
        static env() {
            throw new Error("Provider env is not available on browser.")
        }
        sendAndConfirm(e, n, r) {
            return x(this, null, function*() {
                var i, s, o, a;
                if (r === void 0 && (r = this.opts), Gc(e)) n && e.sign(n);
                else if (e.feePayer = (i = e.feePayer) !== null && i !== void 0 ? i : this.wallet.publicKey, e.recentBlockhash = (yield this.connection.getLatestBlockhash(r.preflightCommitment)).blockhash, n)
                    for (let l of n) e.partialSign(l);
                e = yield this.wallet.signTransaction(e);
                let c = e.serialize();
                try {
                    return yield mT(this.connection, c, r)
                } catch (l) {
                    if (l instanceof qc) {
                        let u = uT(Gc(e) ? ((s = e.signatures) === null || s === void 0 ? void 0 : s[0]) || new Uint8Array : (o = e.signature) !== null && o !== void 0 ? o : new Uint8Array),
                            d = yield this.connection.getTransaction(u, {
                                commitment: "confirmed"
                            });
                        if (d) {
                            let h = (a = d.meta) === null || a === void 0 ? void 0 : a.logMessages;
                            throw h ? new fl(l.message, h) : l
                        } else throw l
                    } else throw l
                }
            })
        }
        sendAll(e, n) {
            return x(this, null, function*() {
                var r, i, s;
                n === void 0 && (n = this.opts);
                let o = (yield this.connection.getLatestBlockhash(n.preflightCommitment)).blockhash,
                    a = e.map(u => {
                        var d, h;
                        if (Gc(u.tx)) {
                            let f = u.tx;
                            return u.signers && f.sign(u.signers), f
                        } else {
                            let f = u.tx,
                                p = (d = u.signers) !== null && d !== void 0 ? d : [];
                            return f.feePayer = (h = f.feePayer) !== null && h !== void 0 ? h : this.wallet.publicKey, f.recentBlockhash = o, p.forEach(g => {
                                f.partialSign(g)
                            }), f
                        }
                    }),
                    c = yield this.wallet.signAllTransactions(a), l = [];
                for (let u = 0; u < a.length; u += 1) {
                    let d = c[u],
                        h = d.serialize();
                    try {
                        l.push(yield mT(this.connection, h, n))
                    } catch (f) {
                        if (f instanceof qc) {
                            let p = uT(Gc(d) ? ((r = d.signatures) === null || r === void 0 ? void 0 : r[0]) || new Uint8Array : (i = d.signature) !== null && i !== void 0 ? i : new Uint8Array),
                                g = yield this.connection.getTransaction(p, {
                                    commitment: "confirmed"
                                });
                            if (g) {
                                let m = (s = g.meta) === null || s === void 0 ? void 0 : s.logMessages;
                                throw m ? new fl(f.message, m) : f
                            } else throw f
                        } else throw f
                    }
                }
                return l
            })
        }
        simulate(e, n, r, i) {
            return x(this, null, function*() {
                let s = (yield this.connection.getLatestBlockhash(r ? ? this.connection.commitment)).blockhash,
                    o;
                if (Gc(e) ? (n && (e.sign(n), e = yield this.wallet.signTransaction(e)), o = yield this.connection.simulateTransaction(e, {
                        commitment: r
                    })) : (e.feePayer = e.feePayer || this.wallet.publicKey, e.recentBlockhash = s, n && (e = yield this.wallet.signTransaction(e)), o = yield r$(this.connection, e, n, r, i)), o.value.err) throw new Iw(o.value);
                return o.value
            })
        }
    },
    Iw = class extends Error {
        constructor(e, n) {
            super(n), this.simulationResponse = e
        }
    };

function mT(t, e, n) {
    return x(this, null, function*() {
        let r = n && {
                skipPreflight: n.skipPreflight,
                preflightCommitment: n.preflightCommitment || n.commitment
            },
            i = yield t.sendRawTransaction(e, r), s = (yield t.confirmTransaction(i, n && n.commitment)).value;
        if (s.err) throw new qc(`Raw transaction ${i} failed (${JSON.stringify(s)})`);
        return i
    })
}
var qc = class extends Error {
    constructor(e) {
        super(e)
    }
};

function Tw() {
    return yT === null ? Qc.local() : yT
}
var yT = null;
var c$ = new Map;

function TT(t) {
    return c$.get(t) !== void 0
}
var ea = class extends Error {
        constructor(e) {
            super(e), this.name = "IdlError"
        }
    },
    Kc = class t {
        constructor(e) {
            this.stack = e
        }
        static parse(e) {
            var n;
            let r = /^Program (\w*) invoke/,
                i = /^Program \w* success/,
                s = [];
            for (let o = 0; o < e.length; o++) {
                if (i.exec(e[o])) {
                    s.pop();
                    continue
                }
                let a = (n = r.exec(e[o])) === null || n === void 0 ? void 0 : n[1];
                a && s.push(new me(a))
            }
            return new t(s)
        }
    },
    xw = class t extends Error {
        constructor(e, n, r, i, s, o) {
            super(r.join(`
`).replace("Program log: ", "")), this.errorLogs = r, this.logs = i, this.error = {
                errorCode: e,
                errorMessage: n,
                comparedValues: o,
                origin: s
            }, this._programErrorStack = Kc.parse(i)
        }
        static parse(e) {
            if (!e) return null;
            let n = e.findIndex(h => h.startsWith("Program log: AnchorError"));
            if (n === -1) return null;
            let r = e[n],
                i = [r],
                s;
            if (n + 1 < e.length) {
                if (e[n + 1] === "Program log: Left:") {
                    let h = /^Program log: (.*)$/,
                        f = h.exec(e[n + 2])[1],
                        p = h.exec(e[n + 4])[1];
                    s = [new me(f), new me(p)], i.push(...e.slice(n + 1, n + 5))
                } else if (e[n + 1].startsWith("Program log: Left:")) {
                    let h = /^Program log: (Left|Right): (.*)$/,
                        f = h.exec(e[n + 1])[2],
                        p = h.exec(e[n + 2])[2];
                    i.push(...e.slice(n + 1, n + 3)), s = [f, p]
                }
            }
            let a = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r),
                l = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r),
                d = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r);
            if (a) {
                let [h, f, p] = a.slice(1, 4), g = {
                    code: h,
                    number: parseInt(f)
                };
                return new t(g, p, i, e, void 0, s)
            } else if (l) {
                let [h, f, p, g, m] = l.slice(1, 6), y = {
                    code: p,
                    number: parseInt(g)
                }, E = {
                    file: h,
                    line: parseInt(f)
                };
                return new t(y, m, i, e, E, s)
            } else if (d) {
                let [h, f, p, g] = d.slice(1, 5), m = h, y = {
                    code: f,
                    number: parseInt(p)
                };
                return new t(y, g, i, e, m, s)
            } else return null
        }
        get program() {
            return this._programErrorStack.stack[this._programErrorStack.stack.length - 1]
        }
        get programErrorStack() {
            return this._programErrorStack.stack
        }
        toString() {
            return this.message
        }
    },
    Aw = class t extends Error {
        constructor(e, n, r) {
            super(), this.code = e, this.msg = n, this.logs = r, r && (this._programErrorStack = Kc.parse(r))
        }
        static parse(e, n) {
            let r = e.toString(),
                i;
            if (r.includes("custom program error:")) {
                let a = r.split("custom program error: ");
                if (a.length !== 2) return null;
                i = a[1]
            } else {
                let a = r.match(/"Custom":([0-9]+)}/g);
                if (!a || a.length > 1) return null;
                i = a[0].match(/([0-9]+)/g)[0]
            }
            let s;
            try {
                s = parseInt(i)
            } catch {
                return null
            }
            let o = n.get(s);
            return o !== void 0 ? new t(s, o, e.logs) : (o = l$.get(s), o !== void 0 ? new t(s, o, e.logs) : null)
        }
        get program() {
            var e;
            return (e = this._programErrorStack) === null || e === void 0 ? void 0 : e.stack[this._programErrorStack.stack.length - 1]
        }
        get programErrorStack() {
            var e;
            return (e = this._programErrorStack) === null || e === void 0 ? void 0 : e.stack
        }
        toString() {
            return this.msg
        }
    };

function xT(t, e) {
    TT("debug-logs") && console.log("Translating error:", t);
    let n = xw.parse(t.logs);
    if (n) return n;
    let r = Aw.parse(t, e);
    if (r) return r;
    if (t.logs) {
        let i = {
            get: function(s, o) {
                return o === "programErrorStack" ? s.programErrorStack.stack : o === "program" ? s.programErrorStack.stack[t.programErrorStack.stack.length - 1] : Reflect.get(...arguments)
            }
        };
        return t.programErrorStack = Kc.parse(t.logs), new Proxy(t, i)
    }
    return t
}
var K = {
        InstructionMissing: 100,
        InstructionFallbackNotFound: 101,
        InstructionDidNotDeserialize: 102,
        InstructionDidNotSerialize: 103,
        IdlInstructionStub: 1e3,
        IdlInstructionInvalidProgram: 1001,
        ConstraintMut: 2e3,
        ConstraintHasOne: 2001,
        ConstraintSigner: 2002,
        ConstraintRaw: 2003,
        ConstraintOwner: 2004,
        ConstraintRentExempt: 2005,
        ConstraintSeeds: 2006,
        ConstraintExecutable: 2007,
        ConstraintState: 2008,
        ConstraintAssociated: 2009,
        ConstraintAssociatedInit: 2010,
        ConstraintClose: 2011,
        ConstraintAddress: 2012,
        ConstraintZero: 2013,
        ConstraintTokenMint: 2014,
        ConstraintTokenOwner: 2015,
        ConstraintMintMintAuthority: 2016,
        ConstraintMintFreezeAuthority: 2017,
        ConstraintMintDecimals: 2018,
        ConstraintSpace: 2019,
        ConstraintAccountIsNone: 2020,
        RequireViolated: 2500,
        RequireEqViolated: 2501,
        RequireKeysEqViolated: 2502,
        RequireNeqViolated: 2503,
        RequireKeysNeqViolated: 2504,
        RequireGtViolated: 2505,
        RequireGteViolated: 2506,
        AccountDiscriminatorAlreadySet: 3e3,
        AccountDiscriminatorNotFound: 3001,
        AccountDiscriminatorMismatch: 3002,
        AccountDidNotDeserialize: 3003,
        AccountDidNotSerialize: 3004,
        AccountNotEnoughKeys: 3005,
        AccountNotMutable: 3006,
        AccountOwnedByWrongProgram: 3007,
        InvalidProgramId: 3008,
        InvalidProgramExecutable: 3009,
        AccountNotSigner: 3010,
        AccountNotSystemOwned: 3011,
        AccountNotInitialized: 3012,
        AccountNotProgramData: 3013,
        AccountNotAssociatedTokenAccount: 3014,
        AccountSysvarMismatch: 3015,
        AccountReallocExceedsLimit: 3016,
        AccountDuplicateReallocs: 3017,
        DeclaredProgramIdMismatch: 4100,
        Deprecated: 5e3
    },
    l$ = new Map([
        [K.InstructionMissing, "8 byte instruction identifier not provided"],
        [K.InstructionFallbackNotFound, "Fallback functions are not supported"],
        [K.InstructionDidNotDeserialize, "The program could not deserialize the given instruction"],
        [K.InstructionDidNotSerialize, "The program could not serialize the given instruction"],
        [K.IdlInstructionStub, "The program was compiled without idl instructions"],
        [K.IdlInstructionInvalidProgram, "The transaction was given an invalid program for the IDL instruction"],
        [K.ConstraintMut, "A mut constraint was violated"],
        [K.ConstraintHasOne, "A has one constraint was violated"],
        [K.ConstraintSigner, "A signer constraint was violated"],
        [K.ConstraintRaw, "A raw constraint was violated"],
        [K.ConstraintOwner, "An owner constraint was violated"],
        [K.ConstraintRentExempt, "A rent exemption constraint was violated"],
        [K.ConstraintSeeds, "A seeds constraint was violated"],
        [K.ConstraintExecutable, "An executable constraint was violated"],
        [K.ConstraintState, "Deprecated Error, feel free to replace with something else"],
        [K.ConstraintAssociated, "An associated constraint was violated"],
        [K.ConstraintAssociatedInit, "An associated init constraint was violated"],
        [K.ConstraintClose, "A close constraint was violated"],
        [K.ConstraintAddress, "An address constraint was violated"],
        [K.ConstraintZero, "Expected zero account discriminant"],
        [K.ConstraintTokenMint, "A token mint constraint was violated"],
        [K.ConstraintTokenOwner, "A token owner constraint was violated"],
        [K.ConstraintMintMintAuthority, "A mint mint authority constraint was violated"],
        [K.ConstraintMintFreezeAuthority, "A mint freeze authority constraint was violated"],
        [K.ConstraintMintDecimals, "A mint decimals constraint was violated"],
        [K.ConstraintSpace, "A space constraint was violated"],
        [K.ConstraintAccountIsNone, "A required account for the constraint is None"],
        [K.RequireViolated, "A require expression was violated"],
        [K.RequireEqViolated, "A require_eq expression was violated"],
        [K.RequireKeysEqViolated, "A require_keys_eq expression was violated"],
        [K.RequireNeqViolated, "A require_neq expression was violated"],
        [K.RequireKeysNeqViolated, "A require_keys_neq expression was violated"],
        [K.RequireGtViolated, "A require_gt expression was violated"],
        [K.RequireGteViolated, "A require_gte expression was violated"],
        [K.AccountDiscriminatorAlreadySet, "The account discriminator was already set on this account"],
        [K.AccountDiscriminatorNotFound, "No 8 byte discriminator was found on the account"],
        [K.AccountDiscriminatorMismatch, "8 byte discriminator did not match what was expected"],
        [K.AccountDidNotDeserialize, "Failed to deserialize the account"],
        [K.AccountDidNotSerialize, "Failed to serialize the account"],
        [K.AccountNotEnoughKeys, "Not enough account keys given to the instruction"],
        [K.AccountNotMutable, "The given account is not mutable"],
        [K.AccountOwnedByWrongProgram, "The given account is owned by a different program than expected"],
        [K.InvalidProgramId, "Program ID was not as expected"],
        [K.InvalidProgramExecutable, "Program account is not executable"],
        [K.AccountNotSigner, "The given account did not sign"],
        [K.AccountNotSystemOwned, "The given account is not owned by the system program"],
        [K.AccountNotInitialized, "The program expected this account to be already initialized"],
        [K.AccountNotProgramData, "The given account is not a program data account"],
        [K.AccountNotAssociatedTokenAccount, "The given account is not the associated token account"],
        [K.AccountSysvarMismatch, "The given public key does not match the required sysvar"],
        [K.AccountReallocExceedsLimit, "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"],
        [K.AccountDuplicateReallocs, "The account was duplicated for more than one reallocation"],
        [K.DeclaredProgramIdMismatch, "The declared program id does not match the actual program id"],
        [K.Deprecated, "The API being used is deprecated and should no longer be used"]
    ]),
    Nw = function() {
        return Nw = Object.assign || function(e) {
            for (var n, r = 1, i = arguments.length; r < i; r++) {
                n = arguments[r];
                for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
            }
            return e
        }, Nw.apply(this, arguments)
    },
    Rw = function() {
        return Rw = Object.assign || function(e) {
            for (var n, r = 1, i = arguments.length; r < i; r++) {
                n = arguments[r];
                for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
            }
            return e
        }, Rw.apply(this, arguments)
    };

function u$(t) {
    return t.toLowerCase()
}
var d$ = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g],
    h$ = /[^A-Z0-9]+/gi;

function f$(t, e) {
    e === void 0 && (e = {});
    for (var n = e.splitRegexp, r = n === void 0 ? d$ : n, i = e.stripRegexp, s = i === void 0 ? h$ : i, o = e.transform, a = o === void 0 ? u$ : o, c = e.delimiter, l = c === void 0 ? " " : c, u = vT(vT(t, r, "$1\0$2"), s, "\0"), d = 0, h = u.length; u.charAt(d) === "\0";) d++;
    for (; u.charAt(h - 1) === "\0";) h--;
    return u.slice(d, h).split("\0").map(a).join(l)
}

function vT(t, e, n) {
    return e instanceof RegExp ? t.replace(e, n) : e.reduce(function(r, i) {
        return r.replace(i, n)
    }, t)
}

function p$(t, e) {
    return e === void 0 && (e = {}), f$(t, Rw({
        delimiter: "."
    }, e))
}

function g$(t, e) {
    return e === void 0 && (e = {}), p$(t, Nw({
        delimiter: "_"
    }, e))
}
var Es = class t {
        static fieldLayout(e, n) {
            let r = e.name !== void 0 ? (0, Le.default)(e.name) : void 0;
            switch (e.type) {
                case "bool":
                    return z.bool(r);
                case "u8":
                    return z.u8(r);
                case "i8":
                    return z.i8(r);
                case "u16":
                    return z.u16(r);
                case "i16":
                    return z.i16(r);
                case "u32":
                    return z.u32(r);
                case "i32":
                    return z.i32(r);
                case "f32":
                    return z.f32(r);
                case "u64":
                    return z.u64(r);
                case "i64":
                    return z.i64(r);
                case "f64":
                    return z.f64(r);
                case "u128":
                    return z.u128(r);
                case "i128":
                    return z.i128(r);
                case "u256":
                    return z.u256(r);
                case "i256":
                    return z.i256(r);
                case "bytes":
                    return z.vecU8(r);
                case "string":
                    return z.str(r);
                case "publicKey":
                    return z.publicKey(r);
                default:
                    {
                        if ("vec" in e.type) return z.vec(t.fieldLayout({
                            name: void 0,
                            type: e.type.vec
                        }, n), r);
                        if ("option" in e.type) return z.option(t.fieldLayout({
                            name: void 0,
                            type: e.type.option
                        }, n), r);
                        if ("defined" in e.type) {
                            if (!n) throw new ea("User defined types not provided");
                            let i = e.type.defined,
                                s = n.filter(o => o.name === i);
                            if (s.length !== 1) throw new ea(`Type not found: ${JSON.stringify(e)}`);
                            return t.typeDefLayout(s[0], n, r)
                        } else if ("array" in e.type) {
                            let i = e.type.array[0],
                                s = e.type.array[1],
                                o = t.fieldLayout({
                                    name: void 0,
                                    type: i
                                }, n);
                            return z.array(o, s, r)
                        } else throw new Error(`Not yet implemented: ${e}`)
                    }
            }
        }
        static typeDefLayout(e, n = [], r) {
            switch (e.type.kind) {
                case "struct":
                    {
                        let i = e.type.fields.map(s => t.fieldLayout(s, n));
                        return z.struct(i, r)
                    }
                case "enum":
                    {
                        let i = e.type.variants.map(s => {
                            let o = (0, Le.default)(s.name);
                            if (!s.fields) return z.struct([], o);
                            let a = s.fields.map((c, l) => c ? .name ? t.fieldLayout(c, n) : t.fieldLayout({
                                type: c,
                                name: l.toString()
                            }, n));
                            return z.struct(a, o)
                        });
                        return r !== void 0 ? z.rustEnum(i).replicate(r) : z.rustEnum(i, r)
                    }
                case "alias":
                    return t.fieldLayout({
                        type: e.type.value,
                        name: e.name
                    }, n)
            }
        }
    },
    wT = "global",
    Ow = class t {
        constructor(e) {
            this.idl = e, this.ixLayout = t.parseIxLayout(e);
            let n = new Map;
            e.instructions.forEach(r => {
                let i = _T(wT, r.name);
                n.set(Jo.default.encode(i), {
                    layout: this.ixLayout.get(r.name),
                    name: r.name
                })
            }), this.sighashLayouts = n
        }
        encode(e, n) {
            return this._encode(wT, e, n)
        }
        _encode(e, n, r) {
            let i = Mn.Buffer.alloc(1e3),
                s = (0, Le.default)(n),
                o = this.ixLayout.get(s);
            if (!o) throw new Error(`Unknown method: ${s}`);
            let a = o.encode(r, i),
                c = i.slice(0, a);
            return Mn.Buffer.concat([_T(e, n), c])
        }
        static parseIxLayout(e) {
            let n = e.instructions.map(r => {
                let i = r.args.map(o => {
                        var a, c;
                        return Es.fieldLayout(o, Array.from([...(a = e.accounts) !== null && a !== void 0 ? a : [], ...(c = e.types) !== null && c !== void 0 ? c : []]))
                    }),
                    s = (0, Le.default)(r.name);
                return [s, z.struct(i, s)]
            });
            return new Map(n)
        }
        decode(e, n = "hex") {
            typeof e == "string" && (e = n === "hex" ? Mn.Buffer.from(e, "hex") : Jo.default.decode(e));
            let r = Jo.default.encode(e.slice(0, 8)),
                i = e.slice(8),
                s = this.sighashLayouts.get(r);
            return s ? {
                data: s.layout.decode(i),
                name: s.name
            } : null
        }
        format(e, n) {
            return Fw.format(e, n, this.idl)
        }
    },
    Fw = class t {
        static format(e, n, r) {
            let i = r.instructions.filter(c => e.name === c.name)[0];
            if (i === void 0) return console.error("Invalid instruction given"), null;
            let s = i.args.map(c => ({
                    name: c.name,
                    type: t.formatIdlType(c.type),
                    data: t.formatIdlData(c, e.data[c.name], r.types)
                })),
                o = t.flattenIdlAccounts(i.accounts),
                a = n.map((c, l) => l < o.length ? _({
                    name: o[l].name
                }, c) : _({
                    name: void 0
                }, c));
            return {
                args: s,
                accounts: a
            }
        }
        static formatIdlType(e) {
            if (typeof e == "string") return e;
            if ("vec" in e) return `Vec<${this.formatIdlType(e.vec)}>`;
            if ("option" in e) return `Option<${this.formatIdlType(e.option)}>`;
            if ("defined" in e) return e.defined;
            if ("array" in e) return `Array<${e.array[0]}; ${e.array[1]}>`;
            throw new Error(`Unknown IDL type: ${e}`)
        }
        static formatIdlData(e, n, r) {
            if (typeof e.type == "string") return n.toString();
            if (e.type.hasOwnProperty("vec")) return "[" + n.map(i => this.formatIdlData({
                name: "",
                type: e.type.vec
            }, i)).join(", ") + "]";
            if (e.type.hasOwnProperty("option")) return n === null ? "null" : this.formatIdlData({
                name: "",
                type: e.type.option
            }, n, r);
            if (e.type.hasOwnProperty("defined")) {
                if (r === void 0) throw new Error("User defined types not provided");
                let i = r.filter(s => s.name === e.type.defined);
                if (i.length !== 1) throw new Error(`Type not found: ${e.type.defined}`);
                return t.formatIdlDataDefined(i[0], n, r)
            }
            return "unknown"
        }
        static formatIdlDataDefined(e, n, r) {
            switch (e.type.kind) {
                case "struct":
                    {
                        let i = e.type;
                        return "{ " + Object.keys(n).map(o => {
                            let a = i.fields.find(c => c.name === o);
                            if (!a) throw new Error("Unable to find type");
                            return o + ": " + t.formatIdlData(a, n[o], r)
                        }).join(", ") + " }"
                    }
                case "enum":
                    {
                        if (e.type.variants.length === 0) return "{}";
                        if (e.type.variants[0].name) {
                            let i = e.type.variants,
                                s = Object.keys(n)[0],
                                o = n[s],
                                a = Object.keys(o).map(l => {
                                    var u;
                                    let d = o[l],
                                        h = (u = i[s]) === null || u === void 0 ? void 0 : u.find(f => f.name === l);
                                    if (!h) throw new Error("Unable to find variant");
                                    return l + ": " + t.formatIdlData(h, d, r)
                                }).join(", "),
                                c = (0, Le.default)(s, {
                                    pascalCase: !0
                                });
                            return a.length === 0 ? c : `${c} { ${a} }`
                        } else return "Tuple formatting not yet implemented"
                    }
                case "alias":
                    return t.formatIdlType(e.type.value)
            }
        }
        static flattenIdlAccounts(e, n) {
            return e.map(r => {
                let i = m$(r.name);
                if (r.hasOwnProperty("accounts")) {
                    let s = n ? `${n} > ${i}` : i;
                    return t.flattenIdlAccounts(r.accounts, s)
                } else return Q(_({}, r), {
                    name: n ? `${n} > ${i}` : i
                })
            }).flat()
        }
    };

function m$(t) {
    let e = t.replace(/([A-Z])/g, " $1");
    return e.charAt(0).toUpperCase() + e.slice(1)
}

function _T(t, e) {
    let n = g$(e),
        r = `${t}:${n}`;
    return Mn.Buffer.from(Gf(r).slice(0, 8))
}

function AT(t, e) {
    switch (e.type.kind) {
        case "struct":
            return e.type.fields.map(n => Ds(t, n.type)).reduce((n, r) => n + r, 0);
        case "enum":
            {
                let n = e.type.variants.map(r => r.fields ? r.fields.map(i => typeof i == "object" && "name" in i ? Ds(t, i.type) : Ds(t, i)).reduce((i, s) => i + s, 0) : 0);
                return Math.max(...n) + 1
            }
        case "alias":
            return Ds(t, e.type.value)
    }
}

function Ds(t, e) {
    var n, r;
    switch (e) {
        case "bool":
            return 1;
        case "u8":
            return 1;
        case "i8":
            return 1;
        case "i16":
            return 2;
        case "u16":
            return 2;
        case "u32":
            return 4;
        case "i32":
            return 4;
        case "f32":
            return 4;
        case "u64":
            return 8;
        case "i64":
            return 8;
        case "f64":
            return 8;
        case "u128":
            return 16;
        case "i128":
            return 16;
        case "u256":
            return 32;
        case "i256":
            return 32;
        case "bytes":
            return 1;
        case "string":
            return 1;
        case "publicKey":
            return 32;
        default:
            if ("vec" in e) return 1;
            if ("option" in e) return 1 + Ds(t, e.option);
            if ("coption" in e) return 4 + Ds(t, e.coption);
            if ("defined" in e) {
                let i = (r = (n = t.types) === null || n === void 0 ? void 0 : n.filter(o => o.name === e.defined)) !== null && r !== void 0 ? r : [];
                if (i.length !== 1) throw new ea(`Type not found: ${JSON.stringify(e)}`);
                let s = i[0];
                return AT(t, s)
            }
            if ("array" in e) {
                let i = e.array[0],
                    s = e.array[1];
                return Ds(t, i) * s
            }
            throw new Error(`Invalid type ${JSON.stringify(e)}`)
    }
}
var kw = 8;

function NT(t) {
    return Buffer.from(Gf(t).slice(0, kw))
}
var Pw = class t {
        constructor(e) {
            if (e.accounts === void 0) {
                this.accountLayouts = new Map;
                return
            }
            let n = e.accounts.map(r => [r.name, Es.typeDefLayout(r, e.types)]);
            this.accountLayouts = new Map(n), this.idl = e
        }
        encode(e, n) {
            return x(this, null, function*() {
                let r = Mn.Buffer.alloc(1e3),
                    i = this.accountLayouts.get(e);
                if (!i) throw new Error(`Unknown account: ${e}`);
                let s = i.encode(n, r),
                    o = r.slice(0, s),
                    a = t.accountDiscriminator(e);
                return Mn.Buffer.concat([a, o])
            })
        }
        decode(e, n) {
            if (t.accountDiscriminator(e).compare(n.slice(0, 8))) throw new Error("Invalid account discriminator");
            return this.decodeUnchecked(e, n)
        }
        decodeAny(e) {
            let n = e.slice(0, 8),
                r = Array.from(this.accountLayouts.keys()).find(i => t.accountDiscriminator(i).equals(n));
            if (!r) throw new Error("Account descriminator not found");
            return this.decodeUnchecked(r, e)
        }
        decodeUnchecked(e, n) {
            let r = n.subarray(kw),
                i = this.accountLayouts.get(e);
            if (!i) throw new Error(`Unknown account: ${e}`);
            return i.decode(r)
        }
        memcmp(e, n) {
            let r = t.accountDiscriminator(e);
            return {
                offset: 0,
                bytes: Jo.default.encode(n ? Mn.Buffer.concat([r, n]) : r)
            }
        }
        size(e) {
            var n;
            return kw + ((n = AT(this.idl, e)) !== null && n !== void 0 ? n : 0)
        }
        static accountDiscriminator(e) {
            let n = `account:${(0,Le.default)(e,{pascalCase:!0,preserveConsecutiveUppercase:!0})}`;
            return NT(n)
        }
    },
    Lw = class {
        constructor(e) {
            if (e.events === void 0) {
                this.layouts = new Map;
                return
            }
            let n = e.events.map(r => {
                let i = {
                    name: r.name,
                    type: {
                        kind: "struct",
                        fields: r.fields.map(s => ({
                            name: s.name,
                            type: s.type
                        }))
                    }
                };
                return [r.name, Es.typeDefLayout(i, e.types)]
            });
            this.layouts = new Map(n), this.discriminators = new Map(e.events === void 0 ? [] : e.events.map(r => [dT(y$(r.name)), r.name]))
        }
        decode(e) {
            let n;
            try {
                n = ET(e)
            } catch {
                return null
            }
            let r = dT(n.slice(0, 8)),
                i = this.discriminators.get(r);
            if (i === void 0) return null;
            let s = this.layouts.get(i);
            if (!s) throw new Error(`Unknown event: ${i}`);
            return {
                data: s.decode(n.slice(8)),
                name: i
            }
        }
    };

function y$(t) {
    return NT(`event:${t}`)
}
var Vw = class {
        constructor(e) {
            if (e.types === void 0) {
                this.typeLayouts = new Map;
                return
            }
            let n = e.types.map(r => [r.name, Es.typeDefLayout(r, e.types)]);
            this.typeLayouts = new Map(n), this.idl = e
        }
        encode(e, n) {
            let r = Mn.Buffer.alloc(1e3),
                i = this.typeLayouts.get(e);
            if (!i) throw new Error(`Unknown type: ${e}`);
            let s = i.encode(n, r);
            return r.slice(0, s)
        }
        decode(e, n) {
            let r = this.typeLayouts.get(e);
            if (!r) throw new Error(`Unknown type: ${e}`);
            return r.decode(n)
        }
    },
    Jh = class {
        constructor(e) {
            this.instruction = new Ow(e), this.accounts = new Pw(e), this.events = new Lw(e), this.types = new Vw(e)
        }
    },
    v$ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function w$(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var Nt = class {
        constructor(e, n) {
            if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
            this.span = e, this.property = n
        }
        makeDestinationObject() {
            return {}
        }
        decode(e, n) {
            throw new Error("Layout is abstract")
        }
        encode(e, n, r) {
            throw new Error("Layout is abstract")
        }
        getSpan(e, n) {
            if (0 > this.span) throw new RangeError("indeterminate span");
            return this.span
        }
        replicate(e) {
            let n = Object.create(this.constructor.prototype);
            return Object.assign(n, this), n.property = e, n
        }
        fromArray(e) {}
    },
    lf = Nt;

function _$(t, e) {
    return e.property ? t + "[" + e.property + "]" : t
}
var Br = class extends Nt {
        isCount() {
            throw new Error("ExternalLayout is abstract")
        }
    },
    Xh = class extends Br {
        constructor(e, n, r) {
            if (!(e instanceof Nt)) throw new TypeError("layout must be a Layout");
            if (n === void 0) n = 0;
            else if (!Number.isInteger(n)) throw new TypeError("offset must be integer or undefined");
            super(e.span, r || e.property), this.layout = e, this.offset = n
        }
        isCount() {
            return this.layout instanceof ta || this.layout instanceof ef
        }
        decode(e, n) {
            return n === void 0 && (n = 0), this.layout.decode(e, n + this.offset)
        }
        encode(e, n, r) {
            return r === void 0 && (r = 0), this.layout.encode(e, n, r + this.offset)
        }
    },
    ta = class extends Nt {
        constructor(e, n) {
            if (super(e, n), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
        }
        decode(e, n) {
            return n === void 0 && (n = 0), e.readUIntLE(n, this.span)
        }
        encode(e, n, r) {
            return r === void 0 && (r = 0), n.writeUIntLE(e, r, this.span), this.span
        }
    },
    ef = class extends Nt {
        constructor(e, n) {
            if (super(e, n), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
        }
        decode(e, n) {
            return n === void 0 && (n = 0), e.readUIntBE(n, this.span)
        }
        encode(e, n, r) {
            return r === void 0 && (r = 0), n.writeUIntBE(e, r, this.span), this.span
        }
    },
    Uw = Math.pow(2, 32);

function RT(t) {
    let e = Math.floor(t / Uw),
        n = t - e * Uw;
    return {
        hi32: e,
        lo32: n
    }
}

function OT(t, e) {
    return t * Uw + e
}
var jw = class extends Nt {
        constructor(e) {
            super(8, e)
        }
        decode(e, n) {
            n === void 0 && (n = 0);
            let r = e.readUInt32LE(n),
                i = e.readUInt32LE(n + 4);
            return OT(i, r)
        }
        encode(e, n, r) {
            r === void 0 && (r = 0);
            let i = RT(e);
            return n.writeUInt32LE(i.lo32, r), n.writeUInt32LE(i.hi32, r + 4), 8
        }
    },
    Bw = class extends Nt {
        constructor(e) {
            super(8, e)
        }
        decode(e, n) {
            n === void 0 && (n = 0);
            let r = e.readUInt32LE(n),
                i = e.readInt32LE(n + 4);
            return OT(i, r)
        }
        encode(e, n, r) {
            r === void 0 && (r = 0);
            let i = RT(e);
            return n.writeUInt32LE(i.lo32, r), n.writeInt32LE(i.hi32, r + 4), 8
        }
    },
    zw = class extends Nt {
        constructor(e, n, r) {
            if (!(Array.isArray(e) && e.reduce((s, o) => s && o instanceof Nt, !0))) throw new TypeError("fields must be array of Layout instances");
            typeof n == "boolean" && r === void 0 && (r = n, n = void 0);
            for (let s of e)
                if (0 > s.span && s.property === void 0) throw new Error("fields cannot contain unnamed variable-length layout");
            let i = -1;
            try {
                i = e.reduce((s, o) => s + o.getSpan(), 0)
            } catch {}
            super(i, n), this.fields = e, this.decodePrefixes = !!r
        }
        getSpan(e, n) {
            if (0 <= this.span) return this.span;
            n === void 0 && (n = 0);
            let r = 0;
            try {
                r = this.fields.reduce((i, s) => {
                    let o = s.getSpan(e, n);
                    return n += o, i + o
                }, 0)
            } catch {
                throw new RangeError("indeterminate span")
            }
            return r
        }
        decode(e, n) {
            n === void 0 && (n = 0);
            let r = this.makeDestinationObject();
            for (let i of this.fields)
                if (i.property !== void 0 && (r[i.property] = i.decode(e, n)), n += i.getSpan(e, n), this.decodePrefixes && e.length === n) break;
            return r
        }
        encode(e, n, r) {
            r === void 0 && (r = 0);
            let i = r,
                s = 0,
                o = 0;
            for (let a of this.fields) {
                let c = a.span;
                if (o = 0 < c ? c : 0, a.property !== void 0) {
                    let l = e[a.property];
                    l !== void 0 && (o = a.encode(l, n, r), 0 > c && (c = a.getSpan(n, r)))
                }
                s = r, r += c
            }
            return s + o - i
        }
        fromArray(e) {
            let n = this.makeDestinationObject();
            for (let r of this.fields) r.property !== void 0 && 0 < e.length && (n[r.property] = e.shift());
            return n
        }
        layoutFor(e) {
            if (typeof e != "string") throw new TypeError("property must be string");
            for (let n of this.fields)
                if (n.property === e) return n
        }
        offsetOf(e) {
            if (typeof e != "string") throw new TypeError("property must be string");
            let n = 0;
            for (let r of this.fields) {
                if (r.property === e) return n;
                0 > r.span ? n = -1 : 0 <= n && (n += r.span)
            }
        }
    },
    tf = class {
        constructor(e) {
            this.property = e
        }
        decode() {
            throw new Error("UnionDiscriminator is abstract")
        }
        encode() {
            throw new Error("UnionDiscriminator is abstract")
        }
    },
    nf = class extends tf {
        constructor(e, n) {
            if (!(e instanceof Br && e.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
            super(n || e.property || "variant"), this.layout = e
        }
        decode(e, n) {
            return this.layout.decode(e, n)
        }
        encode(e, n, r) {
            return this.layout.encode(e, n, r)
        }
    },
    rf = class extends Nt {
        constructor(e, n, r) {
            let i = e instanceof ta || e instanceof ef;
            if (i) e = new nf(new Xh(e));
            else if (e instanceof Br && e.isCount()) e = new nf(e);
            else if (!(e instanceof tf)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
            if (n === void 0 && (n = null), !(n === null || n instanceof Nt)) throw new TypeError("defaultLayout must be null or a Layout");
            if (n !== null) {
                if (0 > n.span) throw new Error("defaultLayout must have constant span");
                n.property === void 0 && (n = n.replicate("content"))
            }
            let s = -1;
            n && (s = n.span, 0 <= s && i && (s += e.layout.span)), super(s, r), this.discriminator = e, this.usesPrefixDiscriminator = i, this.defaultLayout = n, this.registry = {};
            let o = this.defaultGetSourceVariant.bind(this);
            this.getSourceVariant = function(a) {
                return o(a)
            }, this.configGetSourceVariant = function(a) {
                o = a.bind(this)
            }
        }
        getSpan(e, n) {
            if (0 <= this.span) return this.span;
            n === void 0 && (n = 0);
            let r = this.getVariant(e, n);
            if (!r) throw new Error("unable to determine span for unrecognized variant");
            return r.getSpan(e, n)
        }
        defaultGetSourceVariant(e) {
            if (e.hasOwnProperty(this.discriminator.property)) {
                if (this.defaultLayout && e.hasOwnProperty(this.defaultLayout.property)) return;
                let n = this.registry[e[this.discriminator.property]];
                if (n && (!n.layout || e.hasOwnProperty(n.property))) return n
            } else
                for (let n in this.registry) {
                    let r = this.registry[n];
                    if (e.hasOwnProperty(r.property)) return r
                }
            throw new Error("unable to infer src variant")
        }
        decode(e, n) {
            n === void 0 && (n = 0);
            let r, i = this.discriminator,
                s = i.decode(e, n),
                o = this.registry[s];
            if (o === void 0) {
                let a = 0;
                o = this.defaultLayout, this.usesPrefixDiscriminator && (a = i.layout.span), r = this.makeDestinationObject(), r[i.property] = s, r[o.property] = this.defaultLayout.decode(e, n + a)
            } else r = o.decode(e, n);
            return r
        }
        encode(e, n, r) {
            r === void 0 && (r = 0);
            let i = this.getSourceVariant(e);
            if (i === void 0) {
                let s = this.discriminator,
                    o = this.defaultLayout,
                    a = 0;
                return this.usesPrefixDiscriminator && (a = s.layout.span), s.encode(e[s.property], n, r), a + o.encode(e[o.property], n, r + a)
            }
            return i.encode(e, n, r)
        }
        addVariant(e, n, r) {
            let i = new $w(this, e, n, r);
            return this.registry[e] = i, i
        }
        getVariant(e, n) {
            let r = e;
            return Buffer.isBuffer(e) && (n === void 0 && (n = 0), r = this.discriminator.decode(e, n)), this.registry[r]
        }
    },
    $w = class extends Nt {
        constructor(e, n, r, i) {
            if (!(e instanceof rf)) throw new TypeError("union must be a Union");
            if (!Number.isInteger(n) || 0 > n) throw new TypeError("variant must be a (non-negative) integer");
            if (typeof r == "string" && i === void 0 && (i = r, r = null), r) {
                if (!(r instanceof Nt)) throw new TypeError("layout must be a Layout");
                if (e.defaultLayout !== null && 0 <= r.span && r.span > e.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                if (typeof i != "string") throw new TypeError("variant must have a String property")
            }
            let s = e.span;
            0 > e.span && (s = r ? r.span : 0, 0 <= s && e.usesPrefixDiscriminator && (s += e.discriminator.layout.span)), super(s, i), this.union = e, this.variant = n, this.layout = r || null
        }
        getSpan(e, n) {
            if (0 <= this.span) return this.span;
            n === void 0 && (n = 0);
            let r = 0;
            return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), r + this.layout.getSpan(e, n + r)
        }
        decode(e, n) {
            let r = this.makeDestinationObject();
            if (n === void 0 && (n = 0), this !== this.union.getVariant(e, n)) throw new Error("variant mismatch");
            let i = 0;
            return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout ? r[this.property] = this.layout.decode(e, n + i) : this.property ? r[this.property] = !0 : this.union.usesPrefixDiscriminator && (r[this.union.discriminator.property] = this.variant), r
        }
        encode(e, n, r) {
            r === void 0 && (r = 0);
            let i = 0;
            if (this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout && !e.hasOwnProperty(this.property)) throw new TypeError("variant lacks property " + this.property);
            this.union.discriminator.encode(this.variant, n, r);
            let s = i;
            if (this.layout && (this.layout.encode(e[this.property], n, r + i), s += this.layout.getSpan(n, r + i), 0 <= this.union.span && s > this.union.span)) throw new Error("encoded variant overruns containing union");
            return s
        }
        fromArray(e) {
            if (this.layout) return this.layout.fromArray(e)
        }
    },
    Ww = class extends Nt {
        constructor(e, n) {
            if (!(e instanceof Br && e.isCount() || Number.isInteger(e) && 0 <= e)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
            let r = -1;
            e instanceof Br || (r = e), super(r, n), this.length = e
        }
        getSpan(e, n) {
            let r = this.span;
            return 0 > r && (r = this.length.decode(e, n)), r
        }
        decode(e, n) {
            n === void 0 && (n = 0);
            let r = this.span;
            return 0 > r && (r = this.length.decode(e, n)), e.slice(n, n + r)
        }
        encode(e, n, r) {
            let i = this.length;
            if (this.length instanceof Br && (i = e.length), !(Buffer.isBuffer(e) && i === e.length)) throw new TypeError(_$("Blob.encode", this) + " requires (length " + i + ") Buffer as src");
            if (r + i > n.length) throw new RangeError("encoding overruns Buffer");
            return n.write(e.toString("hex"), r, i, "hex"), this.length instanceof Br && this.length.encode(i, n, r), i
        }
    },
    b$ = (t, e, n) => new Xh(t, e, n),
    D$ = t => new ta(1, t),
    jr = t => new ta(4, t),
    E$ = t => new jw(t),
    zr = t => new Bw(t),
    ot = (t, e, n) => new zw(t, e, n),
    FT = (t, e, n) => new rf(t, e, n),
    Xc = (t, e) => new Ww(t, e);
var Hw = class extends lf {
    constructor(e) {
        super(-1, e), this.property = e, this.layout = ot([jr("length"), jr("lengthPadding"), Xc(b$(jr(), -8), "chars")], this.property)
    }
    encode(e, n, r = 0) {
        if (e == null) return this.layout.span;
        let i = {
            chars: Buffer.from(e, "utf8")
        };
        return this.layout.encode(i, n, r)
    }
    decode(e, n = 0) {
        return this.layout.decode(e, n).chars.toString()
    }
    getSpan(e, n = 0) {
        return jr().span + jr().span + new d0.default(new Uint8Array(e).slice(n, n + 4), 10, "le").toNumber()
    }
};

function uf(t) {
    return new Hw(t)
}

function In(t) {
    return Xc(32, t)
}
var cn = FT(jr("instruction"));
cn.addVariant(0, ot([zr("lamports"), zr("space"), In("owner")]), "createAccount");
cn.addVariant(1, ot([In("owner")]), "assign");
cn.addVariant(2, ot([zr("lamports")]), "transfer");
cn.addVariant(3, ot([In("base"), uf("seed"), zr("lamports"), zr("space"), In("owner")]), "createAccountWithSeed");
cn.addVariant(4, ot([In("authorized")]), "advanceNonceAccount");
cn.addVariant(5, ot([zr("lamports")]), "withdrawNonceAccount");
cn.addVariant(6, ot([In("authorized")]), "initializeNonceAccount");
cn.addVariant(7, ot([In("authorized")]), "authorizeNonceAccount");
cn.addVariant(8, ot([zr("space")]), "allocate");
cn.addVariant(9, ot([In("base"), uf("seed"), zr("space"), In("owner")]), "allocateWithSeed");
cn.addVariant(10, ot([In("base"), uf("seed"), In("owner")]), "assignWithSeed");
cn.addVariant(11, ot([zr("lamports"), uf("seed"), In("owner")]), "transferWithSeed");
var yY = Math.max(...Object.values(cn.registry).map(t => t.span));
var Gw = class extends lf {
    constructor(e, n, r, i) {
        super(e.span, i), this.layout = e, this.decoder = n, this.encoder = r
    }
    decode(e, n) {
        return this.decoder(this.layout.decode(e, n))
    }
    encode(e, n, r) {
        return this.layout.encode(this.encoder(e), n, r)
    }
    getSpan(e, n) {
        return this.layout.getSpan(e, n)
    }
};

function bT(t) {
    return new Gw(Xc(32), e => new me(e), e => e.toBuffer(), t)
}
var vY = ot([jr("version"), jr("state"), bT("authorizedPubkey"), bT("nonce"), ot([E$("lamportsPerSignature")], "feeCalculator")]);

function C$(t, ...e) {
    let n = [Mn.Buffer.from([97, 110, 99, 104, 111, 114])];
    e.forEach(i => {
        n.push(i instanceof Mn.Buffer ? i : Sn(i).toBuffer())
    });
    let [r] = me.findProgramAddressSync(n, Sn(t));
    return r
}
var S$ = new me("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
    M$ = new me("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var Zw = {
    exports: {}
};
(function(t, e) {
    var n = typeof self < "u" ? self : v$,
        r = function() {
            function s() {
                this.fetch = !1, this.DOMException = n.DOMException
            }
            return s.prototype = n, new s
        }();
    (function(s) {
        (function(o) {
            var a = {
                searchParams: "URLSearchParams" in s,
                iterable: "Symbol" in s && "iterator" in Symbol,
                blob: "FileReader" in s && "Blob" in s && function() {
                    try {
                        return new Blob, !0
                    } catch {
                        return !1
                    }
                }(),
                formData: "FormData" in s,
                arrayBuffer: "ArrayBuffer" in s
            };

            function c(v) {
                return v && DataView.prototype.isPrototypeOf(v)
            }
            if (a.arrayBuffer) var l = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                u = ArrayBuffer.isView || function(v) {
                    return v && l.indexOf(Object.prototype.toString.call(v)) > -1
                };

            function d(v) {
                if (typeof v != "string" && (v = String(v)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(v)) throw new TypeError("Invalid character in header field name");
                return v.toLowerCase()
            }

            function h(v) {
                return typeof v != "string" && (v = String(v)), v
            }

            function f(v) {
                var A = {
                    next: function() {
                        var b = v.shift();
                        return {
                            done: b === void 0,
                            value: b
                        }
                    }
                };
                return a.iterable && (A[Symbol.iterator] = function() {
                    return A
                }), A
            }

            function p(v) {
                this.map = {}, v instanceof p ? v.forEach(function(A, b) {
                    this.append(b, A)
                }, this) : Array.isArray(v) ? v.forEach(function(A) {
                    this.append(A[0], A[1])
                }, this) : v && Object.getOwnPropertyNames(v).forEach(function(A) {
                    this.append(A, v[A])
                }, this)
            }
            p.prototype.append = function(v, A) {
                v = d(v), A = h(A);
                var b = this.map[v];
                this.map[v] = b ? b + ", " + A : A
            }, p.prototype.delete = function(v) {
                delete this.map[d(v)]
            }, p.prototype.get = function(v) {
                return v = d(v), this.has(v) ? this.map[v] : null
            }, p.prototype.has = function(v) {
                return this.map.hasOwnProperty(d(v))
            }, p.prototype.set = function(v, A) {
                this.map[d(v)] = h(A)
            }, p.prototype.forEach = function(v, A) {
                for (var b in this.map) this.map.hasOwnProperty(b) && v.call(A, this.map[b], b, this)
            }, p.prototype.keys = function() {
                var v = [];
                return this.forEach(function(A, b) {
                    v.push(b)
                }), f(v)
            }, p.prototype.values = function() {
                var v = [];
                return this.forEach(function(A) {
                    v.push(A)
                }), f(v)
            }, p.prototype.entries = function() {
                var v = [];
                return this.forEach(function(A, b) {
                    v.push([b, A])
                }), f(v)
            }, a.iterable && (p.prototype[Symbol.iterator] = p.prototype.entries);

            function g(v) {
                if (v.bodyUsed) return Promise.reject(new TypeError("Already read"));
                v.bodyUsed = !0
            }

            function m(v) {
                return new Promise(function(A, b) {
                    v.onload = function() {
                        A(v.result)
                    }, v.onerror = function() {
                        b(v.error)
                    }
                })
            }

            function y(v) {
                var A = new FileReader,
                    b = m(A);
                return A.readAsArrayBuffer(v), b
            }

            function E(v) {
                var A = new FileReader,
                    b = m(A);
                return A.readAsText(v), b
            }

            function T(v) {
                for (var A = new Uint8Array(v), b = new Array(A.length), F = 0; F < A.length; F++) b[F] = String.fromCharCode(A[F]);
                return b.join("")
            }

            function w(v) {
                if (v.slice) return v.slice(0);
                var A = new Uint8Array(v.byteLength);
                return A.set(new Uint8Array(v)), A.buffer
            }

            function N() {
                return this.bodyUsed = !1, this._initBody = function(v) {
                    this._bodyInit = v, v ? typeof v == "string" ? this._bodyText = v : a.blob && Blob.prototype.isPrototypeOf(v) ? this._bodyBlob = v : a.formData && FormData.prototype.isPrototypeOf(v) ? this._bodyFormData = v : a.searchParams && URLSearchParams.prototype.isPrototypeOf(v) ? this._bodyText = v.toString() : a.arrayBuffer && a.blob && c(v) ? (this._bodyArrayBuffer = w(v.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(v) || u(v)) ? this._bodyArrayBuffer = w(v) : this._bodyText = v = Object.prototype.toString.call(v) : this._bodyText = "", this.headers.get("content-type") || (typeof v == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(v) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                }, a.blob && (this.blob = function() {
                    var v = g(this);
                    if (v) return v;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]))
                }, this.arrayBuffer = function() {
                    return this._bodyArrayBuffer ? g(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(y)
                }), this.text = function() {
                    var v = g(this);
                    if (v) return v;
                    if (this._bodyBlob) return E(this._bodyBlob);
                    if (this._bodyArrayBuffer) return Promise.resolve(T(this._bodyArrayBuffer));
                    if (this._bodyFormData) throw new Error("could not read FormData body as text");
                    return Promise.resolve(this._bodyText)
                }, a.formData && (this.formData = function() {
                    return this.text().then(Y)
                }), this.json = function() {
                    return this.text().then(JSON.parse)
                }, this
            }
            var L = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

            function D(v) {
                var A = v.toUpperCase();
                return L.indexOf(A) > -1 ? A : v
            }

            function j(v, A) {
                A = A || {};
                var b = A.body;
                if (v instanceof j) {
                    if (v.bodyUsed) throw new TypeError("Already read");
                    this.url = v.url, this.credentials = v.credentials, A.headers || (this.headers = new p(v.headers)), this.method = v.method, this.mode = v.mode, this.signal = v.signal, !b && v._bodyInit != null && (b = v._bodyInit, v.bodyUsed = !0)
                } else this.url = String(v);
                if (this.credentials = A.credentials || this.credentials || "same-origin", (A.headers || !this.headers) && (this.headers = new p(A.headers)), this.method = D(A.method || this.method || "GET"), this.mode = A.mode || this.mode || null, this.signal = A.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && b) throw new TypeError("Body not allowed for GET or HEAD requests");
                this._initBody(b)
            }
            j.prototype.clone = function() {
                return new j(this, {
                    body: this._bodyInit
                })
            };

            function Y(v) {
                var A = new FormData;
                return v.trim().split("&").forEach(function(b) {
                    if (b) {
                        var F = b.split("="),
                            V = F.shift().replace(/\+/g, " "),
                            $ = F.join("=").replace(/\+/g, " ");
                        A.append(decodeURIComponent(V), decodeURIComponent($))
                    }
                }), A
            }

            function H(v) {
                var A = new p,
                    b = v.replace(/\r?\n[\t ]+/g, " ");
                return b.split(/\r?\n/).forEach(function(F) {
                    var V = F.split(":"),
                        $ = V.shift().trim();
                    if ($) {
                        var $e = V.join(":").trim();
                        A.append($, $e)
                    }
                }), A
            }
            N.call(j.prototype);

            function G(v, A) {
                A || (A = {}), this.type = "default", this.status = A.status === void 0 ? 200 : A.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in A ? A.statusText : "OK", this.headers = new p(A.headers), this.url = A.url || "", this._initBody(v)
            }
            N.call(G.prototype), G.prototype.clone = function() {
                return new G(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new p(this.headers),
                    url: this.url
                })
            }, G.error = function() {
                var v = new G(null, {
                    status: 0,
                    statusText: ""
                });
                return v.type = "error", v
            };
            var Ue = [301, 302, 303, 307, 308];
            G.redirect = function(v, A) {
                if (Ue.indexOf(A) === -1) throw new RangeError("Invalid status code");
                return new G(null, {
                    status: A,
                    headers: {
                        location: v
                    }
                })
            }, o.DOMException = s.DOMException;
            try {
                new o.DOMException
            } catch {
                o.DOMException = function(A, b) {
                    this.message = A, this.name = b;
                    var F = Error(A);
                    this.stack = F.stack
                }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException
            }

            function qt(v, A) {
                return new Promise(function(b, F) {
                    var V = new j(v, A);
                    if (V.signal && V.signal.aborted) return F(new o.DOMException("Aborted", "AbortError"));
                    var $ = new XMLHttpRequest;

                    function $e() {
                        $.abort()
                    }
                    $.onload = function() {
                        var St = {
                            status: $.status,
                            statusText: $.statusText,
                            headers: H($.getAllResponseHeaders() || "")
                        };
                        St.url = "responseURL" in $ ? $.responseURL : St.headers.get("X-Request-URL");
                        var pt = "response" in $ ? $.response : $.responseText;
                        b(new G(pt, St))
                    }, $.onerror = function() {
                        F(new TypeError("Network request failed"))
                    }, $.ontimeout = function() {
                        F(new TypeError("Network request failed"))
                    }, $.onabort = function() {
                        F(new o.DOMException("Aborted", "AbortError"))
                    }, $.open(V.method, V.url, !0), V.credentials === "include" ? $.withCredentials = !0 : V.credentials === "omit" && ($.withCredentials = !1), "responseType" in $ && a.blob && ($.responseType = "blob"), V.headers.forEach(function(St, pt) {
                        $.setRequestHeader(pt, St)
                    }), V.signal && (V.signal.addEventListener("abort", $e), $.onreadystatechange = function() {
                        $.readyState === 4 && V.signal.removeEventListener("abort", $e)
                    }), $.send(typeof V._bodyInit > "u" ? null : V._bodyInit)
                })
            }
            return qt.polyfill = !0, s.fetch || (s.fetch = qt, s.Headers = p, s.Request = j, s.Response = G), o.Headers = p, o.Request = j, o.Response = G, o.fetch = qt, Object.defineProperty(o, "__esModule", {
                value: !0
            }), o
        })({})
    })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
    var i = r;
    e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, t.exports = e
})(Zw, Zw.exports);
var wY = w$(Zw.exports);
var _Y = z.rustEnum([z.struct([], "uninitialized"), z.struct([z.option(z.publicKey(), "authorityAddress")], "buffer"), z.struct([z.publicKey("programdataAddress")], "program"), z.struct([z.u64("slot"), z.option(z.publicKey(), "upgradeAuthorityAddress")], "programData")], void 0, z.u32());

function I$(t) {
    return "accounts" in t
}

function T$(t) {
    return x(this, null, function*() {
        let e = (yield me.findProgramAddress([], t))[0];
        return yield me.createWithSeed(e, x$(), t)
    })
}

function x$() {
    return "anchor:idl"
}
var A$ = z.struct([z.publicKey("authority"), z.vecU8("data")]);

function N$(t) {
    return A$.decode(t)
}

function df(t, e) {
    var n, r;
    let i = {},
        s = t.args ? t.args.length : 0;
    if (e.length > s) {
        if (e.length !== s + 1) throw new Error(`provided too many arguments ${e} to instruction ${t?.name} expecting: ${(r=(n=t.args)===null||n===void 0?void 0:n.map(o=>o.name))!==null&&r!==void 0?r:[]}`);
        i = e.pop()
    }
    return [e, i]
}
var Qw = class t {
    static build(e, n, r) {
        if (e.name === "_inner") throw new ea("the _inner name is reserved");
        let i = (...s) => {
            let [o, a] = df(e, [...s]);
            CT(e.accounts, a.accounts), R$(e, ...s);
            let c = i.accounts(a.accounts);
            return a.remainingAccounts !== void 0 && c.push(...a.remainingAccounts), TT("debug-logs") && console.log("Outgoing account metas:", c), new J0({
                keys: c,
                programId: r,
                data: n(e.name, Zz(e, ...o))
            })
        };
        return i.accounts = s => t.accountsArray(s, e.accounts, r, e.name), i
    }
    static accountsArray(e, n, r, i) {
        return e ? n.map(s => {
            if (("accounts" in s ? s.accounts : void 0) !== void 0) {
                let a = e[s.name];
                return t.accountsArray(a, s.accounts, r, i).flat()
            } else {
                let a = s,
                    c;
                try {
                    c = Sn(e[s.name])
                } catch {
                    throw new Error(`Wrong input type for account "${s.name}" in the instruction accounts object${i!==void 0?' for instruction "'+i+'"':""}. Expected PublicKey or string.`)
                }
                let l = a.isOptional && c.equals(r),
                    u = a.isMut && !l,
                    d = a.isSigner && !l;
                return {
                    pubkey: c,
                    isWritable: u,
                    isSigner: d
                }
            }
        }).flat() : []
    }
};

function R$(t, ...e) {}
var qw = class {
        static build(e, n) {
            return (...i) => {
                var s, o, a;
                let [, c] = df(e, [...i]), l = new hn;
                if (c.preInstructions && c.instructions) throw new Error("instructions is deprecated, use preInstructions");
                return (s = c.preInstructions) === null || s === void 0 || s.forEach(u => l.add(u)), (o = c.instructions) === null || o === void 0 || o.forEach(u => l.add(u)), l.add(n(...i)), (a = c.postInstructions) === null || a === void 0 || a.forEach(u => l.add(u)), l
            }
        }
    },
    Kw = class {
        static build(e, n, r, i) {
            return (...o) => x(this, null, function*() {
                var a;
                let c = n(...o),
                    [, l] = df(e, [...o]);
                if (i.sendAndConfirm === void 0) throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
                try {
                    return yield i.sendAndConfirm(c, (a = l.signers) !== null && a !== void 0 ? a : [], l.options)
                } catch (u) {
                    throw xT(u, r)
                }
            })
        }
    },
    Yw = class {
        static build(e, n, r, i) {
            var s;
            let o = {};
            return (s = e.accounts) === null || s === void 0 || s.forEach(a => {
                let c = (0, Le.default)(a.name);
                o[c] = new Jw(e, a, r, i, n)
            }), o
        }
    },
    Jw = class {
        get size() {
            return this._size
        }
        get programId() {
            return this._programId
        }
        get provider() {
            return this._provider
        }
        get coder() {
            return this._coder
        }
        get idlAccount() {
            return this._idlAccount
        }
        constructor(e, n, r, i, s) {
            this._idlAccount = n, this._programId = r, this._provider = i ? ? Tw(), this._coder = s ? ? new Jh(e), this._size = this._coder.accounts.size(n)
        }
        fetchNullable(e, n) {
            return x(this, null, function*() {
                let {
                    data: r
                } = yield this.fetchNullableAndContext(e, n);
                return r
            })
        }
        fetchNullableAndContext(e, n) {
            return x(this, null, function*() {
                let r = yield this.getAccountInfoAndContext(e, n), {
                    value: i,
                    context: s
                } = r;
                return {
                    data: i && i.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, i.data) : null,
                    context: s
                }
            })
        }
        fetch(e, n) {
            return x(this, null, function*() {
                let {
                    data: r
                } = yield this.fetchNullableAndContext(e, n);
                if (r === null) throw new Error(`Account does not exist or has no data ${e.toString()}`);
                return r
            })
        }
        fetchAndContext(e, n) {
            return x(this, null, function*() {
                let {
                    data: r,
                    context: i
                } = yield this.fetchNullableAndContext(e, n);
                if (r === null) throw new Error(`Account does not exist ${e.toString()}`);
                return {
                    data: r,
                    context: i
                }
            })
        }
        fetchMultiple(e, n) {
            return x(this, null, function*() {
                return (yield this.fetchMultipleAndContext(e, n)).map(i => i ? i.data : null)
            })
        }
        fetchMultipleAndContext(e, n) {
            return x(this, null, function*() {
                return (yield n$(this._provider.connection, e.map(i => Sn(i)), n)).map(i => {
                    if (i == null) return null;
                    let {
                        account: s,
                        context: o
                    } = i;
                    return {
                        data: this._coder.accounts.decode(this._idlAccount.name, s.data),
                        context: o
                    }
                })
            })
        }
        all(e) {
            return x(this, null, function*() {
                let n = this.coder.accounts.memcmp(this._idlAccount.name, e instanceof Buffer ? e : void 0),
                    r = [];
                return n ? .offset != null && n ? .bytes != null && r.push({
                    memcmp: {
                        offset: n.offset,
                        bytes: n.bytes
                    }
                }), n ? .dataSize != null && r.push({
                    dataSize: n.dataSize
                }), (yield this._provider.connection.getProgramAccounts(this._programId, {
                    commitment: this._provider.connection.commitment,
                    filters: [...r, ...Array.isArray(e) ? e : []]
                })).map(({
                    pubkey: s,
                    account: o
                }) => ({
                    publicKey: s,
                    account: this._coder.accounts.decode(this._idlAccount.name, o.data)
                }))
            })
        }
        subscribe(e, n) {
            let r = Zc.get(e.toString());
            if (r) return r.ee;
            let i = new DT.default;
            e = Sn(e);
            let s = this._provider.connection.onAccountChange(e, o => {
                let a = this._coder.accounts.decode(this._idlAccount.name, o.data);
                i.emit("change", a)
            }, n);
            return Zc.set(e.toString(), {
                ee: i,
                listener: s
            }), i
        }
        unsubscribe(e) {
            return x(this, null, function*() {
                let n = Zc.get(e.toString());
                if (!n) {
                    console.warn("Address is not subscribed");
                    return
                }
                Zc && (yield this._provider.connection.removeAccountChangeListener(n.listener).then(() => {
                    Zc.delete(e.toString())
                }).catch(console.error))
            })
        }
        createInstruction(e, n) {
            return x(this, null, function*() {
                let r = this.size;
                if (this._provider.publicKey === void 0) throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");
                return fn.createAccount({
                    fromPubkey: this._provider.publicKey,
                    newAccountPubkey: e.publicKey,
                    space: n ? ? r,
                    lamports: yield this._provider.connection.getMinimumBalanceForRentExemption(n ? ? r), programId: this._programId
                })
            })
        }
        associated(...e) {
            return x(this, null, function*() {
                let n = yield this.associatedAddress(...e);
                return yield this.fetch(n)
            })
        }
        associatedAddress(...e) {
            return x(this, null, function*() {
                return yield C$(this._programId, ...e)
            })
        }
        getAccountInfo(e, n) {
            return x(this, null, function*() {
                return yield this._provider.connection.getAccountInfo(Sn(e), n)
            })
        }
        getAccountInfoAndContext(e, n) {
            return x(this, null, function*() {
                return yield this._provider.connection.getAccountInfoAndContext(Sn(e), n)
            })
        }
    },
    Zc = new Map,
    Xw = "Program log: ",
    kT = "Program data: ",
    O$ = Xw.length,
    F$ = kT.length,
    e0 = class {
        constructor(e, n, r) {
            this._programId = e, this._provider = n, this._eventParser = new sf(e, r), this._eventCallbacks = new Map, this._eventListeners = new Map, this._listenerIdCount = 0
        }
        addEventListener(e, n) {
            var r;
            let i = this._listenerIdCount;
            return this._listenerIdCount += 1, this._eventListeners.has(e) || this._eventListeners.set(e, []), this._eventListeners.set(e, ((r = this._eventListeners.get(e)) !== null && r !== void 0 ? r : []).concat(i)), this._eventCallbacks.set(i, [e, n]), this._onLogsSubscriptionId !== void 0 || (this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (s, o) => {
                if (!s.err)
                    for (let a of this._eventParser.parseLogs(s.logs)) {
                        let c = this._eventListeners.get(a.name);
                        c && c.forEach(l => {
                            let u = this._eventCallbacks.get(l);
                            if (u) {
                                let [, d] = u;
                                d(a.data, o.slot, s.signature)
                            }
                        })
                    }
            })), i
        }
        removeEventListener(e) {
            return x(this, null, function*() {
                let n = this._eventCallbacks.get(e);
                if (!n) throw new Error(`Event listener ${e} doesn't exist!`);
                let [r] = n, i = this._eventListeners.get(r);
                if (!i) throw new Error(`Event listeners don't exist for ${r}!`);
                if (this._eventCallbacks.delete(e), i = i.filter(s => s !== e), this._eventListeners.set(r, i), i.length === 0 && this._eventListeners.delete(r), this._eventCallbacks.size === 0) {
                    if (this._eventListeners.size !== 0) throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);
                    this._onLogsSubscriptionId !== void 0 && (yield this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId), this._onLogsSubscriptionId = void 0)
                }
            })
        }
    },
    sf = class {
        constructor(e, n) {
            this.coder = n, this.programId = e
        }* parseLogs(e, n = !1) {
            let r = new n0(e),
                i = new t0,
                s = r.next();
            for (; s !== null;) {
                let [o, a, c] = this.handleLog(i, s, n);
                o && (yield o), a && i.push(a), c && i.pop(), s = r.next()
            }
        }
        handleLog(e, n, r) {
            return e.stack.length > 0 && e.program() === this.programId.toString() ? this.handleProgramLog(n, r) : [null, ...this.handleSystemLog(n)]
        }
        handleProgramLog(e, n) {
            if (e.startsWith(Xw) || e.startsWith(kT)) {
                let r = e.startsWith(Xw) ? e.slice(O$) : e.slice(F$),
                    i = this.coder.events.decode(r);
                if (n && i === null) throw new Error(`Unable to decode event ${r}`);
                return [i, null, !1]
            } else return [null, ...this.handleSystemLog(e)]
        }
        handleSystemLog(e) {
            let n = e.split(":")[0];
            return n.match(/^Program (.*) success/g) !== null ? [null, !0] : n.startsWith(`Program ${this.programId.toString()} invoke`) ? [this.programId.toString(), !1] : n.includes("invoke") ? ["cpi", !1] : [null, !1]
        }
    },
    t0 = class {
        constructor() {
            this.stack = []
        }
        program() {
            if (!this.stack.length) throw new Error("Expected the stack to have elements");
            return this.stack[this.stack.length - 1]
        }
        push(e) {
            this.stack.push(e)
        }
        pop() {
            if (!this.stack.length) throw new Error("Expected the stack to have elements");
            this.stack.pop()
        }
    },
    n0 = class {
        constructor(e) {
            this.logs = e
        }
        next() {
            if (this.logs.length === 0) return null;
            let e = this.logs[0];
            return this.logs = this.logs.slice(1), e
        }
    },
    r0 = class {
        static build(e, n, r, i, s, o, a) {
            return (...l) => x(this, null, function*() {
                var u;
                let d = n(...l),
                    [, h] = df(e, [...l]),
                    f;
                if (i.simulate === void 0) throw new Error("This function requires 'Provider.simulate' to be implemented.");
                try {
                    f = yield i.simulate(d, h.signers, (u = h.options) === null || u === void 0 ? void 0 : u.commitment)
                } catch (m) {
                    throw xT(m, r)
                }
                if (f === void 0) throw new Error("Unable to simulate transaction");
                let p = f.logs;
                if (!p) throw new Error("Simulated logs not found");
                let g = [];
                if (a.events) {
                    let m = new sf(o, s);
                    for (let y of m.parseLogs(p)) g.push(y)
                }
                return {
                    events: g,
                    raw: p
                }
            })
        }
    };

function Cw(t) {
    return new of (Xc(8), e => s0.fromBuffer(e), e => e.toBuffer(), t)
}

function qh(t) {
    return new of (Xc(32), e => new me(e), e => e.toBuffer(), t)
}

function Sw(t, e) {
    return new i0(t, e)
}
var of = class extends lf {
    constructor(e, n, r, i) {
        super(e.span, i), this.layout = e, this.decoder = n, this.encoder = r
    }
    decode(e, n) {
        return this.decoder(this.layout.decode(e, n))
    }
    encode(e, n, r) {
        return this.layout.encode(this.encoder(e), n, r)
    }
    getSpan(e, n) {
        return this.layout.getSpan(e, n)
    }
}, i0 = class extends lf {
    constructor(e, n) {
        super(-1, n), this.layout = e, this.discriminator = jr()
    }
    encode(e, n, r = 0) {
        return e == null ? this.layout.span + this.discriminator.encode(0, n, r) : (this.discriminator.encode(1, n, r), this.layout.encode(e, n, r + 4) + 4)
    }
    decode(e, n = 0) {
        let r = this.discriminator.decode(e, n);
        if (r === 0) return null;
        if (r === 1) return this.layout.decode(e, n + 4);
        throw new Error("Invalid coption " + this.layout.property)
    }
    getSpan(e, n = 0) {
        return this.layout.getSpan(e, n + 4) + 4
    }
}, s0 = class t extends d0.default {
    toBuffer() {
        let e = super.toArray().reverse(),
            n = Buffer.from(e);
        if (n.length === 8) return n;
        if (n.length >= 8) throw new Error("u64 too large");
        let r = Buffer.alloc(8);
        return n.copy(r), r
    }
    static fromBuffer(e) {
        if (e.length !== 8) throw new Error(`Invalid buffer length: ${e.length}`);
        return new t([...e].reverse().map(n => `00${n.toString(16)}`.slice(-2)).join(""), 16)
    }
}, k$ = ot([qh("mint"), qh("owner"), Cw("amount"), Sw(qh(), "delegate"), (t => {
    let e = FT(D$("discriminator"), null, t);
    return e.addVariant(0, ot([]), "uninitialized"), e.addVariant(1, ot([]), "initialized"), e.addVariant(2, ot([]), "frozen"), e
})("state"), Sw(Cw(), "isNative"), Cw("delegatedAmount"), Sw(qh(), "closeAuthority")]);

function P$(t) {
    return k$.decode(t)
}
var af = class t {
    constructor(e, n, r, i, s, o, a, c) {
        this._accounts = n, this._provider = r, this._programId = i, this._idlIx = s, this._idlTypes = a, this._customResolver = c, this._args = e, this._accountStore = new o0(r, o, this._programId)
    }
    args(e) {
        this._args = e
    }
    resolve() {
        return x(this, null, function*() {
            for (yield this.resolveConst(this._idlIx.accounts), this._resolveEventCpi(this._idlIx.accounts);
                (yield this.resolvePdas(this._idlIx.accounts)) + (yield this.resolveRelations(this._idlIx.accounts)) + (yield this.resolveCustom()) > 0;);
        })
    }
    resolveCustom() {
        return x(this, null, function*() {
            if (this._customResolver) {
                let {
                    accounts: e,
                    resolved: n
                } = yield this._customResolver({
                    args: this._args,
                    accounts: this._accounts,
                    provider: this._provider,
                    programId: this._programId,
                    idlIx: this._idlIx
                });
                return this._accounts = e, n
            }
            return 0
        })
    }
    resolveOptionalsHelper(e, n) {
        let r = {};
        for (let i of n) {
            let s = i.name,
                o = e[s];
            o !== void 0 && (PT(o) ? I$(i) ? r[s] = this.resolveOptionalsHelper(o, i.accounts) : r[s] = LT(o, !0) : o !== null ? r[s] = Sn(o) : i.isOptional && (r[s] = this._programId))
        }
        return r
    }
    resolveOptionals(e) {
        Object.assign(this._accounts, this.resolveOptionalsHelper(e, this._idlIx.accounts))
    }
    get(e) {
        let n = e.reduce((r, i) => r && r[i], this._accounts);
        if (n && n.toBase58) return n
    }
    set(e, n) {
        let r = this._accounts;
        e.forEach((i, s) => {
            s == e.length - 1 && (r[i] = n), r[i] = r[i] || {}, r = r[i]
        })
    }
    resolveConst(r) {
        return x(this, arguments, function*(e, n = []) {
            for (let i = 0; i < e.length; i += 1) {
                let s = e[i],
                    o = s.accounts;
                o && (yield this.resolveConst(o, [...n, (0, Le.default)(s.name)]));
                let a = s,
                    c = (0, Le.default)(s.name);
                if (a.isSigner && !this.get([...n, c])) {
                    if (this._provider.wallet === void 0) throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
                    this.set([...n, c], this._provider.wallet.publicKey)
                }
                Reflect.has(t.CONST_ACCOUNTS, c) && !this.get([...n, c]) && this.set([...n, c], t.CONST_ACCOUNTS[c])
            }
        })
    }
    _resolveEventCpi(e, n = []) {
        for (let r in e) {
            let i = e[r],
                s = i.accounts;
            s && this._resolveEventCpi(s, [...n, (0, Le.default)(i.name)]);
            let o = +r + 1;
            if (o === e.length) return;
            let a = (0, Le.default)(e[r].name),
                c = (0, Le.default)(e[o].name);
            if (a === "eventAuthority" && c === "program") {
                let l = [...n, a],
                    u = [...n, c];
                this.get(l) || this.set(l, me.findProgramAddressSync([Buffer.from("__event_authority")], this._programId)[0]), this.get(u) || this.set(u, this._programId);
                return
            }
        }
    }
    resolvePdas(r) {
        return x(this, arguments, function*(e, n = []) {
            let i = 0;
            for (let s = 0; s < e.length; s += 1) {
                let o = e[s],
                    a = o.accounts;
                a && (i += yield this.resolvePdas(a, [...n, (0, Le.default)(o.name)]));
                let c = o,
                    l = (0, Le.default)(o.name);
                c.pda && c.pda.seeds.length > 0 && !this.get([...n, l]) && (yield this.autoPopulatePda(c, n)) && (i += 1)
            }
            return i
        })
    }
    resolveRelations(r) {
        return x(this, arguments, function*(e, n = []) {
            let i = 0;
            for (let s = 0; s < e.length; s += 1) {
                let o = e[s],
                    a = o.accounts;
                a && (i += yield this.resolveRelations(a, [...n, (0, Le.default)(o.name)]));
                let c = o.relations || [],
                    l = (0, Le.default)(o.name),
                    u = [...n, l],
                    d = this.get(u);
                if (d) {
                    let h = c.filter(f => !this.get([...n, (0, Le.default)(f)]));
                    if (i += h.length, h.length > 0) {
                        let f = yield this._accountStore.fetchAccount({
                            publicKey: d
                        });
                        yield Promise.all(h.map(p => x(this, null, function*() {
                            let g = (0, Le.default)(p);
                            return this.set([...n, g], f[g]), f[g]
                        })))
                    }
                }
            }
            return i
        })
    }
    autoPopulatePda(r) {
        return x(this, arguments, function*(e, n = []) {
            if (!e.pda || !e.pda.seeds) throw new Error("Must have seeds");
            let i = yield Promise.all(e.pda.seeds.map(a => this.toBuffer(a, n)));
            if (i.some(a => typeof a > "u")) return;
            let s = yield this.parseProgramId(e, n);
            if (!s) return;
            let [o] = yield me.findProgramAddress(i, s);
            this.set([...n, (0, Le.default)(e.name)], o)
        })
    }
    parseProgramId(r) {
        return x(this, arguments, function*(e, n = []) {
            var i;
            if (!(!((i = e.pda) === null || i === void 0) && i.programId)) return this._programId;
            switch (e.pda.programId.kind) {
                case "const":
                    return new me(this.toBufferConst(e.pda.programId.value));
                case "arg":
                    return this.argValue(e.pda.programId);
                case "account":
                    return yield this.accountValue(e.pda.programId, n);
                default:
                    throw new Error(`Unexpected program seed kind: ${e.pda.programId.kind}`)
            }
        })
    }
    toBuffer(r) {
        return x(this, arguments, function*(e, n = []) {
            switch (e.kind) {
                case "const":
                    return this.toBufferConst(e);
                case "arg":
                    return yield this.toBufferArg(e);
                case "account":
                    return yield this.toBufferAccount(e, n);
                default:
                    throw new Error(`Unexpected seed kind: ${e.kind}`)
            }
        })
    }
    getType(e, n = []) {
        if (n.length > 0 && e.defined) {
            let r = this._idlTypes.find(o => o.name === e.defined);
            if (!r) throw new Error(`Cannot find type ${e.defined}`);
            let s = r.type.fields.find(o => o.name === n[0]);
            return this.getType(s.type, n.slice(1))
        }
        return e
    }
    toBufferConst(e) {
        return this.toBufferValue(this.getType(e.type, (e.path || "").split(".").slice(1)), e.value)
    }
    toBufferArg(e) {
        return x(this, null, function*() {
            let n = this.argValue(e);
            if (!(typeof n > "u")) return this.toBufferValue(this.getType(e.type, (e.path || "").split(".").slice(1)), n)
        })
    }
    argValue(e) {
        let n = e.path.split("."),
            r = (0, Le.default)(n[0]),
            i = this._idlIx.args.findIndex(s => s.name === r);
        if (i === -1) throw new Error(`Unable to find argument for seed: ${r}`);
        return n.slice(1).reduce((s, o) => (s || {})[o], this._args[i])
    }
    toBufferAccount(r) {
        return x(this, arguments, function*(e, n = []) {
            let i = yield this.accountValue(e, n);
            if (i) return this.toBufferValue(e.type, i)
        })
    }
    accountValue(r) {
        return x(this, arguments, function*(e, n = []) {
            let i = e.path.split("."),
                s = i[0],
                o = this.get([...n, (0, Le.default)(s)]);
            if (o === null) throw new Error("fieldPubkey is null");
            if (i.length === 1) return o;
            let a = yield this._accountStore.fetchAccount({
                publicKey: o,
                name: e.account
            });
            return this.parseAccountValue(a, i.slice(1))
        })
    }
    parseAccountValue(e, n) {
        let r;
        for (; n.length > 0;) r = e[(0, Le.default)(n[0])], n = n.slice(1);
        return r
    }
    toBufferValue(e, n) {
        switch (e) {
            case "u8":
                return Buffer.from([n]);
            case "u16":
                let r = Buffer.alloc(2);
                return r.writeUInt16LE(n), r;
            case "u32":
                let i = Buffer.alloc(4);
                return i.writeUInt32LE(n), i;
            case "u64":
                let s = Buffer.alloc(8);
                return s.writeBigUInt64LE(BigInt(n)), s;
            case "string":
                return Buffer.from(Hz(n));
            case "publicKey":
                return n.toBuffer();
            default:
                if (e.array) return Buffer.from(n);
                throw new Error(`Unexpected seed type: ${e}`)
        }
    }
};
af.CONST_ACCOUNTS = {
    associatedTokenProgram: M$,
    rent: e_,
    systemProgram: fn.programId,
    tokenProgram: S$,
    clock: X0
};
var o0 = class {
        constructor(e, n, r) {
            this._provider = e, this._programId = r, this._cache = new Map, this._idls = {}, this._idls[r.toBase58()] = n
        }
        ensureIdl(e) {
            return x(this, null, function*() {
                if (!this._idls[e.toBase58()]) {
                    let n = yield cf.fetchIdl(e, this._provider);
                    if (n) {
                        let r = new cf(n, e, this._provider);
                        this._idls[e.toBase58()] = r.account
                    }
                }
                return this._idls[e.toBase58()]
            })
        }
        fetchAccount(i) {
            return x(this, arguments, function*({
                publicKey: e,
                name: n,
                programId: r = this._programId
            }) {
                let s = e.toString();
                if (!this._cache.has(s))
                    if (n === "TokenAccount") {
                        let o = yield this._provider.connection.getAccountInfo(e);
                        if (o === null) throw new Error(`invalid account info for ${s}`);
                        let a = P$(o.data);
                        this._cache.set(s, a)
                    } else if (n) {
                    let o = yield this.ensureIdl(r);
                    if (o) {
                        let a = o[(0, Le.default)(n)];
                        if (a) {
                            let c = yield a.fetch(e);
                            this._cache.set(s, c)
                        }
                    }
                } else {
                    let o = yield this._provider.connection.getAccountInfo(e);
                    if (o === null) throw new Error(`invalid account info for ${s}`);
                    let a = o.data,
                        c = yield this.ensureIdl(o.owner);
                    if (c) {
                        let l = Object.values(c)[0];
                        if (!l) throw new Error("No accounts for this program");
                        let u = l.coder.accounts.decodeAny(a);
                        this._cache.set(s, u)
                    }
                }
                return this._cache.get(s)
            })
        }
    },
    a0 = class {
        static build(e, n, r, i, s, o, a, c, l, u, d) {
            return (...h) => new c0(h, i, s, o, a, c, e, n, r, l, u, d)
        }
    };

function PT(t) {
    return typeof t == "object" && t !== null && !("_bn" in t)
}

function LT(t, e) {
    let n = {};
    for (let r in t) {
        let i = t[r];
        if (i === null) {
            if (e) throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");
            continue
        }
        n[r] = PT(i) ? LT(i, !0) : Sn(i)
    }
    return n
}
var c0 = class {
        constructor(e, n, r, i, s, o, a, c, l, u, d, h) {
            this._ixFn = n, this._txFn = r, this._rpcFn = i, this._simulateFn = s, this._viewFn = o, this._programId = c, this._accounts = {}, this._remainingAccounts = [], this._signers = [], this._preInstructions = [], this._postInstructions = [], this._autoResolveAccounts = !0, this._args = e, this._accountsResolver = new af(e, this._accounts, a, c, l, u, d, h)
        }
        args(e) {
            this._args = e, this._accountsResolver.args(e)
        }
        pubkeys() {
            return x(this, null, function*() {
                return this._autoResolveAccounts && (yield this._accountsResolver.resolve()), this._accounts
            })
        }
        accounts(e) {
            return this._autoResolveAccounts = !0, this._accountsResolver.resolveOptionals(e), this
        }
        accountsStrict(e) {
            return this._autoResolveAccounts = !1, this._accountsResolver.resolveOptionals(e), this
        }
        signers(e) {
            return this._signers = this._signers.concat(e), this
        }
        remainingAccounts(e) {
            return this._remainingAccounts = this._remainingAccounts.concat(e), this
        }
        preInstructions(e) {
            return this._preInstructions = this._preInstructions.concat(e), this
        }
        postInstructions(e) {
            return this._postInstructions = this._postInstructions.concat(e), this
        }
        rpc(e) {
            return x(this, null, function*() {
                return this._autoResolveAccounts && (yield this._accountsResolver.resolve()), this._rpcFn(...this._args, {
                    accounts: this._accounts,
                    signers: this._signers,
                    remainingAccounts: this._remainingAccounts,
                    preInstructions: this._preInstructions,
                    postInstructions: this._postInstructions,
                    options: e
                })
            })
        }
        rpcAndKeys(e) {
            return x(this, null, function*() {
                return {
                    pubkeys: yield this.pubkeys(), signature: yield this.rpc(e)
                }
            })
        }
        view(e) {
            return x(this, null, function*() {
                if (this._autoResolveAccounts && (yield this._accountsResolver.resolve()), !this._viewFn) throw new Error("Method does not support views");
                return this._viewFn(...this._args, {
                    accounts: this._accounts,
                    signers: this._signers,
                    remainingAccounts: this._remainingAccounts,
                    preInstructions: this._preInstructions,
                    postInstructions: this._postInstructions,
                    options: e
                })
            })
        }
        simulate(e) {
            return x(this, null, function*() {
                return this._autoResolveAccounts && (yield this._accountsResolver.resolve()), this._simulateFn(...this._args, {
                    accounts: this._accounts,
                    signers: this._signers,
                    remainingAccounts: this._remainingAccounts,
                    preInstructions: this._preInstructions,
                    postInstructions: this._postInstructions,
                    options: e
                })
            })
        }
        instruction() {
            return x(this, null, function*() {
                return this._autoResolveAccounts && (yield this._accountsResolver.resolve()), this._ixFn(...this._args, {
                    accounts: this._accounts,
                    signers: this._signers,
                    remainingAccounts: this._remainingAccounts,
                    preInstructions: this._preInstructions,
                    postInstructions: this._postInstructions
                })
            })
        }
        prepare() {
            return x(this, null, function*() {
                return {
                    instruction: yield this.instruction(), pubkeys: yield this.pubkeys(), signers: yield this._signers
                }
            })
        }
        transaction() {
            return x(this, null, function*() {
                return this._autoResolveAccounts && (yield this._accountsResolver.resolve()), this._txFn(...this._args, {
                    accounts: this._accounts,
                    signers: this._signers,
                    remainingAccounts: this._remainingAccounts,
                    preInstructions: this._preInstructions,
                    postInstructions: this._postInstructions
                })
            })
        }
    },
    l0 = class {
        static build(e, n, r, i) {
            let s = n.accounts.find(c => c.isMut),
                o = !!n.returns;
            return s || !o ? void 0 : (...c) => x(this, null, function*() {
                var l, u;
                let d = yield r(...c), h = `Program return: ${e} `, f = d.raw.find(y => y.startsWith(h));
                if (!f) throw new Error("View expected return log");
                let p = ET(f.slice(h.length)),
                    g = n.returns;
                if (!g) throw new Error("View expected return type");
                return Es.fieldLayout({
                    type: g
                }, Array.from([...(l = i.accounts) !== null && l !== void 0 ? l : [], ...(u = i.types) !== null && u !== void 0 ? u : []])).decode(p)
            })
        }
    },
    u0 = class {
        static build(e, n, r, i, s) {
            let o = {},
                a = {},
                c = {},
                l = {},
                u = {},
                d = {},
                h = Gz(e),
                f = e.accounts ? Yw.build(e, n, r, i) : {};
            return e.instructions.forEach(p => {
                let g = Qw.build(p, (L, D) => n.instruction.encode(L, D), r),
                    m = qw.build(p, g),
                    y = Kw.build(p, m, h, i),
                    E = r0.build(p, m, h, i, n, r, e),
                    T = l0.build(r, p, E, e),
                    w = a0.build(i, r, p, g, m, y, E, T, f, e.types || [], s && s(p)),
                    N = (0, Le.default)(p.name);
                a[N] = g, c[N] = m, o[N] = y, l[N] = E, u[N] = w, T && (d[N] = T)
            }), [o, a, c, f, l, u, d]
        }
    },
    cf = class t {
        get programId() {
            return this._programId
        }
        get idl() {
            return this._idl
        }
        get coder() {
            return this._coder
        }
        get provider() {
            return this._provider
        }
        constructor(e, n, r, i, s) {
            n = Sn(n), r || (r = Tw()), this._idl = e, this._provider = r, this._programId = n, this._coder = i ? ? new Jh(e), this._events = new e0(this._programId, r, this._coder);
            let [o, a, c, l, u, d, h] = u0.build(e, this._coder, n, r, s ? ? (() => {}));
            this.rpc = o, this.instruction = a, this.transaction = c, this.account = l, this.simulate = u, this.methods = d, this.views = h
        }
        static at(e, n) {
            return x(this, null, function*() {
                let r = Sn(e),
                    i = yield t.fetchIdl(r, n);
                if (!i) throw new Error(`IDL not found for program: ${e.toString()}`);
                return new t(i, r, n)
            })
        }
        static fetchIdl(e, n) {
            return x(this, null, function*() {
                n = n ? ? Tw();
                let r = Sn(e),
                    i = yield T$(r), s = yield n.connection.getAccountInfo(i);
                if (!s) return null;
                let o = N$(s.data.slice(8)),
                    a = lT(o.data);
                return JSON.parse(Wz(a))
            })
        }
        addEventListener(e, n) {
            return this._events.addEventListener(e, n)
        }
        removeEventListener(e) {
            return x(this, null, function*() {
                return yield this._events.removeEventListener(e)
            })
        }
    },
    bY = new me("11111111111111111111111111111111");

function Cs(t, e) {
    let n = !e ? .manualCleanup;
    n && !e ? .injector && Hg(Cs);
    let r = n ? e ? .injector ? .get(go) ? ? M(go) : null,
        i;
    e ? .requireSync ? i = Hu({
        kind: 0
    }) : i = Hu({
        kind: 1,
        value: e ? .initialValue
    });
    let s = t.subscribe({
        next: o => i.set({
            kind: 1,
            value: o
        }),
        error: o => {
            if (e ? .rejectErrors) throw o;
            i.set({
                kind: 2,
                error: o
            })
        }
    });
    return r ? .onDestroy(s.unsubscribe.bind(s)), dd(() => {
        let o = i();
        switch (o.kind) {
            case 1:
                return o.value;
            case 2:
                throw o.error;
            case 0:
                throw new S(601, "`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.")
        }
    })
}

function V$() {
    return t => new ie(e => {
        let n, r, i = new Oe;
        return i.add(t.subscribe({
            complete: () => {
                n && e.next(r), e.complete()
            },
            error: s => {
                e.error(s)
            },
            next: s => {
                r = s, n || (n = Tl.schedule(() => {
                    e.next(r), n = void 0
                }), i.add(n))
            }
        })), i
    })
}

function g0(t) {
    return typeof t.ngrxOnStoreInit == "function"
}

function m0(t) {
    return typeof t.ngrxOnStateInit == "function"
}

function y0(t) {
    let e = new R("@ngrx/component-store ComponentStore with Hooks");
    return [{
        provide: e,
        useClass: t
    }, {
        provide: t,
        useFactory: () => {
            let n = M(e);
            return n.\u0275hasProvider = !0, g0(n) && n.ngrxOnStoreInit(), m0(n) && n.state$.pipe(vt(1)).subscribe(() => n.ngrxOnStateInit()), n
        }
    }]
}
var U$ = new R("@ngrx/component-store Initial State"),
    hf = (() => {
        let e = class e {
            constructor(r) {
                this.destroySubject$ = new Gr(1), this.destroy$ = this.destroySubject$.asObservable(), this.stateSubject$ = new Gr(1), this.isInitialized = !1, this.state$ = this.select(i => i), this.state = Cs(this.stateSubject$.pipe(Rn(this.destroy$)), {
                    requireSync: !1,
                    manualCleanup: !0
                }), this.\u0275hasProvider = !1, r && this.initState(r), this.checkProviderForHooks()
            }
            ngOnDestroy() {
                this.stateSubject$.complete(), this.destroySubject$.next()
            }
            updater(r) {
                return i => {
                    let s = !0,
                        o, c = (Rt(i) ? i : k(i)).pipe(Li(Nl), ve(() => this.assertStateIsInitialized()), Qs(this.stateSubject$), Z(([l, u]) => r(u, l)), ve(l => this.stateSubject$.next(l)), yt(l => s ? (o = l, Ye) : Qe(l)), Rn(this.destroy$)).subscribe();
                    if (o) throw o;
                    return s = !1, c
                }
            }
            initState(r) {
                da([r], Nl).subscribe(i => {
                    this.isInitialized = !0, this.stateSubject$.next(i)
                })
            }
            setState(r) {
                typeof r != "function" ? this.initState(r) : this.updater(r)()
            }
            patchState(r) {
                let i = typeof r == "function" ? r(this.get()) : r;
                this.updater((s, o) => _(_({}, s), o))(i)
            }
            get(r) {
                this.assertStateIsInitialized();
                let i;
                return this.stateSubject$.pipe(vt(1)).subscribe(s => {
                    i = r ? r(s) : s
                }), i
            }
            select(...r) {
                let {
                    observablesOrSelectorsObject: i,
                    projector: s,
                    config: o
                } = j$(r);
                return (z$(i, s) ? this.stateSubject$ : Ot(i)).pipe(o.debounce ? V$() : VT(), s ? Z(c => i.length > 0 && Array.isArray(c) ? s(...c) : s(c)) : VT(), mp(o.equal), Zs({
                    refCount: !0,
                    bufferSize: 1
                }), Rn(this.destroy$))
            }
            selectSignal(...r) {
                let i = [...r],
                    s = typeof i[r.length - 1] == "object" ? i.pop() : {},
                    o = i.pop(),
                    a = i,
                    c = a.length === 0 ? () => o(this.state()) : () => {
                        let l = a.map(u => u());
                        return o(...l)
                    };
                return dd(c, s)
            }
            effect(r) {
                let i = new Me;
                return r(i).pipe(Rn(this.destroy$)).subscribe(), s => (Rt(s) ? s : k(s)).pipe(Rn(this.destroy$)).subscribe(a => {
                    i.next(a)
                })
            }
            checkProviderForHooks() {
                Tl.schedule(() => {
                    if (cd() && (g0(this) || m0(this)) && !this.\u0275hasProvider) {
                        let r = [g0(this) ? "OnStoreInit" : "", m0(this) ? "OnStateInit" : ""].filter(i => i);
                        console.warn(`@ngrx/component-store: ${this.constructor.name} has the ${r.join(" and ")} lifecycle hook(s) implemented without being provided using the provideComponentStore(${this.constructor.name}) function. To resolve this, provide the component store via provideComponentStore(${this.constructor.name})`)
                    }
                })
            }
            assertStateIsInitialized() {
                if (!this.isInitialized) throw new Error(`${this.constructor.name} has not been initialized yet. Please make sure it is initialized before updating/getting.`)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(U$, 8))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })();

function j$(t) {
    let e = Array.from(t),
        r = {
            debounce: !1,
            equal: (o, a) => o === a
        };
    if (B$(e[e.length - 1]) && (r = _(_({}, r), e.pop())), e.length === 1 && typeof e[0] != "function") return {
        observablesOrSelectorsObject: e[0],
        projector: void 0,
        config: r
    };
    let i = e.pop();
    return {
        observablesOrSelectorsObject: e,
        projector: i,
        config: r
    }
}

function B$(t) {
    let e = t;
    return typeof e.debounce < "u" || typeof e.equal < "u"
}

function z$(t, e) {
    return Array.isArray(t) && t.length === 0 && e
}

function VT() {
    return t => t
}
_r();
var UT = Hn(q0(), 1);
var Ge = class extends Error {
        constructor(e, n) {
            super(e), this.error = n
        }
    },
    Gt = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletNotReadyError"
        }
    },
    ff = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletLoadError"
        }
    },
    Ii = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletConfigError"
        }
    },
    ln = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletConnectionError"
        }
    },
    mr = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletDisconnectedError"
        }
    },
    Ti = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletDisconnectionError"
        }
    },
    $n = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletAccountError"
        }
    },
    xi = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletPublicKeyError"
        }
    };
var Ve = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletNotConnectedError"
        }
    },
    Zt = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletSendTransactionError"
        }
    },
    Et = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletSignTransactionError"
        }
    },
    yr = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletSignMessageError"
        }
    },
    el = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletSignInError"
        }
    };
var pf = class extends Ge {
    constructor() {
        super(...arguments), this.name = "WalletWindowClosedError"
    }
};
var _e = function(t) {
        return t.Installed = "Installed", t.NotDetected = "NotDetected", t.Loadable = "Loadable", t.Unsupported = "Unsupported", t
    }(_e || {}),
    na = class extends UT.default {
        get connected() {
            return !!this.publicKey
        }
        autoConnect() {
            return x(this, null, function*() {
                yield this.connect()
            })
        }
        prepareTransaction(i, s) {
            return x(this, arguments, function*(e, n, r = {}) {
                let o = this.publicKey;
                if (!o) throw new Ve;
                return e.feePayer = e.feePayer || o, e.recentBlockhash = e.recentBlockhash || (yield n.getLatestBlockhash({
                    commitment: r.preflightCommitment,
                    minContextSlot: r.minContextSlot
                })).blockhash, e
            })
        }
    };

function jT(t) {
    if (typeof window > "u" || typeof document > "u") return;
    let e = [];

    function n() {
        if (t())
            for (let s of e) s()
    }
    let r = setInterval(n, 1e3);
    e.push(() => clearInterval(r)), document.readyState === "loading" && (document.addEventListener("DOMContentLoaded", n, {
        once: !0
    }), e.push(() => document.removeEventListener("DOMContentLoaded", n))), document.readyState !== "complete" && (window.addEventListener("load", n, {
        once: !0
    }), e.push(() => window.removeEventListener("load", n))), n()
}

function $r(t) {
    return "version" in t
}
var tl = class extends na {
        sendTransaction(i, s) {
            return x(this, arguments, function*(e, n, r = {}) {
                let o = !0;
                try {
                    if ($r(e)) {
                        if (!this.supportedTransactionVersions) throw new Zt("Sending versioned transactions isn't supported by this wallet");
                        if (!this.supportedTransactionVersions.has(e.version)) throw new Zt(`Sending transaction version ${e.version} isn't supported by this wallet`);
                        try {
                            e = yield this.signTransaction(e);
                            let c = e.serialize();
                            return yield n.sendRawTransaction(c, r)
                        } catch (c) {
                            throw c instanceof Et ? (o = !1, c) : new Zt(c ? .message, c)
                        }
                    } else try {
                        let a = r,
                            {
                                signers: c
                            } = a,
                            l = Tn(a, ["signers"]);
                        e = yield this.prepareTransaction(e, n, l), c ? .length && e.partialSign(...c), e = yield this.signTransaction(e);
                        let u = e.serialize();
                        return yield n.sendRawTransaction(u, l)
                    } catch (c) {
                        throw c instanceof Et ? (o = !1, c) : new Zt(c ? .message, c)
                    }
                } catch (c) {
                    throw o && this.emit("error", c), c
                }
            })
        }
        signAllTransactions(e) {
            return x(this, null, function*() {
                for (let r of e)
                    if ($r(r)) {
                        if (!this.supportedTransactionVersions) throw new Et("Signing versioned transactions isn't supported by this wallet");
                        if (!this.supportedTransactionVersions.has(r.version)) throw new Et(`Signing transaction version ${r.version} isn't supported by this wallet`)
                    }
                let n = [];
                for (let r of e) n.push(yield this.signTransaction(r));
                return n
            })
        }
    },
    nl = class extends tl {},
    gf = class extends nl {};
var vr = "solana:signAndSendTransaction";
var mf = "solana:signIn";
var ra = "solana:signMessage";
var at = "solana:signTransaction";
var yf = "standard:connect";
var v0 = "standard:disconnect";
var vf = "standard:events";

function BT(t) {
    return yf in t.features && vf in t.features && (vr in t.features || at in t.features)
}
var rl = function(t) {
    return t.Mainnet = "mainnet-beta", t.Testnet = "testnet", t.Devnet = "devnet", t
}(rl || {});
_r();
_r();

function wf(t) {
    switch (t) {
        case "processed":
        case "confirmed":
        case "finalized":
        case void 0:
            return t;
        case "recent":
            return "processed";
        case "single":
        case "singleGossip":
            return "confirmed";
        case "max":
        case "root":
            return "finalized";
        default:
            return
    }
}
var w0 = "solana:mainnet",
    zT = "solana:devnet",
    $T = "solana:testnet",
    WT = "solana:localnet";
var $$ = "https://api.mainnet-beta.solana.com";

function HT(t) {
    return t.includes($$) ? w0 : /\bdevnet\b/i.test(t) ? zT : /\btestnet\b/i.test(t) ? $T : /\blocalhost\b/i.test(t) || /\b127\.0\.0\.1\b/.test(t) ? WT : w0
}
var W$ = "(?<domain>[^\\n]+?) wants you to sign in with your Solana account:\\n",
    H$ = "(?<address>[^\\n]+)(?:\\n|$)",
    G$ = "(?:\\n(?<statement>[\\S\\s]*?)(?:\\n|$))??",
    Z$ = "(?:\\nURI: (?<uri>[^\\n]+))?",
    Q$ = "(?:\\nVersion: (?<version>[^\\n]+))?",
    q$ = "(?:\\nChain ID: (?<chainId>[^\\n]+))?",
    K$ = "(?:\\nNonce: (?<nonce>[^\\n]+))?",
    Y$ = "(?:\\nIssued At: (?<issuedAt>[^\\n]+))?",
    J$ = "(?:\\nExpiration Time: (?<expirationTime>[^\\n]+))?",
    X$ = "(?:\\nNot Before: (?<notBefore>[^\\n]+))?",
    e3 = "(?:\\nRequest ID: (?<requestId>[^\\n]+))?",
    t3 = "(?:\\nResources:(?<resources>(?:\\n- [^\\n]+)*))?",
    n3 = `${Z$}${Q$}${q$}${K$}${Y$}${J$}${X$}${e3}${t3}`,
    l7 = new RegExp(`^${W$}${H$}${G$}${n3}\\n*$`);

function GT(t) {
    let e = `${t.domain} wants you to sign in with your Solana account:
`;
    e += `${t.address}`, t.statement && (e += `

${t.statement}`);
    let n = [];
    if (t.uri && n.push(`URI: ${t.uri}`), t.version && n.push(`Version: ${t.version}`), t.chainId && n.push(`Chain ID: ${t.chainId}`), t.nonce && n.push(`Nonce: ${t.nonce}`), t.issuedAt && n.push(`Issued At: ${t.issuedAt}`), t.expirationTime && n.push(`Expiration Time: ${t.expirationTime}`), t.notBefore && n.push(`Not Before: ${t.notBefore}`), t.requestId && n.push(`Request ID: ${t.requestId}`), t.resources) {
        n.push("Resources:");
        for (let r of t.resources) n.push(`- ${r}`)
    }
    return n.length && (e += `

${n.join(`
`)}`), e
}
var Wr = {
        ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
        ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
        ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
        ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
        ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
        ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND",
        ERROR_INVALID_PROTOCOL_VERSION: "ERROR_INVALID_PROTOCOL_VERSION"
    },
    Wn = class extends Error {
        constructor(...e) {
            let [n, r, i] = e;
            super(r), this.code = n, this.data = i, this.name = "SolanaMobileWalletAdapterError"
        }
    };
var _f = class extends Error {
    constructor(...e) {
        let [n, r, i, s] = e;
        super(i), this.code = r, this.data = s, this.jsonRpcMessageId = n, this.name = "SolanaMobileWalletAdapterProtocolError"
    }
};

function ct(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        })
    }
    return new(n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                l(r.next(u))
            } catch (d) {
                o(d)
            }
        }

        function c(u) {
            try {
                l(r.throw(u))
            } catch (d) {
                o(d)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(a, c)
        }
        l((r = r.apply(t, e || [])).next())
    })
}

function r3(t, e) {
    return ct(this, void 0, void 0, function*() {
        let n = yield crypto.subtle.exportKey("raw", t), r = yield crypto.subtle.sign({
            hash: "SHA-256",
            name: "ECDSA"
        }, e, n), i = new Uint8Array(n.byteLength + r.byteLength);
        return i.set(new Uint8Array(n), 0), i.set(new Uint8Array(r), n.byteLength), i
    })
}

function i3(t) {
    return window.btoa(t)
}

function s3(t) {
    return GT(t)
}

function o3(t) {
    return i3(s3(t))
}
var a3 = "solana:signTransactions",
    ZT = "solana:cloneAuthorization";

function c3(t, e) {
    return new Proxy({}, {
        get(n, r) {
            return n[r] == null && (n[r] = function(i) {
                return ct(this, void 0, void 0, function*() {
                    let {
                        method: s,
                        params: o
                    } = l3(r, i, t), a = yield e(s, o);
                    return s === "authorize" && o.sign_in_payload && !a.sign_in_result && (a.sign_in_result = yield d3(o.sign_in_payload, a, e)), u3(r, a, t)
                })
            }), n[r]
        },
        defineProperty() {
            return !1
        },
        deleteProperty() {
            return !1
        }
    })
}

function l3(t, e, n) {
    let r = e,
        i = t.toString().replace(/[A-Z]/g, s => `_${s.toLowerCase()}`).toLowerCase();
    switch (t) {
        case "authorize":
            {
                let {
                    chain: s
                } = r;
                if (n === "legacy") {
                    switch (s) {
                        case "solana:testnet":
                            {
                                s = "testnet";
                                break
                            }
                        case "solana:devnet":
                            {
                                s = "devnet";
                                break
                            }
                        case "solana:mainnet":
                            {
                                s = "mainnet-beta";
                                break
                            }
                        default:
                            s = r.cluster
                    }
                    r.cluster = s
                } else {
                    switch (s) {
                        case "testnet":
                        case "devnet":
                            {
                                s = `solana:${s}`;
                                break
                            }
                        case "mainnet-beta":
                            {
                                s = "solana:mainnet";
                                break
                            }
                    }
                    r.chain = s
                }
            }
        case "reauthorize":
            {
                let {
                    auth_token: s,
                    identity: o
                } = r;
                if (s) switch (n) {
                    case "legacy":
                        {
                            i = "reauthorize",
                            r = {
                                auth_token: s,
                                identity: o
                            };
                            break
                        }
                    default:
                        {
                            i = "authorize";
                            break
                        }
                }
                break
            }
    }
    return {
        method: i,
        params: r
    }
}

function u3(t, e, n) {
    switch (t) {
        case "getCapabilities":
            {
                let r = e;
                switch (n) {
                    case "legacy":
                        {
                            let i = [a3];
                            return r.supports_clone_authorization === !0 && i.push(ZT),
                            Object.assign(Object.assign({}, r), {
                                features: i
                            })
                        }
                    case "v1":
                        return Object.assign(Object.assign({}, r), {
                            supports_sign_and_send_transactions: !0,
                            supports_clone_authorization: r.features.includes(ZT)
                        })
                }
            }
    }
    return e
}

function d3(t, e, n) {
    var r;
    return ct(this, void 0, void 0, function*() {
        let i = (r = t.domain) !== null && r !== void 0 ? r : window.location.host,
            s = e.accounts[0].address,
            o = o3(Object.assign(Object.assign({}, t), {
                domain: i,
                address: s
            })),
            a = yield n("sign_messages", {
                addresses: [s],
                payloads: [o]
            });
        return {
            address: s,
            signed_message: o,
            signature: a.signed_payloads[0].slice(o.length)
        }
    })
}
var Ss = 4;

function h3(t) {
    if (t >= 4294967296) throw new Error("Outbound sequence number overflow. The maximum sequence number is 32-bytes.");
    let e = new ArrayBuffer(Ss);
    return new DataView(e).setUint32(0, t, !1), new Uint8Array(e)
}
var b0 = 12,
    YT = 65;

function f3(t, e, n) {
    return ct(this, void 0, void 0, function*() {
        let r = h3(e),
            i = new Uint8Array(b0);
        crypto.getRandomValues(i);
        let s = yield crypto.subtle.encrypt(XT(r, i), n, new TextEncoder().encode(t)), o = new Uint8Array(r.byteLength + i.byteLength + s.byteLength);
        return o.set(new Uint8Array(r), 0), o.set(new Uint8Array(i), r.byteLength), o.set(new Uint8Array(s), r.byteLength + i.byteLength), o
    })
}

function JT(t, e) {
    return ct(this, void 0, void 0, function*() {
        let n = t.slice(0, Ss),
            r = t.slice(Ss, Ss + b0),
            i = t.slice(Ss + b0),
            s = yield crypto.subtle.decrypt(XT(n, r), e, i);
        return p3().decode(s)
    })
}

function XT(t, e) {
    return {
        additionalData: t,
        iv: e,
        name: "AES-GCM",
        tagLength: 128
    }
}
var _0;

function p3() {
    return _0 === void 0 && (_0 = new TextDecoder("utf-8")), _0
}

function g3() {
    return ct(this, void 0, void 0, function*() {
        return yield crypto.subtle.generateKey({
            name: "ECDSA",
            namedCurve: "P-256"
        }, !1, ["sign"])
    })
}

function m3() {
    return ct(this, void 0, void 0, function*() {
        return yield crypto.subtle.generateKey({
            name: "ECDH",
            namedCurve: "P-256"
        }, !1, ["deriveKey", "deriveBits"])
    })
}

function y3(t, e) {
    return ct(this, void 0, void 0, function*() {
        let n = JSON.stringify(t),
            r = t.id;
        return f3(n, r, e)
    })
}

function v3(t, e) {
    return ct(this, void 0, void 0, function*() {
        let n = yield JT(t, e), r = JSON.parse(n);
        if (Object.hasOwnProperty.call(r, "error")) throw new _f(r.id, r.error.code, r.error.message);
        return r
    })
}

function w3(t, e, n) {
    return ct(this, void 0, void 0, function*() {
        let [r, i] = yield Promise.all([crypto.subtle.exportKey("raw", e), crypto.subtle.importKey("raw", t.slice(0, YT), {
            name: "ECDH",
            namedCurve: "P-256"
        }, !1, [])]), s = yield crypto.subtle.deriveBits({
            name: "ECDH",
            public: i
        }, n, 256), o = yield crypto.subtle.importKey("raw", s, "HKDF", !1, ["deriveKey"]);
        return yield crypto.subtle.deriveKey({
            name: "HKDF",
            hash: "SHA-256",
            salt: new Uint8Array(r),
            info: new Uint8Array
        }, o, {
            name: "AES-GCM",
            length: 128
        }, !1, ["encrypt", "decrypt"])
    })
}

function _3(t, e) {
    return ct(this, void 0, void 0, function*() {
        let n = yield JT(t, e), r = JSON.parse(n), i = "legacy";
        if (Object.hasOwnProperty.call(r, "v")) switch (r.v) {
            case 1:
            case "1":
            case "v1":
                i = "v1";
                break;
            case "legacy":
                i = "legacy";
                break;
            default:
                throw new Wn(Wr.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${r.v}`)
        }
        return {
            protocol_version: i
        }
    })
}

function b3() {
    return ex(49152 + Math.floor(Math.random() * 16384))
}

function ex(t) {
    if (t < 49152 || t > 65535) throw new Wn(Wr.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${t} given.`, {
        port: t
    });
    return t
}

function D3(t) {
    let e = "",
        n = new Uint8Array(t),
        r = n.byteLength;
    for (let i = 0; i < r; i++) e += String.fromCharCode(n[i]);
    return window.btoa(e)
}

function E3(t) {
    return t.replace(/[/+=]/g, e => ({
        "/": "_",
        "+": "-",
        "=": "."
    })[e])
}
var C3 = "solana-wallet";

function QT(t) {
    return t.replace(/(^\/+|\/+$)/g, "").split("/")
}

function S3(t, e) {
    let n = null;
    if (e) {
        try {
            n = new URL(e)
        } catch {}
        if (n ? .protocol !== "https:") throw new Wn(Wr.ERROR_FORBIDDEN_WALLET_BASE_URL, "Base URLs supplied by wallets must be valid `https` URLs")
    }
    n || (n = new URL(`${C3}:/`));
    let r = t.startsWith("/") ? t : [...QT(n.pathname), ...QT(t)].join("/");
    return new URL(r, n)
}

function M3(t, e, n, r = ["v1"]) {
    return ct(this, void 0, void 0, function*() {
        let i = ex(e),
            s = yield crypto.subtle.exportKey("raw", t), o = D3(s), a = S3("v1/associate/local", n);
        return a.searchParams.set("association", E3(o)), a.searchParams.set("port", `${i}`), r.forEach(c => {
            a.searchParams.set("v", c)
        }), a
    })
}
var bf = {
    Firefox: 0,
    Other: 1
};

function I3() {
    return navigator.userAgent.indexOf("Firefox/") !== -1 ? bf.Firefox : bf.Other
}

function T3() {
    return new Promise((t, e) => {
        function n() {
            clearTimeout(i), window.removeEventListener("blur", r)
        }

        function r() {
            n(), t()
        }
        window.addEventListener("blur", r);
        let i = setTimeout(() => {
            n(), e()
        }, 2e3)
    })
}
var il = null;

function x3(t) {
    il == null && (il = document.createElement("iframe"), il.style.display = "none", document.body.appendChild(il)), il.contentWindow.location.href = t.toString()
}

function A3(t, e) {
    return ct(this, void 0, void 0, function*() {
        let n = b3(),
            r = yield M3(t, n, e);
        if (r.protocol === "https:") window.location.assign(r);
        else try {
            let i = I3();
            switch (i) {
                case bf.Firefox:
                    x3(r);
                    break;
                case bf.Other:
                    {
                        let s = T3();window.location.assign(r),
                        yield s;
                        break
                    }
                default:
            }
        } catch {
            throw new Wn(Wr.ERROR_WALLET_NOT_FOUND, "Found no installed wallet that supports the mobile wallet protocol.")
        }
        return n
    })
}
var qT = {
        retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3],
        timeoutMs: 3e4
    },
    N3 = "com.solana.mobilewalletadapter.v1";

function R3() {
    if (typeof window > "u" || window.isSecureContext !== !0) throw new Wn(Wr.ERROR_SECURE_CONTEXT_REQUIRED, "The mobile wallet adapter protocol must be used in a secure context (`https`).")
}

function O3(t) {
    let e;
    try {
        e = new URL(t)
    } catch {
        throw new Wn(Wr.ERROR_FORBIDDEN_WALLET_BASE_URL, "Invalid base URL supplied by wallet")
    }
    if (e.protocol !== "https:") throw new Wn(Wr.ERROR_FORBIDDEN_WALLET_BASE_URL, "Base URLs supplied by wallets must be valid `https` URLs")
}

function KT(t) {
    return new DataView(t).getUint32(0, !1)
}

function tx(t, e) {
    return ct(this, void 0, void 0, function*() {
        R3();
        let n = yield g3(), r = yield A3(n.publicKey, e ? .baseUri), i = `ws://localhost:${r}/solana-wallet`, s, o = (() => {
            let u = [...qT.retryDelayScheduleMs];
            return () => u.length > 1 ? u.shift() : u[0]
        })(), a = 1, c = 0, l = {
            __type: "disconnected"
        };
        return new Promise((u, d) => {
            let h, f = {},
                p = () => ct(this, void 0, void 0, function*() {
                    if (l.__type !== "connecting") {
                        console.warn(`Expected adapter state to be \`connecting\` at the moment the websocket opens. Got \`${l.__type}\`.`);
                        return
                    }
                    let {
                        associationKeypair: N
                    } = l;
                    h.removeEventListener("open", p);
                    let L = yield m3();
                    h.send(yield r3(L.publicKey, N.privateKey)), l = {
                        __type: "hello_req_sent",
                        associationPublicKey: N.publicKey,
                        ecdhPrivateKey: L.privateKey
                    }
                }),
                g = N => {
                    N.wasClean ? l = {
                        __type: "disconnected"
                    } : d(new Wn(Wr.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${N.code}: ${N.reason}).`, {
                        closeEvent: N
                    })), E()
                },
                m = N => ct(this, void 0, void 0, function*() {
                    E(), Date.now() - s >= qT.timeoutMs ? d(new Wn(Wr.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket on port ${r}.`)) : (yield new Promise(L => {
                        let D = o();
                        T = window.setTimeout(L, D)
                    }), w())
                }),
                y = N => ct(this, void 0, void 0, function*() {
                    let L = yield N.data.arrayBuffer();
                    switch (l.__type) {
                        case "connected":
                            try {
                                let D = L.slice(0, Ss),
                                    j = KT(D);
                                if (j !== c + 1) throw new Error("Encrypted message has invalid sequence number");
                                c = j;
                                let Y = yield v3(L, l.sharedSecret), H = f[Y.id];
                                delete f[Y.id], H.resolve(Y.result)
                            } catch (D) {
                                if (D instanceof _f) {
                                    let j = f[D.jsonRpcMessageId];
                                    delete f[D.jsonRpcMessageId], j.reject(D)
                                } else throw D
                            }
                            break;
                        case "hello_req_sent":
                            {
                                let D = yield w3(L, l.associationPublicKey, l.ecdhPrivateKey), j = L.slice(YT), Y = j.byteLength !== 0 ? yield ct(this, void 0, void 0, function*() {
                                    let G = j.slice(0, Ss),
                                        Ue = KT(G);
                                    if (Ue !== c + 1) throw new Error("Encrypted message has invalid sequence number");
                                    return c = Ue, _3(j, D)
                                }): {
                                    protocol_version: "legacy"
                                };l = {
                                    __type: "connected",
                                    sharedSecret: D,
                                    sessionProperties: Y
                                };
                                let H = c3(Y.protocol_version, (G, Ue) => ct(this, void 0, void 0, function*() {
                                    let qt = a++;
                                    return h.send(yield y3({
                                        id: qt,
                                        jsonrpc: "2.0",
                                        method: G,
                                        params: Ue ? ? {}
                                    }, D)), new Promise((v, A) => {
                                        f[qt] = {
                                            resolve(b) {
                                                switch (G) {
                                                    case "authorize":
                                                    case "reauthorize":
                                                        {
                                                            let {
                                                                wallet_uri_base: F
                                                            } = b;
                                                            if (F != null) try {
                                                                O3(F)
                                                            } catch (V) {
                                                                A(V);
                                                                return
                                                            }
                                                            break
                                                        }
                                                }
                                                v(b)
                                            },
                                            reject: A
                                        }
                                    })
                                }));
                                try {
                                    u(yield t(H))
                                } catch (G) {
                                    d(G)
                                } finally {
                                    E(), h.close()
                                }
                                break
                            }
                    }
                }),
                E, T, w = () => {
                    E && E(), l = {
                        __type: "connecting",
                        associationKeypair: n
                    }, s === void 0 && (s = Date.now()), h = new WebSocket(i, [N3]), h.addEventListener("open", p), h.addEventListener("close", g), h.addEventListener("error", m), h.addEventListener("message", y), E = () => {
                        window.clearTimeout(T), h.removeEventListener("open", p), h.removeEventListener("close", g), h.removeEventListener("error", m), h.removeEventListener("message", y)
                    }
                };
            w()
        })
    })
}
var ax = Hn(sx(), 1);

function D0(t, e) {
    var n = {};
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++) e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (n[r[i]] = t[r[i]]);
    return n
}

function Df(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        })
    }
    return new(n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                l(r.next(u))
            } catch (d) {
                o(d)
            }
        }

        function c(u) {
            try {
                l(r.throw(u))
            } catch (d) {
                o(d)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(a, c)
        }
        l((r = r.apply(t, e || [])).next())
    })
}

function cx(t) {
    return window.btoa(String.fromCharCode.call(null, ...t))
}

function E0(t) {
    return new Uint8Array(window.atob(t).split("").map(e => e.charCodeAt(0)))
}

function ox(t) {
    let e = "version" in t ? t.serialize() : t.serialize({
        requireAllSignatures: !1,
        verifySignatures: !1
    });
    return cx(e)
}

function L3(t) {
    let n = t[0] * K0 + 1;
    return Y0.deserializeMessageVersion(t.slice(n, t.length)) === "legacy" ? hn.from(t) : Os.deserialize(t)
}

function lx(t, e) {
    return Df(this, void 0, void 0, function*() {
        return yield tx(r => {
            let i = new Proxy({}, {
                get(s, o) {
                    if (s[o] == null) switch (o) {
                        case "signAndSendTransactions":
                            s[o] = function(a) {
                                var {
                                    minContextSlot: c,
                                    commitment: l,
                                    skipPreflight: u,
                                    maxRetries: d,
                                    waitForCommitmentToSendNextTransaction: h,
                                    transactions: f
                                } = a, p = D0(a, ["minContextSlot", "commitment", "skipPreflight", "maxRetries", "waitForCommitmentToSendNextTransaction", "transactions"]);
                                return Df(this, void 0, void 0, function*() {
                                    let g = f.map(ox),
                                        m = {
                                            min_context_slot: c,
                                            commitment: l,
                                            skip_preflight: u,
                                            max_retries: d,
                                            wait_for_commitment_to_send_next_transaction: h
                                        },
                                        {
                                            signatures: y
                                        } = yield r.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, p), Object.values(m).some(T => T != null) ? {
                                            options: m
                                        } : null), {
                                            payloads: g
                                        }));
                                    return y.map(E0).map(ax.default.encode)
                                })
                            };
                            break;
                        case "signMessages":
                            s[o] = function(a) {
                                var {
                                    payloads: c
                                } = a, l = D0(a, ["payloads"]);
                                return Df(this, void 0, void 0, function*() {
                                    let u = c.map(cx),
                                        {
                                            signed_payloads: d
                                        } = yield r.signMessages(Object.assign(Object.assign({}, l), {
                                            payloads: u
                                        }));
                                    return d.map(E0)
                                })
                            };
                            break;
                        case "signTransactions":
                            s[o] = function(a) {
                                var {
                                    transactions: c
                                } = a, l = D0(a, ["transactions"]);
                                return Df(this, void 0, void 0, function*() {
                                    let u = c.map(ox),
                                        {
                                            signed_payloads: d
                                        } = yield r.signTransactions(Object.assign(Object.assign({}, l), {
                                            payloads: u
                                        }));
                                    return d.map(E0).map(L3)
                                })
                            };
                            break;
                        default:
                            {
                                s[o] = r[o];
                                break
                            }
                    }
                    return s[o]
                },
                defineProperty() {
                    return !1
                },
                deleteProperty() {
                    return !1
                }
            });
            return t(i)
        }, e)
    })
}

function be(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        })
    }
    return new(n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                l(r.next(u))
            } catch (d) {
                o(d)
            }
        }

        function c(u) {
            try {
                l(r.throw(u))
            } catch (d) {
                o(d)
            }
        }

        function l(u) {
            u.done ? s(u.value) : i(u.value).then(a, c)
        }
        l((r = r.apply(t, e || [])).next())
    })
}

function Ef(t) {
    return new Uint8Array(window.atob(t).split("").map(e => e.charCodeAt(0)))
}

function V3() {
    return typeof window < "u" && window.isSecureContext && typeof document < "u" && /android/i.test(navigator.userAgent)
}
var Sf = "Mobile Wallet Adapter",
    U3 = 64;

function j3(t) {
    let e = Ef(t);
    return new me(e)
}

function ux(t) {
    return "version" in t
}
var Cf = class extends gf {
    constructor(e) {
        var n;
        super(), this.supportedTransactionVersions = new Set(["legacy", 0]), this.name = Sf, this.url = "https://solanamobile.com/wallets", this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==", this._connecting = !1, this._connectionGeneration = 0, this._readyState = V3() ? _e.Loadable : _e.Unsupported, this._authorizationResultCache = e.authorizationResultCache, this._addressSelector = e.addressSelector, this._appIdentity = e.appIdentity, this._chain = (n = e.chain) !== null && n !== void 0 ? n : e.cluster, this._onWalletNotFound = e.onWalletNotFound, this._readyState !== _e.Unsupported && this._authorizationResultCache.get().then(r => {
            r && this.declareWalletAsInstalled()
        })
    }
    get publicKey() {
        if (this._publicKey == null && this._selectedAddress != null) try {
            this._publicKey = j3(this._selectedAddress)
        } catch (e) {
            throw new xi(e instanceof Error && e ? .message || "Unknown error", e)
        }
        return this._publicKey ? this._publicKey : null
    }
    get connected() {
        return !!this._authorizationResult
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    declareWalletAsInstalled() {
        this._readyState !== _e.Installed && this.emit("readyStateChange", this._readyState = _e.Installed)
    }
    runWithGuard(e) {
        return be(this, void 0, void 0, function*() {
            try {
                return yield e()
            } catch (n) {
                throw this.emit("error", n), n
            }
        })
    }
    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
        return be(this, void 0, void 0, function*() {
            return yield this.autoConnect()
        })
    }
    autoConnect() {
        return be(this, void 0, void 0, function*() {
            if (!(this.connecting || this.connected)) return yield this.runWithGuard(() => be(this, void 0, void 0, function*() {
                if (this._readyState !== _e.Installed && this._readyState !== _e.Loadable) throw new Gt;
                this._connecting = !0;
                try {
                    let e = yield this._authorizationResultCache.get();
                    e && this.handleAuthorizationResult(e)
                } catch (e) {
                    throw new ln(e instanceof Error && e.message || "Unknown error", e)
                } finally {
                    this._connecting = !1
                }
            }))
        })
    }
    connect() {
        return be(this, void 0, void 0, function*() {
            if (!(this.connecting || this.connected)) return yield this.runWithGuard(() => be(this, void 0, void 0, function*() {
                if (this._readyState !== _e.Installed && this._readyState !== _e.Loadable) throw new Gt;
                this._connecting = !0;
                try {
                    yield this.performAuthorization()
                } catch (e) {
                    throw new ln(e instanceof Error && e.message || "Unknown error", e)
                } finally {
                    this._connecting = !1
                }
            }))
        })
    }
    performAuthorization(e) {
        return be(this, void 0, void 0, function*() {
            try {
                let n = yield this._authorizationResultCache.get();
                return n ? (this.handleAuthorizationResult(n), n) : yield this.transact(r => be(this, void 0, void 0, function*() {
                    let i = yield r.authorize({
                        chain: this._chain,
                        identity: this._appIdentity,
                        sign_in_payload: e
                    });
                    return Promise.all([this._authorizationResultCache.set(i), this.handleAuthorizationResult(i)]), i
                }))
            } catch (n) {
                throw new ln(n instanceof Error && n.message || "Unknown error", n)
            }
        })
    }
    handleAuthorizationResult(e) {
        var n;
        return be(this, void 0, void 0, function*() {
            let r = this._authorizationResult == null || ((n = this._authorizationResult) === null || n === void 0 ? void 0 : n.accounts.length) !== e.accounts.length || this._authorizationResult.accounts.some((i, s) => i.address !== e.accounts[s].address);
            if (this._authorizationResult = e, this.declareWalletAsInstalled(), r) {
                let i = yield this._addressSelector.select(e.accounts.map(({
                    address: s
                }) => s));
                i !== this._selectedAddress && (this._selectedAddress = i, delete this._publicKey, this.emit("connect", this.publicKey))
            }
        })
    }
    performReauthorization(e, n) {
        return be(this, void 0, void 0, function*() {
            try {
                let r = yield e.authorize({
                    auth_token: n,
                    identity: this._appIdentity
                });
                Promise.all([this._authorizationResultCache.set(r), this.handleAuthorizationResult(r)])
            } catch (r) {
                throw this.disconnect(), new mr(r instanceof Error && r ? .message || "Unknown error", r)
            }
        })
    }
    disconnect() {
        return be(this, void 0, void 0, function*() {
            this._authorizationResultCache.clear(), this._connecting = !1, this._connectionGeneration++, delete this._authorizationResult, delete this._publicKey, delete this._selectedAddress, this.emit("disconnect")
        })
    }
    transact(e) {
        var n;
        return be(this, void 0, void 0, function*() {
            let r = (n = this._authorizationResult) === null || n === void 0 ? void 0 : n.wallet_uri_base,
                i = r ? {
                    baseUri: r
                } : void 0,
                s = this._connectionGeneration;
            try {
                return yield lx(e, i)
            } catch (o) {
                throw this._connectionGeneration !== s && (yield new Promise(() => {})), o instanceof Error && o.name === "SolanaMobileWalletAdapterError" && o.code === "ERROR_WALLET_NOT_FOUND" && (yield this._onWalletNotFound(this)), o
            }
        })
    }
    assertIsAuthorized() {
        if (!this._authorizationResult || !this._selectedAddress) throw new Ve;
        return {
            authToken: this._authorizationResult.auth_token,
            selectedAddress: this._selectedAddress
        }
    }
    performSignTransactions(e) {
        return be(this, void 0, void 0, function*() {
            let {
                authToken: n
            } = this.assertIsAuthorized();
            try {
                return yield this.transact(r => be(this, void 0, void 0, function*() {
                    return yield this.performReauthorization(r, n), yield r.signTransactions({
                        transactions: e
                    })
                }))
            } catch (r) {
                throw new Et(r ? .message, r)
            }
        })
    }
    sendTransaction(e, n, r) {
        return be(this, void 0, void 0, function*() {
            return yield this.runWithGuard(() => be(this, void 0, void 0, function*() {
                let {
                    authToken: i
                } = this.assertIsAuthorized(), s = r ? .minContextSlot;
                try {
                    return yield this.transact(o => be(this, void 0, void 0, function*() {
                        function a() {
                            let d;
                            switch (n.commitment) {
                                case "confirmed":
                                case "finalized":
                                case "processed":
                                    d = n.commitment;
                                    break;
                                default:
                                    d = "finalized"
                            }
                            let h;
                            switch (r ? .preflightCommitment) {
                                case "confirmed":
                                case "finalized":
                                case "processed":
                                    h = r.preflightCommitment;
                                    break;
                                case void 0:
                                    h = d;
                                    break;
                                default:
                                    h = "finalized"
                            }
                            return (h === "finalized" ? 2 : h === "confirmed" ? 1 : 0) < (d === "finalized" ? 2 : d === "confirmed" ? 1 : 0) ? h : d
                        }
                        let [c, l, u] = yield Promise.all([o.getCapabilities(), this.performReauthorization(o, i), ux(e) ? null : be(this, void 0, void 0, function*() {
                            var d;
                            if (e.feePayer || (e.feePayer = (d = this.publicKey) !== null && d !== void 0 ? d : void 0), e.recentBlockhash == null) {
                                let {
                                    blockhash: h
                                } = yield n.getLatestBlockhash({
                                    commitment: a()
                                });
                                e.recentBlockhash = h
                            }
                        })]);
                        if (c.supports_sign_and_send_transactions) return (yield o.signAndSendTransactions({
                            minContextSlot: s,
                            transactions: [e]
                        }))[0]; {
                            let [d] = yield o.signTransactions({
                                transactions: [e]
                            });
                            if (ux(d)) return yield n.sendTransaction(d); {
                                let h = d.serialize();
                                return yield n.sendRawTransaction(h, Object.assign(Object.assign({}, r), {
                                    preflightCommitment: a()
                                }))
                            }
                        }
                    }))
                } catch (o) {
                    throw new Zt(o ? .message, o)
                }
            }))
        })
    }
    signTransaction(e) {
        return be(this, void 0, void 0, function*() {
            return yield this.runWithGuard(() => be(this, void 0, void 0, function*() {
                let [n] = yield this.performSignTransactions([e]);
                return n
            }))
        })
    }
    signAllTransactions(e) {
        return be(this, void 0, void 0, function*() {
            return yield this.runWithGuard(() => be(this, void 0, void 0, function*() {
                return yield this.performSignTransactions(e)
            }))
        })
    }
    signMessage(e) {
        return be(this, void 0, void 0, function*() {
            return yield this.runWithGuard(() => be(this, void 0, void 0, function*() {
                let {
                    authToken: n,
                    selectedAddress: r
                } = this.assertIsAuthorized();
                try {
                    return yield this.transact(i => be(this, void 0, void 0, function*() {
                        yield this.performReauthorization(i, n);
                        let [s] = yield i.signMessages({
                            addresses: [r],
                            payloads: [e]
                        });
                        return s.slice(-U3)
                    }))
                } catch (i) {
                    throw new yr(i ? .message, i)
                }
            }))
        })
    }
    signIn(e) {
        return be(this, void 0, void 0, function*() {
            return yield this.runWithGuard(() => be(this, void 0, void 0, function*() {
                var n, r;
                if (this._readyState !== _e.Installed && this._readyState !== _e.Loadable) throw new Gt;
                this._connecting = !0;
                try {
                    let i = yield this.performAuthorization(Object.assign(Object.assign({}, e), {
                        domain: (n = e ? .domain) !== null && n !== void 0 ? n : window.location.host
                    }));
                    if (!i.sign_in_result) throw new Error("Sign in failed, no sign in result returned by wallet");
                    let s = i.sign_in_result.address;
                    return {
                        account: Object.assign(Object.assign({}, (r = i.accounts.find(a => a.address == s)) !== null && r !== void 0 ? r : {
                            address: s
                        }), {
                            publicKey: Ef(s)
                        }),
                        signedMessage: Ef(i.sign_in_result.signed_message),
                        signature: Ef(i.sign_in_result.signature)
                    }
                } catch (i) {
                    throw new ln(i instanceof Error && i.message || "Unknown error", i)
                } finally {
                    this._connecting = !1
                }
            }))
        })
    }
};

function dx() {
    return {
        select(t) {
            return be(this, void 0, void 0, function*() {
                return t[0]
            })
        }
    }
}
var C0 = "SolanaMobileWalletAdapterDefaultAuthorizationCache";

function hx() {
    let t;
    try {
        t = window.localStorage
    } catch {}
    return {
        clear() {
            return be(this, void 0, void 0, function*() {
                if (t) try {
                    t.removeItem(C0)
                } catch {}
            })
        },
        get() {
            return be(this, void 0, void 0, function*() {
                if (t) try {
                    return JSON.parse(t.getItem(C0)) || void 0
                } catch {}
            })
        },
        set(e) {
            return be(this, void 0, void 0, function*() {
                if (t) try {
                    t.setItem(C0, JSON.stringify(e))
                } catch {}
            })
        }
    }
}

function B3(t) {
    return be(this, void 0, void 0, function*() {
        typeof window < "u" && window.location.assign(t.url)
    })
}

function fx() {
    return B3
}
_r();
var z3, $3, W3, H3, G3, Z3;
z3 = new WeakMap, $3 = new WeakMap, W3 = new WeakMap, H3 = new WeakMap, G3 = new WeakMap, Z3 = new WeakMap;

function px(t, e) {
    if (t === e) return !0;
    let n = t.length;
    if (n !== e.length) return !1;
    for (let r = 0; r < n; r++)
        if (t[r] !== e[r]) return !1;
    return !0
}
var wx = Hn(Q0(), 1);
var tt = function(t, e, n, r, i) {
        if (r === "m") throw new TypeError("Private method is not writable");
        if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n), n
    },
    W = function(t, e, n, r) {
        if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
    },
    Ct, Qt, Is, Ts, Ms, sl, If, De, Tf, S0, Mf, M0, ol, I0, gx, mx, yx, vx, xf = class extends na {
        constructor({
            wallet: e
        }) {
            super(), Ct.add(this), Qt.set(this, void 0), Is.set(this, void 0), Ts.set(this, void 0), Ms.set(this, void 0), sl.set(this, void 0), If.set(this, void 0), De.set(this, void 0), Tf.set(this, typeof window > "u" || typeof document > "u" ? _e.Unsupported : _e.Installed), I0.set(this, n => {
                if ("accounts" in n) {
                    let r = W(this, De, "f").accounts[0];
                    W(this, Qt, "f") && !W(this, Ms, "f") && r !== W(this, Qt, "f") && (r ? W(this, Ct, "m", Mf).call(this, r) : (this.emit("error", new mr), W(this, Ct, "m", M0).call(this)))
                }
                "features" in n && W(this, Ct, "m", ol).call(this)
            }), tt(this, De, e, "f"), tt(this, Qt, null, "f"), tt(this, Is, null, "f"), tt(this, Ts, !1, "f"), tt(this, Ms, !1, "f"), tt(this, sl, W(this, De, "f").features[vf].on("change", W(this, I0, "f")), "f"), W(this, Ct, "m", ol).call(this)
        }
        get name() {
            return W(this, De, "f").name
        }
        get url() {
            return "https://github.com/solana-labs/wallet-standard"
        }
        get icon() {
            return W(this, De, "f").icon
        }
        get readyState() {
            return W(this, Tf, "f")
        }
        get publicKey() {
            return W(this, Is, "f")
        }
        get connecting() {
            return W(this, Ts, "f")
        }
        get supportedTransactionVersions() {
            return W(this, If, "f")
        }
        get wallet() {
            return W(this, De, "f")
        }
        get standard() {
            return !0
        }
        destroy() {
            tt(this, Qt, null, "f"), tt(this, Is, null, "f"), tt(this, Ts, !1, "f"), tt(this, Ms, !1, "f");
            let e = W(this, sl, "f");
            e && (tt(this, sl, null, "f"), e())
        }
        autoConnect() {
            return x(this, null, function*() {
                return W(this, Ct, "m", S0).call(this, {
                    silent: !0
                })
            })
        }
        connect() {
            return x(this, null, function*() {
                return W(this, Ct, "m", S0).call(this)
            })
        }
        disconnect() {
            return x(this, null, function*() {
                if (v0 in W(this, De, "f").features) try {
                    tt(this, Ms, !0, "f"), yield W(this, De, "f").features[v0].disconnect()
                } catch (e) {
                    this.emit("error", new Ti(e ? .message, e))
                } finally {
                    tt(this, Ms, !1, "f")
                }
                W(this, Ct, "m", M0).call(this)
            })
        }
        sendTransaction(i, s) {
            return x(this, arguments, function*(e, n, r = {}) {
                try {
                    let a = W(this, Qt, "f");
                    if (!a) throw new Ve;
                    let c;
                    if (vr in W(this, De, "f").features)
                        if (a.features.includes(vr)) c = vr;
                        else if (at in W(this, De, "f").features && a.features.includes(at)) c = at;
                    else throw new $n;
                    else if (at in W(this, De, "f").features) {
                        if (!a.features.includes(at)) throw new $n;
                        c = at
                    } else throw new Ii;
                    let l = HT(n.rpcEndpoint);
                    if (!a.chains.includes(l)) throw new Zt;
                    try {
                        let o = r,
                            {
                                signers: u
                            } = o,
                            d = Tn(o, ["signers"]),
                            h;
                        if ($r(e) ? (u ? .length && e.sign(u), h = e.serialize()) : (e = yield this.prepareTransaction(e, n, d), u ? .length && e.partialSign(...u), h = new Uint8Array(e.serialize({
                                requireAllSignatures: !1,
                                verifySignatures: !1
                            }))), c === vr) {
                            let [f] = yield W(this, De, "f").features[vr].signAndSendTransaction({
                                account: a,
                                chain: l,
                                transaction: h,
                                options: {
                                    preflightCommitment: wf(d.preflightCommitment || n.commitment),
                                    skipPreflight: d.skipPreflight,
                                    maxRetries: d.maxRetries,
                                    minContextSlot: d.minContextSlot
                                }
                            });
                            return wx.default.encode(f.signature)
                        } else {
                            let [f] = yield W(this, De, "f").features[at].signTransaction({
                                account: a,
                                chain: l,
                                transaction: h,
                                options: {
                                    preflightCommitment: wf(d.preflightCommitment || n.commitment),
                                    minContextSlot: d.minContextSlot
                                }
                            });
                            return yield n.sendRawTransaction(f.signedTransaction, Q(_({}, d), {
                                preflightCommitment: wf(d.preflightCommitment || n.commitment)
                            }))
                        }
                    } catch (u) {
                        throw u instanceof Ge ? u : new Zt(u ? .message, u)
                    }
                } catch (a) {
                    throw this.emit("error", a), a
                }
            })
        }
    };
Qt = new WeakMap, Is = new WeakMap, Ts = new WeakMap, Ms = new WeakMap, sl = new WeakMap, If = new WeakMap, De = new WeakMap, Tf = new WeakMap, I0 = new WeakMap, Ct = new WeakSet, S0 = function(e) {
    return x(this, null, function*() {
        try {
            if (this.connected || this.connecting) return;
            if (W(this, Tf, "f") !== _e.Installed) throw new Gt;
            if (tt(this, Ts, !0, "f"), !W(this, De, "f").accounts.length) try {
                yield W(this, De, "f").features[yf].connect(e)
            } catch (r) {
                throw new ln(r ? .message, r)
            }
            let n = W(this, De, "f").accounts[0];
            if (!n) throw new $n;
            W(this, Ct, "m", Mf).call(this, n)
        } catch (n) {
            throw this.emit("error", n), n
        } finally {
            tt(this, Ts, !1, "f")
        }
    })
}, Mf = function(e) {
    let n;
    try {
        n = new me(e.address)
    } catch (r) {
        throw new xi(r ? .message, r)
    }
    tt(this, Qt, e, "f"), tt(this, Is, n, "f"), W(this, Ct, "m", ol).call(this), this.emit("connect", n)
}, M0 = function() {
    tt(this, Qt, null, "f"), tt(this, Is, null, "f"), W(this, Ct, "m", ol).call(this), this.emit("disconnect")
}, ol = function() {
    let e = vr in W(this, De, "f").features ? W(this, De, "f").features[vr].supportedTransactionVersions : W(this, De, "f").features[at].supportedTransactionVersions;
    tt(this, If, px(e, ["legacy"]) ? null : new Set(e), "f"), at in W(this, De, "f").features && W(this, Qt, "f") ? .features.includes(at) ? (this.signTransaction = W(this, Ct, "m", gx), this.signAllTransactions = W(this, Ct, "m", mx)) : (delete this.signTransaction, delete this.signAllTransactions), ra in W(this, De, "f").features && W(this, Qt, "f") ? .features.includes(ra) ? this.signMessage = W(this, Ct, "m", yx) : delete this.signMessage, mf in W(this, De, "f").features ? this.signIn = W(this, Ct, "m", vx) : delete this.signIn
}, gx = function(e) {
    return x(this, null, function*() {
        try {
            let n = W(this, Qt, "f");
            if (!n) throw new Ve;
            if (!(at in W(this, De, "f").features)) throw new Ii;
            if (!n.features.includes(at)) throw new $n;
            try {
                let i = (yield W(this, De, "f").features[at].signTransaction({
                    account: n,
                    transaction: $r(e) ? e.serialize() : new Uint8Array(e.serialize({
                        requireAllSignatures: !1,
                        verifySignatures: !1
                    }))
                }))[0].signedTransaction;
                return $r(e) ? Os.deserialize(i) : hn.from(i)
            } catch (r) {
                throw r instanceof Ge ? r : new Et(r ? .message, r)
            }
        } catch (n) {
            throw this.emit("error", n), n
        }
    })
}, mx = function(e) {
    return x(this, null, function*() {
        try {
            let n = W(this, Qt, "f");
            if (!n) throw new Ve;
            if (!(at in W(this, De, "f").features)) throw new Ii;
            if (!n.features.includes(at)) throw new $n;
            try {
                let r = yield W(this, De, "f").features[at].signTransaction(...e.map(i => ({
                    account: n,
                    transaction: $r(i) ? i.serialize() : new Uint8Array(i.serialize({
                        requireAllSignatures: !1,
                        verifySignatures: !1
                    }))
                })));
                return e.map((i, s) => {
                    let o = r[s].signedTransaction;
                    return $r(i) ? Os.deserialize(o) : hn.from(o)
                })
            } catch (r) {
                throw new Et(r ? .message, r)
            }
        } catch (n) {
            throw this.emit("error", n), n
        }
    })
}, yx = function(e) {
    return x(this, null, function*() {
        try {
            let n = W(this, Qt, "f");
            if (!n) throw new Ve;
            if (!(ra in W(this, De, "f").features)) throw new Ii;
            if (!n.features.includes(ra)) throw new $n;
            try {
                return (yield W(this, De, "f").features[ra].signMessage({
                    account: n,
                    message: e
                }))[0].signature
            } catch (r) {
                throw new yr(r ? .message, r)
            }
        } catch (n) {
            throw this.emit("error", n), n
        }
    })
}, vx = function() {
    return x(this, arguments, function*(e = {}) {
        try {
            if (!(mf in W(this, De, "f").features)) throw new Ii;
            let n;
            try {
                [n] = yield W(this, De, "f").features[mf].signIn(e)
            } catch (r) {
                throw new el(r ? .message, r)
            }
            if (!n) throw new el;
            return W(this, Ct, "m", Mf).call(this, n.account), n
        } catch (n) {
            throw this.emit("error", n), n
        }
    })
};
var Q3 = function(t, e, n, r, i) {
        if (r === "m") throw new TypeError("Private method is not writable");
        if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return r === "a" ? i.call(t, n) : i ? i.value = n : e.set(t, n), n
    },
    q3 = function(t, e, n, r) {
        if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? t !== e || !r : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return n === "m" ? r : n === "a" ? r.call(t) : r ? r.value : e.get(t)
    },
    Af, un, Nf = new Set,
    ia = {};

function K3() {
    if (un || (un = Object.freeze({
            register: _x,
            get: Y3,
            on: J3
        }), typeof window > "u")) return un;
    let t = Object.freeze({
        register: _x
    });
    try {
        window.addEventListener("wallet-standard:register-wallet", ({
            detail: e
        }) => e(t))
    } catch (e) {
        console.error(`wallet-standard:register-wallet event listener could not be added
`, e)
    }
    try {
        window.dispatchEvent(new x0(t))
    } catch (e) {
        console.error(`wallet-standard:app-ready event could not be dispatched
`, e)
    }
    return un
}

function _x(...t) {
    return t = t.filter(e => !Nf.has(e)), t.length ? (t.forEach(e => Nf.add(e)), ia.register ? .forEach(e => T0(() => e(...t))), function() {
        t.forEach(n => Nf.delete(n)), ia.unregister ? .forEach(n => T0(() => n(...t)))
    }) : () => {}
}

function Y3() {
    return [...Nf]
}

function J3(t, e) {
    return ia[t] ? .push(e) || (ia[t] = [e]),
        function() {
            ia[t] = ia[t] ? .filter(r => e !== r)
        }
}

function T0(t) {
    try {
        t()
    } catch (e) {
        console.error(e)
    }
}
var x0 = class extends Event {
    constructor(e) {
        super("wallet-standard:app-ready", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }), Af.set(this, void 0), Q3(this, Af, e, "f")
    }
    get detail() {
        return q3(this, Af, "f")
    }
    get type() {
        return "wallet-standard:app-ready"
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
};
Af = new WeakMap;

function bx() {
    if (un || (un = K3(), typeof window > "u")) return un;
    let t = window.navigator.wallets || [];
    if (!Array.isArray(t)) return console.error("window.navigator.wallets is not an array"), un;
    let {
        register: e
    } = un, n = (...r) => r.forEach(i => T0(() => i({
        register: e
    })));
    try {
        Object.defineProperty(window.navigator, "wallets", {
            value: Object.freeze({
                push: n
            })
        })
    } catch {
        return console.error("window.navigator.wallets could not be set"), un
    }
    return n(...t), un
}
var Of = class extends Ge {
        constructor() {
            super(...arguments), this.name = "WalletNotSelectedError"
        }
    },
    Rf = (t, e) => fa(n => t.on(e, n), n => t.off(e, n)),
    al = function(t) {
        return t[t.DESKTOP_WEB = 0] = "DESKTOP_WEB", t[t.MOBILE_WEB = 1] = "MOBILE_WEB", t
    }(al || {});

function X3(t) {
    return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(t)
}

function eW({
    adapters: t,
    userAgentString: e
}) {
    return t.some(n => n.name !== Sf && n.readyState === _e.Installed) ? al.DESKTOP_WEB : e && /android/i.test(e) && !X3(e) ? al.MOBILE_WEB : al.DESKTOP_WEB
}

function tW(t) {
    return t ? /devnet/i.test(t) ? "devnet" : /testnet/i.test(t) ? "testnet" : "mainnet-beta" : "mainnet-beta"
}
var A0;

function nW() {
    return A0 === void 0 && (A0 = globalThis.navigator ? .userAgent ? ? null), A0
}

function rW(t) {
    let e = nW();
    return eW({
        adapters: t,
        userAgentString: e
    }) === al.MOBILE_WEB
}

function iW() {
    let t = globalThis.location;
    if (t) return `${t.protocol}//${t.host}`
}
var N0 = t => e => e.pipe(Je(n => n === null ? k(null) : t(n))),
    sW = t => t.pipe(Fe(e => e != null)),
    oW = t => {
        try {
            let e = localStorage.getItem(t);
            return e ? JSON.parse(e) : null
        } catch (e) {
            typeof window < "u" && console.error(e)
        }
        return null
    },
    R0 = class extends Ze {
        constructor(e) {
            super(oW(e)), this._key = e
        }
        next(e) {
            try {
                e === null ? localStorage.removeItem(this._key) : localStorage.setItem(this._key, JSON.stringify(e))
            } catch (n) {
                typeof window < "u" && console.error(n)
            }
            super.next(e)
        }
    },
    aW = (t, e, n) => r => e ? le(mt(() => t.signMessage(r))) : Qe(() => n(new Ve)),
    Dx = (t, e, n) => r => e ? le(mt(() => t.signTransaction(r))) : Qe(() => n(new Ve)),
    Ex = (t, e, n) => r => e ? le(mt(() => t.signAllTransactions(r))) : Qe(() => n(new Ve)),
    cW = (t, e, n) => r => e ? le(mt(() => t.signIn(r))) : Qe(() => n(new Ve)),
    Ix = new R("connectionConfig"),
    lW = (t = {}) => ({
        provide: Ix,
        useValue: _({
            commitment: "confirmed"
        }, t)
    }),
    Tx = (() => {
        let e = class e extends hf {
            constructor(r) {
                super({
                    connection: null,
                    endpoint: null
                }), this._config = r, this._endpoint$ = this.select(this.state$, ({
                    endpoint: i
                }) => i), this.connection$ = this.select(this.state$, ({
                    connection: i
                }) => i), this.setEndpoint = this.updater((i, s) => Q(_({}, i), {
                    endpoint: s
                })), this.onEndpointChange = this.effect(() => this._endpoint$.pipe(sW, ve(i => this.patchState({
                    connection: new pl(i, this._config)
                }))))
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(Ix, 8))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })();

function Cx(t) {
    return t.filter(BT).map(e => new xf({
        wallet: e
    }))
}

function Sx(t, e) {
    return fa(n => t.on(e, (...r) => n(r)), n => n())
}
var xx = (() => {
        let e = class e extends hf {
            constructor() {
                super(), this._standardWallets = bx(), this._standardAdapters$ = this.select(({
                    standardAdapters: i
                }) => i), this._adapters$ = this.select(({
                    adapters: i
                }) => i), this.adapters$ = this.select(this._adapters$, this._standardAdapters$, (i, s) => [...s, ...i.filter(({
                    name: o
                }) => !s.some(a => a.name === o))]), this.warnings$ = this.select(this._adapters$, this._standardAdapters$, (i, s) => [...i.filter(({
                    name: o
                }) => s.some(a => a.name === o)).map(({
                    name: o
                }) => o)]), this._addStandardAdapters = this.updater((i, s) => Q(_({}, i), {
                    standardAdapters: [...i.standardAdapters, ...Cx(s)]
                })), this._removeStandardAdapters = this.updater((i, s) => Q(_({}, i), {
                    standardAdapters: i.standardAdapters.filter(o => s.some(a => a === o.wallet))
                })), this.setAdapters = this.updater((i, s) => Q(_({}, i), {
                    adapters: s
                })), this._handleStandardAdaptersChange = this.effect(ve(([i, s]) => {
                    let o = new Set(s);
                    new Set(i.filter(c => !o.has(c))).forEach(c => c.destroy())
                }));
                let r = Cx(this._standardWallets.get());
                r.forEach(i => i.destroy()), this.setState({
                    adapters: [],
                    standardAdapters: r
                }), this._addStandardAdapters(Sx(this._standardWallets, "register")), this._removeStandardAdapters(Sx(this._standardWallets, "unregister")), this._handleStandardAdaptersChange(this._standardAdapters$.pipe(ql()))
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    O0 = new R("walletConfig"),
    uW = t => ({
        provide: O0,
        useValue: _({
            autoConnect: !1,
            localStorageKey: "walletName",
            adapters: []
        }, t ? ? {})
    }),
    Mx = {
        wallet: null,
        adapter: null,
        connected: !1,
        publicKey: null,
        readyState: null
    },
    xs = (() => {
        let e = class e extends hf {
            constructor(r) {
                super(Q(_({}, Mx), {
                    wallets: [],
                    adapters: [],
                    connecting: !1,
                    disconnecting: !1,
                    unloading: !1,
                    autoConnect: r.autoConnect || !1,
                    readyState: null,
                    error: null
                })), this._config = r, this._name = new R0(this._config.localStorageKey), this._unloading$ = this.select(({
                    unloading: i
                }) => i), this._adapters$ = this.select(({
                    adapters: i
                }) => i), this._adapter$ = this.select(({
                    adapter: i
                }) => i), this._name$ = this._name.asObservable(), this._readyState$ = this.select(({
                    readyState: i
                }) => i), this.autoConnect$ = this.select(({
                    autoConnect: i
                }) => i), this.wallets$ = this.select(({
                    wallets: i
                }) => i), this.wallet$ = this.select(({
                    wallet: i
                }) => i), this.publicKey$ = this.select(({
                    publicKey: i
                }) => i), this.connecting$ = this.select(({
                    connecting: i
                }) => i), this.connected$ = this.select(({
                    connected: i
                }) => i), this.disconnecting$ = this.select(({
                    disconnecting: i
                }) => i), this.error$ = this.select(({
                    error: i
                }) => i), this.anchorWallet$ = this.select(this.publicKey$, this._adapter$, this.connected$, (i, s, o) => i && s && "signTransaction" in s && "signAllTransactions" in s ? {
                    publicKey: i,
                    signTransaction: a => Hl(Dx(s, o, c => this._setError(c))(a)),
                    signAllTransactions: a => Hl(Ex(s, o, c => this._setError(c))(a))
                } : void 0, {
                    debounce: !0
                }), this._setError = this.updater((i, s) => Q(_({}, i), {
                    error: i.unloading ? i.error : s
                })), this._setReadyState = this.updater((i, {
                    readyState: s,
                    walletName: o
                }) => Q(_({}, i), {
                    wallets: i.wallets.map(a => a.adapter.name === o ? Q(_({}, a), {
                        readyState: s
                    }) : a),
                    readyState: i.adapter ? .name === o ? s : i.readyState
                })), this.setAdapters = this.updater((i, s) => Q(_({}, i), {
                    adapters: s,
                    wallets: s.map(o => ({
                        adapter: o,
                        readyState: o.readyState
                    }))
                })), this.onAdapterChangeDisconnectPreviousAdapter = this.effect(() => this._adapter$.pipe(ql(), nt(([i]) => i && i.connected ? le(mt(() => i.disconnect())) : k(null)))), this.onWalletChanged = this.effect(() => Ot([this._name$, this.wallets$]).pipe(ve(([i, s]) => {
                    let o = s.find(({
                        adapter: a
                    }) => a.name === i);
                    o ? this.patchState({
                        wallet: o,
                        adapter: o.adapter,
                        connected: o.adapter.connected,
                        publicKey: o.adapter.publicKey,
                        readyState: o.adapter.readyState
                    }) : this.patchState(Mx)
                }))), this.onAutoConnect = this.effect(() => Ot([this._adapter$, this._readyState$, this.autoConnect$, this.connecting$, this.connected$]).pipe(nt(([i, s, o, a, c]) => !o || i == null || s !== _e.Installed && s !== _e.Loadable || a || c ? Ye : (this.patchState({
                    connecting: !0
                }), le(mt(() => i.connect())).pipe(yt(() => (this.selectWallet(null), Ye)), Ft(() => this.patchState({
                    connecting: !1
                }))))))), this.onWindowUnload = this.effect(() => typeof window > "u" ? k(null) : qn(window, "beforeunload").pipe(ve(() => this.patchState({
                    unloading: !0
                })))), this.onConnect = this.effect(() => this._adapter$.pipe(N0(i => Rf(i, "connect").pipe(ve(() => this.patchState({
                    connected: i.connected,
                    publicKey: i.publicKey
                })))))), this.onDisconnect = this.effect(() => this._adapter$.pipe(N0(i => Rf(i, "disconnect").pipe(nt(() => k(null).pipe(Qs(this._unloading$))), Fe(([, s]) => !s), ve(() => this.selectWallet(null)))))), this.onError = this.effect(() => this._adapter$.pipe(N0(i => Rf(i, "error").pipe(ve(s => this._setError(s)))))), this.onReadyStateChanges = this.effect(() => this._adapters$.pipe(Je(i => Hs(...i.map(s => Rf(s, "readyStateChange").pipe(ve(o => this._setReadyState({
                    readyState: o,
                    walletName: s.name
                })))))))), this.setAdapters(this._config.adapters)
            }
            selectWallet(r) {
                this._name.next(r)
            }
            connect() {
                return Ot([this.connecting$, this.disconnecting$, this.connected$, this._adapter$, this._readyState$]).pipe(kt(), Fe(([r, i, s]) => !s && !r && !i), nt(([, , , r, i]) => {
                    if (!r) {
                        let s = new Of;
                        return this._setError(s), Qe(() => s)
                    }
                    if (!(i === _e.Installed || i === _e.Loadable)) {
                        this.selectWallet(null), typeof window < "u" && window.open(r.url, "_blank");
                        let s = new Gt;
                        return this._setError(s), Qe(() => s)
                    }
                    return this.patchState({
                        connecting: !0
                    }), le(mt(() => r.connect())).pipe(yt(s => (this.selectWallet(null), Qe(() => s))), Ft(() => this.patchState({
                        connecting: !1
                    })))
                }))
            }
            disconnect() {
                return Ot([this.disconnecting$, this._adapter$]).pipe(kt(), Fe(([r]) => !r), nt(([, r]) => r ? (this.patchState({
                    disconnecting: !0
                }), le(mt(() => r.disconnect())).pipe(yt(i => (this.selectWallet(null), Qe(() => i))), Ft(() => {
                    this.patchState({
                        disconnecting: !1
                    })
                }))) : (this.selectWallet(null), Ye)))
            }
            sendTransaction(r, i, s) {
                return Ot([this._adapter$, this.connected$]).pipe(kt(), nt(([o, a]) => {
                    if (!o) {
                        let c = new Of;
                        return this._setError(c), Qe(() => c)
                    }
                    if (!a) {
                        let c = new Ve;
                        return this._setError(c), Qe(() => c)
                    }
                    return le(mt(() => o.sendTransaction(r, i, s)))
                }))
            }
            signTransaction(r) {
                let {
                    adapter: i,
                    connected: s
                } = this.get();
                return i && "signTransaction" in i ? Dx(i, s, o => this._setError(o))(r) : void 0
            }
            signAllTransactions(r) {
                let {
                    adapter: i,
                    connected: s
                } = this.get();
                return i && "signAllTransactions" in i ? Ex(i, s, o => this._setError(o))(r) : void 0
            }
            signMessage(r) {
                let {
                    adapter: i,
                    connected: s
                } = this.get();
                return i && "signMessage" in i ? aW(i, s, o => this._setError(o))(r) : void 0
            }
            signIn(r) {
                let {
                    adapter: i,
                    connected: s
                } = this.get();
                return i && "signIn" in i ? cW(i, s, o => this._setError(o))(r) : void 0
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(C(O0))
        }, e.\u0275prov = I({
            token: e,
            factory: e.\u0275fac
        });
        let t = e;
        return t
    })(),
    dW = {
        provide: xs,
        useFactory: (t, e, n) => {
            let r = Ot([t.connection$, e.adapters$]).pipe(Z(([o, a]) => {
                    if (!rW(a)) return null;
                    let c = a.find(l => l.name === Sf);
                    return c || new Cf({
                        addressSelector: dx(),
                        appIdentity: {
                            uri: iW()
                        },
                        authorizationResultCache: hx(),
                        cluster: tW(o ? .rpcEndpoint),
                        onWalletNotFound: fx()
                    })
                })),
                i = Ot([r, e.adapters$]).pipe(Z(([o, a]) => o == null || a.indexOf(o) !== -1 ? a : [o, ...a])),
                s = new xs(n);
            return s.setAdapters(i), s
        },
        deps: [Tx, xx, O0]
    };

function Ax() {
    let t = M(xs);
    return Cs(t.connected$, {
        initialValue: !1
    })
}

function Nx() {
    let t = M(xs);
    return Cs(t.publicKey$, {
        initialValue: null
    })
}

function Rx() {
    let t = M(xs);
    return Cs(t.wallets$, {
        initialValue: []
    })
}
var Ox = (() => {
    let e = class e {
        static forRoot(r, i) {
            return {
                ngModule: e,
                providers: [uW(r), lW(i), y0(Tx), y0(xx), dW]
            }
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275mod = xe({
        type: e
    }), e.\u0275inj = Te({});
    let t = e;
    return t
})();
var hW = "WalletConnect",
    Ff = class extends tl {
        constructor(e) {
            super(), this.name = hW, this.url = "https://walletconnect.org", this.icon = "data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjE4NSIgdmlld0JveD0iMCAwIDMwMCAxODUiIHdpZHRoPSIzMDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTYxLjQzODU0MjkgMzYuMjU2MjYxMmM0OC45MTEyMjQxLTQ3Ljg4ODE2NjMgMTI4LjIxMTk4NzEtNDcuODg4MTY2MyAxNzcuMTIzMjA5MSAwbDUuODg2NTQ1IDUuNzYzNDE3NGMyLjQ0NTU2MSAyLjM5NDQwODEgMi40NDU1NjEgNi4yNzY1MTEyIDAgOC42NzA5MjA0bC0yMC4xMzY2OTUgMTkuNzE1NTAzYy0xLjIyMjc4MSAxLjE5NzIwNTEtMy4yMDUzIDEuMTk3MjA1MS00LjQyODA4MSAwbC04LjEwMDU4NC03LjkzMTE0NzljLTM0LjEyMTY5Mi0zMy40MDc5ODE3LTg5LjQ0Mzg4Ni0zMy40MDc5ODE3LTEyMy41NjU1Nzg4IDBsLTguNjc1MDU2MiA4LjQ5MzYwNTFjLTEuMjIyNzgxNiAxLjE5NzIwNDEtMy4yMDUzMDEgMS4xOTcyMDQxLTQuNDI4MDgwNiAwbC0yMC4xMzY2OTQ5LTE5LjcxNTUwMzFjLTIuNDQ1NTYxMi0yLjM5NDQwOTItMi40NDU1NjEyLTYuMjc2NTEyMiAwLTguNjcwOTIwNHptMjE4Ljc2Nzc5NjEgNDAuNzczNzQ0OSAxNy45MjE2OTcgMTcuNTQ2ODk3YzIuNDQ1NTQ5IDIuMzk0Mzk2OSAyLjQ0NTU2MyA2LjI3NjQ3NjkuMDAwMDMxIDguNjcwODg5OWwtODAuODEwMTcxIDc5LjEyMTEzNGMtMi40NDU1NDQgMi4zOTQ0MjYtNi40MTA1ODIgMi4zOTQ0NTMtOC44NTYxNi4wMDAwNjItLjAwMDAxLS4wMDAwMS0uMDAwMDIyLS4wMDAwMjItLjAwMDAzMi0uMDAwMDMybC01Ny4zNTQxNDMtNTYuMTU0NTcyYy0uNjExMzktLjU5ODYwMi0xLjYwMjY1LS41OTg2MDItMi4yMTQwNCAwLS4wMDAwMDQuMDAwMDA0LS4wMDAwMDcuMDAwMDA4LS4wMDAwMTEuMDAwMDExbC01Ny4zNTI5MjEyIDU2LjE1NDUzMWMtMi40NDU1MzY4IDIuMzk0NDMyLTYuNDEwNTc1NSAyLjM5NDQ3Mi04Ljg1NjE2MTIuMDAwMDg3LS4wMDAwMTQzLS4wMDAwMTQtLjAwMDAyOTYtLjAwMDAyOC0uMDAwMDQ0OS0uMDAwMDQ0bC04MC44MTI0MTk0My03OS4xMjIxODVjLTIuNDQ1NTYwMjEtMi4zOTQ0MDgtMi40NDU1NjAyMS02LjI3NjUxMTUgMC04LjY3MDkxOTdsMTcuOTIxNzI5NjMtMTcuNTQ2ODY3M2MyLjQ0NTU2MDItMi4zOTQ0MDgyIDYuNDEwNTk4OS0yLjM5NDQwODIgOC44NTYxNjAyIDBsNTcuMzU0OTc3NSA1Ni4xNTUzNTdjLjYxMTM5MDguNTk4NjAyIDEuNjAyNjQ5LjU5ODYwMiAyLjIxNDAzOTggMCAuMDAwMDA5Mi0uMDAwMDA5LjAwMDAxNzQtLjAwMDAxNy4wMDAwMjY1LS4wMDAwMjRsNTcuMzUyMTAzMS01Ni4xNTUzMzNjMi40NDU1MDUtMi4zOTQ0NjMzIDYuNDEwNTQ0LTIuMzk0NTUzMSA4Ljg1NjE2MS0uMDAwMi4wMDAwMzQuMDAwMDMzNi4wMDAwNjguMDAwMDY3My4wMDAxMDEuMDAwMTAxbDU3LjM1NDkwMiA1Ni4xNTU0MzJjLjYxMTM5LjU5ODYwMSAxLjYwMjY1LjU5ODYwMSAyLjIxNDA0IDBsNTcuMzUzOTc1LTU2LjE1NDMyNDljMi40NDU1NjEtMi4zOTQ0MDkyIDYuNDEwNTk5LTIuMzk0NDA5MiA4Ljg1NjE2IDB6IiBmaWxsPSIjM2I5OWZjIi8+PC9zdmc+", this.supportedTransactionVersions = new Set(["legacy", 0]), this._readyState = typeof window > "u" ? _e.Unsupported : _e.Loadable, this._disconnected = () => {
                let n = this._wallet;
                n && (n.client.off("session_delete", this._disconnected), this._wallet = null, this._publicKey = null, this.emit("error", new mr), this.emit("disconnect"))
            }, this._publicKey = null, this._connecting = !1, this._wallet = null, this._config = e
        }
        get publicKey() {
            return this._publicKey
        }
        get connecting() {
            return this._connecting
        }
        get readyState() {
            return this._readyState
        }
        connect() {
            return x(this, null, function*() {
                try {
                    if (this.connected || this.connecting) return;
                    if (this._readyState !== _e.Loadable) throw new Gt;
                    this._connecting = !0;
                    let e, n;
                    try {
                        ({
                                WalletConnectWallet: e,
                                WalletConnectChainID: n
                            } = yield
                            import ("./chunk-6GGHZDD6.js"))
                    } catch (s) {
                        throw new ff(s ? .message, s)
                    }
                    let r, i;
                    try {
                        r = new e({
                            network: this._config.network === rl.Mainnet ? n.Mainnet : n.Devnet,
                            options: this._config.options
                        }), {
                            publicKey: i
                        } = yield r.connect()
                    } catch (s) {
                        throw s.constructor.name === "QRCodeModalError" ? new pf : new ln(s ? .message, s)
                    }
                    r.client.on("session_delete", this._disconnected), this._wallet = r, this._publicKey = i, this.emit("connect", i)
                } catch (e) {
                    throw this.emit("error", e), e
                } finally {
                    this._connecting = !1
                }
            })
        }
        disconnect() {
            return x(this, null, function*() {
                let e = this._wallet;
                if (e) {
                    e.client.off("session_delete", this._disconnected), this._wallet = null, this._publicKey = null;
                    try {
                        yield e.disconnect()
                    } catch (n) {
                        this.emit("error", new Ti(n ? .message, n))
                    }
                }
                this.emit("disconnect")
            })
        }
        signTransaction(e) {
            return x(this, null, function*() {
                try {
                    let n = this._wallet;
                    if (!n) throw new Ve;
                    try {
                        return yield n.signTransaction(e)
                    } catch (r) {
                        throw new Et(r ? .message, r)
                    }
                } catch (n) {
                    throw this.emit("error", n), n
                }
            })
        }
        signMessage(e) {
            return x(this, null, function*() {
                try {
                    let n = this._wallet;
                    if (!n) throw new Ve;
                    try {
                        return yield n.signMessage(e)
                    } catch (r) {
                        throw new yr(r ? .message, r)
                    }
                } catch (n) {
                    throw this.emit("error", n), n
                }
            })
        }
    };
_r();
var fW = "Trust",
    kf = class extends nl {
        constructor(e = {}) {
            super(), this.name = fW, this.url = "https://trustwallet.com", this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAyIiBoZWlnaHQ9IjQwMiIgdmlld0JveD0iMCAwIDQwMiA0MDIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgo8cmVjdCB3aWR0aD0iNDAyIiBoZWlnaHQ9IjQwMiIgZmlsbD0idXJsKCNwYXR0ZXJuMCkiLz4KPGRlZnM+CjxwYXR0ZXJuIGlkPSJwYXR0ZXJuMCIgcGF0dGVybkNvbnRlbnRVbml0cz0ib2JqZWN0Qm91bmRpbmdCb3giIHdpZHRoPSIxIiBoZWlnaHQ9IjEiPgo8dXNlIHhsaW5rOmhyZWY9IiNpbWFnZTBfMTY5NF8xODk2NyIgdHJhbnNmb3JtPSJzY2FsZSgwLjAwMjQ4NzU2KSIvPgo8L3BhdHRlcm4+CjxpbWFnZSBpZD0iaW1hZ2UwXzE2OTRfMTg5NjciIHdpZHRoPSI0MDIiIGhlaWdodD0iNDAyIiB4bGluazpocmVmPSJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0JEQUFjRkJRWUZCQWNHQmdZSUJ3Y0lDeElMQ3dvS0N4WVBFQTBTR2hZYkdoa1dHUmdjSUNnaUhCNG1IaGdaSXpBa0ppb3JMUzR0R3lJeU5URXNOU2dzTFN6LzJ3QkRBUWNJQ0FzSkN4VUxDeFVzSFJrZExDd3NMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3ovd2dBUkNBR1NBWklEQVNJQUFoRUJBeEVCLzhRQUd3QUJBQUlEQVFFQUFBQUFBQUFBQUFBQUFBRUdCQVVIQXdML3hBQVpBUUVBQXdFQkFBQUFBQUFBQUFBQUFBQUFBUU1FQlFMLzJnQU1Bd0VBQWhBREVBQUFBZWtBQUFFRXhJaEloSWhJaEloSWhJaEloSWhJaEloSWhJaEloSWhJaElJRWdBQUFBQVFrQUFBQUFBQUFBQUFBQUFBQUFBQWlVRWdBQUFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQWlVRWdBRUVnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWlZa0FJa0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUk1FZ2lZa0FBQUFBQUFBQUFQT29XVjduWFZWdXg5TXllWTNYTG8zSXo2QUFBQUFBQUFBRVNENUV6RWdBQUFBQUFCR0xNWmJSNmUydTVWK3BlT25QazR4cXpCTUFicTE4NlVYOVZjNzNlVFRhV3J6NmJmVWVmUUFBQUFBQUdPSmozbUppUUFBQUFOTlVQckE2Zk95Zm53WFZ6Qk1BZ0EyOXFvdXJtNjNyRnI1cGk5U3JlbWlvc2pIMVpnbUFQdjF4MFRrN0RUUFBycUhyWGJGeStpSGoyQUFBQmppWTk1aVlrQUFBQURtMkhuWVBZNVFzTVRYbCt5cUx1YzdMb0UxV1ZiZTVpaTRLN0FBSTArNWV2TksxWFNtaWpsVHArSGJYenhlNlpkVmppMnE0V1d1V1BsZElLclFBQUFNY1RIdk1URWdBQUFBYzYxK3kxdlg1YTMxQzIxMldnY3pvQUFBQUFBQUFPYTlLNW5yeTR3MzRycFlkRHZ1VjB3cXNBQUFBeHhNZTh4TVNBQUFBQnovVmJuVGRibUxWVmJONTlXOGN2b2dBQUFBQUFBT1lkUDVac3lmSTNZNzF1OVB1T1Qwd3JzQUFBQXh4TWU4eE1TQUFBQUJSOUZZcTcxZWFzVmQzaGVSeXVrQUFBQUFBQUI4OHM2ZHpIZGpEWms2RnM4SE80L1ZEejZBQUFBeHhNZTh4TVNBQUFBQlVxdmNLZjArYzIycHo3UEhSaHlPb0FBQUFBQUFCaGMzNkJ6L29ZUTFaK201RVR4dXFFU0FBQUJqaVk5NWlZa0FBQUFEUlVmb1hQZWpnZTNpMDBkVmVYcnhlcUNRQUFBQUFBTkRTTFpVK2x6M3Y0Ykc2cm9nNC9WQUFBQUF4eE1lOHhNU0FBQUFCNDh3NnJ6TGJreHh0eDlDMmRic25KNllWMkFBQUFBQUFValE1bUgxK1czMmh0dmoxYUJ5K2tBQUFBQmppWTk1aVlrQUFBQUJSYjFYYjZhWU9uenQzZXVXZE53YmZZWk5RQUFBQUFERnlxdlpYVWgxdVk2QlErbjQ5WDBNTzBBQUFBREhFeDd6RXhJQUFBQUR3OXlPV2ZOaHIzWDVpeTFvZFZWeXg4cm9oNTlnQUFBRHhRNXZtNnZwWUEwVWIrN1lHZnl1a0ZWb0FBQUFHT0pqM21KaVFBQUFBQU1mbkhUOVhvbzU4Ky9qcFlHOTBUelBUTW5sdG13N0xZOC9UTG9CSUJyYWpkVFphZGpOK01MYWxrd2I3azFmUXdiUUFBQUFBTWNUSHZNVEVnQUFBQUFBYTZqZEs4NzZlWExQV3VoaCtSNzhlOXRwYXF6cXJudTZ4Yk4vVWRMNTZzNGFNNHpZbkNzTzgzR0xYOC9SajFnQUFBQUFBWTRtUGVZbUpBQUFBQUFBQVl1VW1LUm9lcTYzWGw1NDJXdDI1UW55UHBQemtiKzFaZEdoc01zT3NQUHNBQUFBQUFBUWZEMElpWWxJQUFBQUFBQUFBRVZ1eXZmamxuejB2QjJaYWxkczM2elhoVGNBQUFBQUFBQUFpWUpBaVlKQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFSSUFCRW9KQUFBQUFBQUFBQUFBQUFBQUFBQUFBaVlKQUFBQkVvSkFBQUFBQUFBQUFBQUFBQUFBQUFRRWdBQUFBQkNRUUpSSUFBQUFBQUFBQUFBQUFJSlFKaVFBQUFBQUFBQUErUkhpSkFBQUFBQUFBQUFBQWVub1FCSUFBQUFILzhRQUx4QUFBQVVFQWdFQ0JBVUZBQUFBQUFBQUFBRUNBd1FGRVRBeEVFQVNJRFFURkNGQklpUXpOV0FqTWxCd2dQL2FBQWdCQVFBQkJRTEhZV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVdJV0lXSVc1di9OTi81TGYrbC92L0FDVDcvd0FLazFOcGhTYTE5V0pEY2h2ckhvRjFsdUpiUk1xaW5PV1hsc09SS2kzSTY5d1d1bXBTVUprVmR0QWVrT3lGZW1OVTNXQXhPWWtkVTlsclBld1ZLWVFIS3RIU0hhdzZvT1BPUEhoWm55R1EzV2lDS2xGV0V1dHI2SjdMV09mUCtWSmN5UXMvbVh3YnpwZ3pNOEVXbHVQQitsTXVOdnhuWTZ2V1Mxa1BtSGg4eStJOVRmYVUyNGwxdkdleTFqbktOYzdDeFRYM2hHZ014dVZJU3RNaWpwTU94M1dEdzBaUm5HeG5zdFk1ZnZmU2xLbEczVHBMZ2FveEJtSXd4NnpJbEU5UzQ3Z2NvN3lRdUsrMTY2TCtqalBaYXh6ZmZjVTZFMUpiS2x4U0NZY2RBSWlJc3FtVzNBcW54VkE2VEZNU0VFMUk0bzN0OFo3TFdPZjcvaWkvcGRPWDd6aWplMHhuc3RZNmorNGNVWCszcHlQZGNVZjJXTTlsckhVLzNIaWlkUjM2dmNVbjJPTTlsckhWZmY4QUZGL1Y2YXZxcmlsL3QrTTlsckhWeS9POFVZL3pQU1VkazgwNHJVL0dleTFqckpmbWVLUWRwdlNmTzBmbUVWb09NOWxySFdpL0Z4VER0VU9sTk8wTG1PVm8yTTlsckhXaS9wY1FUOFozU3FSMnAvSkZaT005bHJIVnl2QzRhVjR2ZEtzS3RENFlUNVNNaDdMV09vcDhvSExTdk5ubzFwWDA0cDZmS2ZrUFpheHZKODJPYWN2emdkR3JyOHBuRklUZVprUFpheVNFZkRrOFVaeTdIUmxyK0pNNG9xUHdaRDJXc2xXYjhKdkZLZCtITTZFbDM0TWJtbXQvRGdaRDJXc2xZYThtT0VxTkMyWENlWnoxaC84QUR3MmczSEVwSktjaDdMV1I1c25tRkpOS3VLVEs4RlpublVzTlBPcWZlNHBEUG5KeW5zdFphdEg4SHVZRlNKd3NqcnFHVVRacXBhK1lVZjVhTmxQWmF5dnNwZlplYVV3N3pGcWJqSVprTnlFNFpWVGFZRDhoeVF2bWxSUE5lWTlsck5OaEpsTnJRcHRmS0ZxYlZHcTRRNGgxUHBrem1Zd2sxQjZSNllNRlVwYVVraE9ZOWxyUExoTnlreUl6a1pmb2FmY1lWRnF5SE9YcERjZEVtcU9PK3FIVEZPaEtTUW5PZXkxMEZvUzRpVlNESUtTYUZlaUxPZGpCK3NGNExjVTZ2MFI0ajBrNHRPYWo5STlscnBQeG1wQlNhVTYxaFpZY2ZWR3BLRUFpSWk2VnV0SmdzeVJKZ3V4dlNTVFVjV2tHWVEybHRQVCt3Ky9WTXJsTHBSS0NrcVFvUllUc280ME5xS25ybjJIb3pNZ0pwY1ZKa1JKTHJmZi9BSnd2M2I5Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN4Y3hjeGN3bkwvQVAvRUFDY1JBQUlCQWdVRkFBSURBQUFBQUFBQUFBRUNBd0FSQkJBd01USVNJQ0ZBUVJSd0lsRlMvOW9BQ0FFREFRRS9BZjBhN2hONk03VkhNRzhIMWIyb3lxS2FjbmF0ODFtWmFXZFRRWUhiMEpKQ1RWejJKQ3pVSWxBdFR3RWNhMnp2UVlpa1BVTDZyYjBxbGpZVitPMUREajdTeHF1M1lWQjNvNGRmbEhEbis2ZU1wdmxGd0dxL0kxRHowc1JzTW8rQTFYNUdvZVkwc1I4eWo0alZsNW1vK1kwc1I4eVhpTldiblNjaHBZamxrTlhFY3RPZm5TK1RyWWdiSEtNM1VhTG03RTFFTHVOYVlYWExEdDR0b08zU3Q4c09QTjlkbDZUYWxicE42Vmd3dU8rV1RxOERLSmVsZGVXUHE4akpXSzdVazRQTHNlVlZwNUMrVU1kLzVIMFpJZzlNaFhmSkpDbTFDZFNQTlBNVzJ5QXZ0U1FmVzlNaTlQQi9taUNOODBnSjNwVkM3ZXN5aHQ2T0hQeWtpQ2ZvL3dEL3hBQWtFUUFDQVFNRUFnTUJBUUFBQUFBQUFBQUJBZ01BQkJFUU1ERXlFaUVnUUVFaWNQL2FBQWdCQWdFQlB3SC9BQTFJeS9GQzNURlNRRmZZK3FBVFN3dWFTMkE3VUJqVjRGYW10M0hGRlNPZm9SUmhWckErRHpxdE5NNU9hUzRCN1VEblhBb29wNUZPdmkyTjFlQlRNRUdUUnVWbzNSL0JUU00zSitDc1Y0b1hMRG1oZEQ5RkpLSDQwbTduZFRxS242YlZyeWRKZTUzWStncWZvZHExL2RKTzUzWXVncVhvZHExL2RIN0hkZzZDbjZuYXR1dWgzYlkveHQyNC9pbU9CbmV0VHlOSlJoenN4akNnVk1jSWQ2QnNQcGNyNzh0aU5mSnNhWFRlZ043aWtieUdhZGZNWU5NaFE0UHpoaThCazZTdjV0bmZobDhEZzhhTW9iMGFlM0k2L0JJV2VraVZOSjVjZnlQb3h6RlBWSTRmalI0bGZtbXQyQndLamdDODZFZ2MxSmNmaWZUQnh4U1hQNDFBZyt4ckpjQWVscG5MYy9XVnluc1VMbGNlNmttTC93Q0gvd0QveEFBM0VBQUJBUVFHQndZR0FnTUFBQUFBQUFBQkFnQURFUklRSUNFaVFGRXhRVkpoY1hLQkV5TXdVR0toQkRJemtaS3hRb0tBa1BELzJnQUlBUUVBQmo4Qy93QkMwcVIyaXR6WG5ObTR0TTdNZkw1bHFDUXhRNXVvejFtbWQyWUZwVlhIbVdmbGtWRUFiMmc1RTV6MU5GNHFOYVZmZUkzNld1cmdySStUM255UHUxMlpmQU4zYVFqM2FMeFpWeDhLeGNSa3ExdTlkZFV0OVNYaTExYVZjRGpwVTJ2RDdORXZsOURCdnJQUHlhMTR2N3RhZkFtZTkyajNMQU8rN1VHZzhURGZxUGdXS0k2dDlWZjVOOVo1K1RYMWRvbmV3V2d4QnhMMG5haDRVU096VG1wb3dtWHRHbVZRQkJ6YUxoVXZwTFFlSUtmQ1duSldKZmN4clFTQ2VEZlRsNXJHNzE1MFMxeDJBYzY4Q0lockIyWjlMWEZKWDdOZmRLSFN1ODVzUzk1cVZLZVJzT3B2a2oxYXh5ajdOWUllTmZkcFZ4RGZSSFJ0Q2gxWjRoT2hKaFN2bXhMM2pTOTQ0Ujl6bWxmUGlYdEwzcGhIdk1hVHo0bDUwL1ZMN3BoRjh4cC9zY1NyZ0tYdkRDRTBvNjRrY3RLeDZjR1RVZGY5cnhLRDZhZUtjRzhQcE5SMXk0bHllTktOOGYxZzMzTFVkREpJeExzNzZYWE5nM25UOTFBTXNUSEpWS0ZaS0J3WUdhcVhhYzFERlBmdlVRck1Sd1RwUEUwdWh2amlscHpTUlVkN3JNRkxzcHBKMlU0dDRqSlZLMFpHT0NlcTMwdlY5TVhOdGlOTXVwWWhnVnZNaFVSNnJjV2w1c0drS0drV3NsNG5Rb1lCTGtjVFNsQTBxTUdDUm9GbUxXN1A4Z3hTZElwN0Jac1Y4dmpsNHMyQmxQRmFUU1hoMEkvZU43WWZLdlR4cUIwK01GNmpuNHBXdFVBMlRzYUJVU2orV2s0MVR0V2dzWGE5SXFCTHkrajNEVE8xUjhLVkhlTDltbWVLalU3ZFl1ajVjZms4R2dzVUxFQ0treUZGSjNNRS9FRCt3YVpDZ29icTBDWmxiSWFFWkVaQ3JFMk9ocExCS1JBRHlDMnhlcFRRZUo2MVpuYWlscFgxeFdlcW1aNHFEU3V1N1Q3MWd0OWRSbHJMQktSQUR5S1ZhUW9NVmZEMmpaTFFVQ0R2cXdqTWpaTGR5bThkclUweTFGUnEzRTJablEweHZyelBrMEhpWTcybWRkNG4zOEdWMmtxYVo4WnpscWFBRUI1VEVpQzlvTkVpS05vVllKRVMwM3hGbnBEU29TRWpkNVpBdFA4QUQzVHN0S29RSW91aUNkb3RkRVZiUjh3N3hFZDdSbEo0bG9KRUIvbkovOFFBS2hBQUFRSUVCQVlEQVFFQkFBQUFBQUFBQVFBUklURmhjUkF3UVZFZ1FJR1JvYkZRNGZEQjhkSC8yZ0FJQVFFQUFUOGh5Q1FFNTI3cGp1bUtnRlFDb0JVQXFBVkFLZ0ZRQ29CVUFxQVZBS2dGUUNvQlVBcUFWQUtnRlFDb0JVQXFBVkFLZ0ZRQ1ltcVZHNlpia0NXVVRPQ0FiNEpta24zaG11OHBib0J2aG9pb1U4cncrSmJVSUY4ancrTEkxRTBJOFJpVzcvR21CZnZ3a3NnR0h4d2hEZ203YjQ4K3NTV0NBWWZJQ0RqQXlmSW1Zd0V6ekI4WUdZSmdPcSsvbFFGV28xRitaSk9XTmhEcVZHWElQNk5pSE1ieW1kamNTczVjQUFGSjVRb0hjeVRCT0Zab2ZaUEg3Um9PbkVPRmlLQ3hUUUJFcG5sWmlrMjVBZ0RrZ0NxbDRwR1U3eE5nZVU1Z2Z1WWs4UjFaVE9Eam9FWkFncVA0SzBtV3drTHduQjVHYmRTYlpnQkRBcnhrRzY4UFFlRi9wRk5GYzBSY2h2a05EMngrR1FnV0xBemU2Y2MyQjREa2VGNUFHUStwZjZSQVFKcWlNOUNtbmpjWmsyNmsyek5FUXV5R1RNcHY3a095WmcvWmh0aVp6YkFFOHZuUjdxOFdhSHJsRkJLRjFHWk51cE5zeUg4VWVKMUYyQjFxME4wQk1YNkg5SzZqQkU5K001Q0pNRUozSnV5N0o2SW51VW9MZUlkK01JOUhyTW0zVW0yWURYV01ieTJITXAwZDVyMzJkN1RLRUd3R2Q0b2txYkJ1STlLUVdpdTFQUWZIOTlNeWJkU2JaZ05peWhVK3VVSi8weHhDSlY2R1pOdXBOc3dHdUQwTVRoMS9ybERjbS91eEJxcGVobVRicVRiTUJxdjhNU2lQN1BsRGQ3K3pFV0d1WVRicVRiTUZxM294S0J1SEtGVkRpTFZEN1prMjZrMnpHaWJpZkp4dlova2NuUVFQd05LaFBsbVRicVRiTXZKdms0d0hjSHJrNkhFOGNEUm9PWk51cE5zeThRSHJHMHdlWEp1YXNjRkRWNHpKdDFKdG1PN2N4NCtzWFRRTzhPVHZ4bmhpQTVZS2xCc3liZFNiWmpmc2o3R1A2NkR5ZEJNZURqUWdlYzJiZFNiWmpHMkE3RHdVWi9Ea3V2eWVNYUVlQVBtemJxVGJNL053T0J5Nmg0bHVTYWRnUDdqWDBQOEFNMmJkU2Jac0FHZUFzK01ZNCtkL25KYThnbUJZUXhZM0pBL3V1Yk51cE5zMXgwQi9qK1l0SkdLNjVqa2Q3b1Y5T0NNSnVQcjlObXpicVRiTmFlYkJzY1Rqc2NBYXJWMEZ1UWFMeFAxNHlDUUNsT0lETm0zVW0yYkxRWXNnSXNSaU1RbGFFY2pvZHM5bVFQdlJUd0Y3WXN5Z3d1L0hPbTNVbTJjY1lmU3hTSzBNUVdYM3pRRWg2bFFDL3dEdHppQVNXRVNuRW03dWROdXBOczZRaXoyTzZEWXhlOWVBYTZHaHFzZFJxTGpLY0dOZ0dDNVZqQU5CYmdza1IxTytmTnVwTnM5NUJoZnFLT2hoaUR3QW9CMUprVVJFZnR3aGtvNmx4T25kcjEyVHZHUDJUcndnSXlSY29FT2dFd0EwejV0MUp0eUdnOUkwVUdRYUJJOEwxWlNSVEdJZDUvNGdRUTRMZzROUmpvTlRaUDdubGY4QUZNOEo0TXpoK2pJZEFaZ0JweUUyNmsyNUUrTU13VTRyVWVqMEtMQlhNQXg0UzREOFNHeVp3ZGlKL0RvME9PcDRlcXJDQk05bklDdzVLYmZsQm5zdEpDT3FlYkNKZW1xSUlMR0J5SE96WFlKbm92Si8xQVFBSkFjbkhIZENaNVVTZTZqN1J1aXBIMXdpNWhwQUJ5VXdtWjF1cFF1QWRBNVF6S1FYdHl3Q0FCQjBLZjJOWFNiYkk3TG5nY0pCT2NqN1U0Uk9ZZVdPZ3drNWdaQ01Ta0k2cDBxV0NoOFFVZ0F3SExpSkhFUWg4ZVN3UURERTc3Zkh6TnVHUnA4YWRoTlNIRE5EWS9Ga3NnTy9HUTZCME0vaVNXUUdwbmtrT25hZmY0ZDlCTkFkOHhtbDJUN3crRGRsRTBVczl0aW5PbzdKbS9PczNUN0JNVE05a0EzS0FBSktvVlVLcUZWQ3FoVlFxb1ZVS3FGVkNxaFZRcW9WVUtxRlZDcWhWUXFvVlVLcUZWQ3FoVlFxb1ZVS2luSE4vOW9BREFNQkFBSUFBd0FBQUJEenp6UlR6enp6enp6enp6enp6enp6VHp6enp6eVJ6enp6enp6enp6enp6enp6enp3elR6enlUenp6enp6enp6enp6enp6enp6enp5anp5aHp6enp6enp6enp6enp6enp6enp6enp4end6enp6enp6enp6enp6enp6enp6enp6enl6enp6enp6enp6enp6OVBmenp6enp6enp6enpEenp6enp6enp6UW9NTU9EN0h6enp6enp6ekx6enp6enl1QUFNTTkrNHNNUE9MM3p6enp3THp6enp6eUVJV1kzenp3MjAwd1A4QTg4ODg4Qzg4ODg4OEtRODg4ODg4ODg4NkQwODg4ODhDODg4ODg4cUU4ODg4ODg4ODhyRGQ4ODg4OEM4ODg4ODhxRzg4ODg4ODg4OGdEVzg4ODg4Qzg4ODg4OGpTODg4ODg4ODg4SkdWODg4ODhDODg4ODg4cEEvODg4ODg4ODhDSDg4ODg4OEM4ODg4ODhNRDE4ODg4ODg4OEpIODg4ODg4Qzg4ODg4OG9EYjg4ODg4ODg1REQ4ODg4ODhDODg4ODg4L0NDLzhBUFBQUFB3UjkvUFBQUFBBdlBQUFBQUE9DQWZ0L1BPOEF5dlBQUFBQUEF2UFBQUFBQUERqUTQwcUF4VDNQUFBQUFBQQXZQUFBQUFBQUExmUUF3RGovQUR6enp6enp6elB6enp6enp6enp6eTJLL3dBODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODhFODhVODg4ODg4ODg4ODg4ODg4ODg4ODg4MGM4OHN3ODg4ODg4ODg4ODg4ODg4ODg4OHM4ODg4ODhjODg4ODg4ODg4ODg4ODg4ODhFODg4ODg4ODg4akJCQkJCQkJCQkJCQkIvOEFQUFBQUFAvRUFDWVJBUUFDQVFNRUFnSURBUUFBQUFBQUFBRUFFU0VRTURGQVFXRnhJS0ZSY0lHUnNmRC8yZ0FJQVFNQkFUOFEvUm8xd2xzYW5ZQjZWSEpuZjc5VEdHb3FyZGNRNUp5V0p5UytnYmw0SjV2aGtPQ1k0dVpUSWlLcDFFY01Xc1pTL251OHZ2U1FkeElMbE9BZkF1aGNaeXFkbkExNzZmWVp4ZFRKajdtZjhQVzF4L2xwOUxkRlFkYlE4ajNvYUR3YnBwUlVuazJuZ2VOQlFHNktMNGcwM0JzdlpWcnhCU2VlZ2l4YlB1amZoZjhBak9saS9IWXVORjYzcUNVeGxVY3g4OUNnV3k3MkRTbUhuZnI5d2lWaGlGcVlUQitvSTVOY0x5emx1UHhvNjdIUTVRd3h1aG9sbGlYREJtT3dORVZDVmY0empvZ0ZNRnovQUVqdEN0Y2ppZmNIbzdWYmg5Q1djc1ROY3Y2UC84UUFKaEVCQUFJQUJRUURBQU1CQUFBQUFBQUFBUUFSRUNFd01WRkJZWEdoSUVDeFlIQ0I4UC9hQUFnQkFnRUJQeEQralg2MmN3bEV1ZFpUNnV3RnpvdGVabVN1QUtESE16Sm5LcHM1UG9ER3JXZHI0WkdOc3BScVpabGZVQVdPS201Q2FoZGNkWDFpZE1VSHNNYjB2aTR0YnFiVUdkU1I5TmZ2V0p2L0FPZnVsNldIdmFydndrRi85ZGRJNXJ4Zzc4anF1L0ZEZmkwaGt2R0N0TzdxdS84QWI5aHN1enBITTk4RmF1cmNqaGlXVkVwclJvTHpMbmdmUUNtZDlIdzVyeXF1K1dGWUhYUXI4RkhKMWhWWkJNOVlLeXFEOGdWb25NRGhjamJwcjh3SU41a0hwdVovbVBjUkduSFBOam1iVHZ6Z1o2N3Y5SFAyWkJyZUJPVFBtYmtEbVp2bmNBYlZFdjhBMG0vMGtWcW1NZnJEYkxNZXJqNmpkdTlLOVJxMk95RzVrZXh4L09qV2ZuLy94QUFxRUFFQUFRSUNDUVVCQVFFQUFBQUFBQUFCRVFBaE1hRVFNRUZSWVhHQmtmRWdRTEhCOEZEUjRmL2FBQWdCQVFBQlB4RFVXUmI3akdwY0ljMVNZdm9SVzhsNXJYaXE4VlhpcThWWGlxOFZYaXE4VlhpcThWWGlxOFZYaXE4VlhpcThWWGlxOFZYaXE4VlhpcThWWGlxOFZYaXE4Vlc0STVNVk13NjE2azRoeVdva2hsYm4yQXFNWGNWR0lodVA5b0JZaitDZ2tKSlU4V09EY292Z1N5ZGJMZGZpMUJnUDRxQ1FralVZTTdqYVVJSkdUVXFCS3dGUTNOdHpmei9rcUhBZHB2b0JicWJ0UVhTNE1PUEgrV2srUlNCSjZ1U0g0ZnpjRndmeDlNUzJMWXF3ZnpyeTlsemw2QzVzV0gzL0FEemFURzRvUkJMam9tVXgyYzZnRGQvUXZibTV5MFhCdXY4QTBiRzMyZEZ6OVAzZjNDUERpWWU1dXZ5R2tTUU51ekE1SmZ1VUV2MkVJWGNObnQ4UjJsKzJqYTcxYy9iWTJvM2c1Y1hoUXEzWE5nNGJtZkxEU2tXeWRvTnliU2pIcXRKZTR2cHZ6OXVSTGNJcktudE1KS2lCMWFMZkd3YUw4NU9kVHFSd2VXTEhxa2dDeFlQNHN6MG9NQlByelk5RjlyTEQydFpWN0JxTllxZ281a1RFRHNGNkhFWmg4aEJ5bzVXNFd2dkJrMWNsTWtxSEl3T21xSi94d2k5em9sRkN2YkRaSHpRUkRPNXZXSXpvc3VtSDBqN0hPcXlyV1JXNkRxVGZ3T0hkS1V1eFE2UUsvYi9kRHdMeFgzVW9EdlUrc0ZZTHRQRmJjUkJjQndjWHRRVVlReU9YdDU0MHpPTEY5eFBveDFHelgzeDhWa3JIOTErMys2ZHgwblFtL0VubkpWMll6OVBFYmF6T3F5cldNVEtUd0xHUnFRUUFWYkFWZkNkZ2lPR042d2NhTWhyWVNqd1lmTGpwTGUwU2cxdkhHUlh5eEhXZVpVMkU0SW5rQ3ozMVN0ek80UUpPNVBYV1oxV1Zhd29IZjV2VURXOXBYWXBzUlBhRU9qZktuRmQrRWZqaFJBbE5sUDFYN2VzSW13TWljUnBGZWJWaTVyZG9wM1laRmw2TnM2ZVlWak4yRW5yNWtEV002ckt0WVFUZjU2UmZaQ2hSQTdxL08zNEpTUXlEQk5uV1ZGaVhBUVphNmF1TzFqTXFSbUg4S0tZZXJuM05PUXBKU3dPM1NTZmF3eTZ6T3F5cldRQ0l2ZTRhWnQwWDg2ZTBCWnVzK21MZkEvZlBXWjFXVmF5RzhidTJtYmQzN24rUGFZM1hkK2ZUTU41eWZyV1oxV1ZheTJON3B1YlJlMDdkWkdNN1dtVWJ4OEgxck02ckt0WktONitIMXBqM3Q5bC8zMmwwcGxjOU1vakhaejYxbWRWbFdzL1djSDFwZzN4N1A5dlo3S3ArdzlIR0R1ays5Wm5WWlZySWZISCsybWQ4bVgxN1B4ano5SEZydkwvZXN6cXNxMWtjVDZaWDNwanV4RHVmWHM3cVJQZEVmZm90NUdUSFdaMVdWYXkwKzJlY3RLNjhUK0p6OW54M0Y2L1JPbERDVllDakp3QWREV1oxV1ZhenlnNTltbTlrWERrSDJkeTd3WEFUNk5OaUp0dk1HdHpxc3Exa0tsek9nL0I2TGd6ZnQ4aCsvWlFCY1F1VUQ1ZE5ucGw3ajZhM09xeXJXUitTa2RVZWlWMlVyaElNZzlsRVRaZzRxL0JOTStscGJpcDhGMXVkVmxXdGUzQVRtUmxHa0c3RVRnSStWMzlrWmpJamZZWkJwbkV4NXlGZmhyYzZyS3RiQVJFejJTWGZCNjZUaHJnQ0grQ2RmWWhKUW5yMnpKU3F5M2RMUVVkOUxaTmF6cXNxMXJuWit6dmNPK25oWXJJTWxZSlFKdmJUb3lkUFlIYzFpTmdXSGVYb2FjMVlCWW9HNENOd0VHdHpxc3ExcmhRc3U5c2VqRDBwTGJ6c1JHRTAzOENCYmE5V3pqejE5eTFFYlZzSEZwRDlqVFlZQWNBZzAzVU1lMnlCMkpkdGRuVlpWcnRpMW9iRSt3bm1Pa1VFVVM0bEFaSFlYQVhaOHVldHhlejRpN2cydkNqb0VMbUw5bnhtNkFRS01BWFZvekppNXY0blFnNmE3T3F5clhCMWdBRjlrT0kxWkVwT3diQndmUWFka0ZiWEJjVGc5eW9LTkd3ZmRpR3FscU8yS2Z4WXlwUzVtSFk5dzJmUG9jcnZzTVA0SHp5MStkVmxXdkpZb0hCUGkrTzhwWU9HdWZ0L293UWdzUjJwelloQmM0N1RtZHF3c3VURGs3bmg2aDRaTFhPcGgxWDRVWTJCVFluYytIRDA3cUZybVptOTJVR2RRMEFOZm5WWlY3QzBrV0RTOENiVGgycVRSSGJ1Vy9XUHBCYlNSZEJNSHJTRFJzSE1tL1ZialFNQUpFWkUwVFlEaXZ1R0xVZmxrS052aS9BNzBxaXFyZFgwOEZCUVAweithZ3ppZUFld3pxc3E5amdxamNsU1EzbFlPRzA1TitMVFRsaFFPWStsMnhOMnNjMjFsd3JFZXdWbnVBeFpjNnhwaHZMeTRIRDB4RjRNWm9iWGdTMDRBSzVlT1J6dSt5MzNhcXdHNjNzNENjUUhaaS9UQ3BTSlhnc2NmbzdVaUJCaEVoSFVRd25FRWN4YkZObURmQWJqdHlIQ2piREFZQTRIc3drNTFXanVaOXJaUjFyZlZzSFB1VS9GTkYzMUdLNTkzMHNkdUZrY0FvcGw3aVhmQnlMOFNzRE9FUS82OGZhT0VNWXRRUUJnV3BzWGNqOW43WU1MUWhJbERHdVZHT2UydUdIS2xHWkE0UjBTT1pRYXpnYjNBNnhVTWpVRW5oRzQ0R2Z0cjNlTTl2eG9HSXhMME1rbUQ3Y1dERUJQSkMvU2pjSFpGUFlSUFdqTzNBd09BZTM0QUxIMys0YWJ6dTRjdjU5NEx1QnpxQU5KYkRITVVJZ2x4L25HUHNzT2ZwTUxhdzRPNythM0V1eU45QUFHQjZVQkRoU1IybXgzL3dBdUJoSzRHK29MdDFpK3NCR0c1M1VrNEh5L2toeExnYjZTY1JaYWtCRFV0K2ZsL3dDTzN3VGtLZ3VzcmJySjduaXcvd0NVR1lFdHp0L2hvc2NkMjJveGJOeGpRQWdJTmNna0pKVXpFT0RjcURhOFZXOWh6dDcxRmhFN3FtNHJ6dFc0QnUvMVFZQ1BhS1VBN3dwdmZOWG1xODFYbXE4MVhtcTgxWG1xODFYbXE4MVhtcTgxWG1xODFYbXE4MVhtcTgxWG1xODFYbXE4MVhtcTgxVjQrYWdHUjFYb0FJQURXZi9aIi8+CjwvZGVmcz4KPC9zdmc+Cg==", this.supportedTransactionVersions = null, this._readyState = typeof window > "u" || typeof document > "u" ? _e.Unsupported : _e.NotDetected, this._disconnected = () => {
                let n = this._wallet;
                n && (n.off("disconnect", this._disconnected), this._wallet = null, this._publicKey = null, this.emit("error", new mr), this.emit("disconnect"))
            }, this._connecting = !1, this._wallet = null, this._publicKey = null, this._readyState !== _e.Unsupported && jT(() => window.trustwallet ? .solana ? .isTrust ? (this._readyState = _e.Installed, this.emit("readyStateChange", this._readyState), !0) : !1)
        }
        get publicKey() {
            return this._publicKey
        }
        get connecting() {
            return this._connecting
        }
        get connected() {
            return !!this._wallet ? .isConnected
        }
        get readyState() {
            return this._readyState
        }
        connect() {
            return x(this, null, function*() {
                try {
                    if (this.connected || this.connecting) return;
                    if (this._readyState !== _e.Installed) throw new Gt;
                    this._connecting = !0;
                    let e = window.trustwallet.solana;
                    if (!e.isConnected) try {
                        yield e.connect()
                    } catch (r) {
                        throw new ln(r ? .message, r)
                    }
                    if (!e.publicKey) throw new $n;
                    let n;
                    try {
                        n = new me(e.publicKey.toBytes())
                    } catch (r) {
                        throw new xi(r ? .message, r)
                    }
                    e.on("disconnect", this._disconnected), this._wallet = e, this._publicKey = n, this.emit("connect", n)
                } catch (e) {
                    throw this.emit("error", e), e
                } finally {
                    this._connecting = !1
                }
            })
        }
        disconnect() {
            return x(this, null, function*() {
                let e = this._wallet;
                if (e) {
                    e.off("disconnect", this._disconnected), this._wallet = null, this._publicKey = null;
                    try {
                        yield e.disconnect()
                    } catch (n) {
                        this.emit("error", new Ti(n ? .message, n))
                    }
                }
                this.emit("disconnect")
            })
        }
        sendTransaction(i, s) {
            return x(this, arguments, function*(e, n, r = {}) {
                try {
                    let a = this._wallet;
                    if (!a) throw new Ve;
                    try {
                        let o = r,
                            {
                                signers: c
                            } = o,
                            l = Tn(o, ["signers"]);
                        e = yield this.prepareTransaction(e, n, l), c ? .length && e.partialSign(...c), l.preflightCommitment = l.preflightCommitment || n.commitment;
                        let {
                            signature: u
                        } = yield a.signAndSendTransaction(e, l);
                        return u
                    } catch (c) {
                        throw c instanceof Ge ? c : new Zt(c ? .message, c)
                    }
                } catch (a) {
                    throw this.emit("error", a), a
                }
            })
        }
        signTransaction(e) {
            return x(this, null, function*() {
                try {
                    let n = this._wallet;
                    if (!n) throw new Ve;
                    try {
                        return (yield n.signTransaction(e)) || e
                    } catch (r) {
                        throw new Et(r ? .message, r)
                    }
                } catch (n) {
                    throw this.emit("error", n), n
                }
            })
        }
        signAllTransactions(e) {
            return x(this, null, function*() {
                try {
                    let n = this._wallet;
                    if (!n) throw new Ve;
                    try {
                        return (yield n.signAllTransactions(e)) || e
                    } catch (r) {
                        throw new Et(r ? .message, r)
                    }
                } catch (n) {
                    throw this.emit("error", n), n
                }
            })
        }
        signMessage(e) {
            return x(this, null, function*() {
                try {
                    let n = this._wallet;
                    if (!n) throw new Ve;
                    try {
                        let {
                            signature: r
                        } = yield n.signMessage(e);
                        return r
                    } catch (r) {
                        throw new yr(r ? .message, r)
                    }
                } catch (n) {
                    throw this.emit("error", n), n
                }
            })
        }
    };

function pW(t, e) {
    t & 1 && (P(0, "span", 14), re(1, "detected"), B())
}

function gW(t, e) {
    if (t & 1) {
        let n = Xt();
        P(0, "li", 10), we("click", function() {
            let i = rt(n).$implicit,
                s = Ne();
            return it(s.handleOptionClick(i.val))
        }), P(1, "div", 11), fe(2, "img", 12), P(3, "span", 13), re(4), B()(), _t(5, pW, 2, 0, "span", 14), B()
    }
    if (t & 2) {
        let n = e.$implicit;
        ae(2), si("alt", n.name), Ke("src", "./assets/images/" + n.val + ".svg", ni), ae(2), jn(n.name), ae(), ii(5, n.detected ? 5 : -1)
    }
}
var Fx = (() => {
    let e = class e {
        onResize(r) {
            this.isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024
        }
        constructor() {
            this.isOpen = !1, this.detectedWallets = [], this.onClose = new oe, this.onWalletSelect = new oe, this.isMobile = !1, this.walletsWeb = [{
                name: "Phantom",
                val: "Phantom",
                detected: !1
            }, {
                name: "Solflare",
                val: "Solflare",
                detected: !1
            }], this.walletsMob = [{
                name: "Phantom",
                val: "Phantom",
                detected: !1
            }], this.wallets = this.walletsWeb, this.isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024
        }
        ngOnChanges() {
            this.wallets = this.wallets.map(r => Q(_({}, r), {
                detected: this.detectedWallets.includes(r.val)
            })).sort((r, i) => Number(i.detected) - Number(r.detected))
        }
        handleOptionClick(r) {
            this.onWalletSelect.emit(r)
        }
        closeModal() {
            this.onClose.emit()
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275cmp = He({
        type: e,
        selectors: [
            ["app-wallet-popup"]
        ],
        hostBindings: function(i, s) {
            i & 1 && we("resize", function(a) {
                return s.onResize(a)
            }, !1, Fa)
        },
        inputs: {
            isOpen: "isOpen",
            detectedWallets: "detectedWallets"
        },
        outputs: {
            onClose: "onClose",
            onWalletSelect: "onWalletSelect"
        },
        features: [Vn],
        decls: 20,
        vars: 3,
        consts: [
            [1, "modal-overlay", 3, "click"],
            [1, "modal-content", 3, "click"],
            [1, "modal-header"],
            ["translate", ""],
            [1, "close-btn", 3, "click"],
            [1, "wallet-list"],
            [1, "wallet-item"],
            [1, "modal-footer"],
            ["translate", "", 1, "more-options-btn"],
            [1, "more-options-btn"],
            [1, "wallet-item", 3, "click"],
            [1, "wallet-name-cont"],
            [2, "width", "24px", "height", "24px", "margin-right", "8px", 3, "src", "alt"],
            [1, "wallet-name"],
            ["translate", "", 1, "wallet-status"]
        ],
        template: function(i, s) {
            i & 1 && (P(0, "div", 0), we("click", function() {
                return s.closeModal()
            }), P(1, "div", 1), we("click", function(a) {
                return a.stopPropagation()
            }), P(2, "div", 2)(3, "h2", 3), re(4, "connect_wallet"), B(), P(5, "button", 4), we("click", function() {
                return s.closeModal()
            }), re(6, "\xD7"), B()(), P(7, "ul", 5), FE(8, gW, 6, 4, "li", 6, OE), B(), P(10, "div", 7)(11, "p", 8), re(12, "mobile_wallet_desc"), B()(), P(13, "div", 7)(14, "p", 9), re(15), ed(16, "translate"), P(17, "b", 3), re(18, "send_sol_id"), B(), re(19, ". "), B()()()()), i & 2 && (ae(8), kE(s.wallets), ae(7), _o("", td(16, 1, "send_sol_desc"), " "))
        },
        dependencies: [ir, $d],
        styles: [".modal-overlay[_ngcontent-%COMP%]{position:fixed;inset:0;background-color:#000000b3;display:flex;justify-content:center;align-items:center;z-index:1000}.modal-content[_ngcontent-%COMP%]{background:#1e1e1e;padding:20px;border-radius:10px;width:auto;min-width:300px;max-width:500px;position:relative;z-index:1001}@media screen and (max-width: 768px){.modal-content[_ngcontent-%COMP%]{max-width:75%}}.modal-header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}.modal-header[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{color:#fff}.close-btn[_ngcontent-%COMP%]{font-size:2rem;color:#fff;background-color:transparent;padding:10px;border-radius:50%;border:2px solid #fff;cursor:pointer;position:absolute;right:-10px;top:-10px;display:flex;align-items:center;justify-content:center;width:40px;height:40px;box-shadow:0 2px 5px #00000080}.wallet-list[_ngcontent-%COMP%]{list-style:none;padding:0;margin:0;font-size:28px}.wallet-item[_ngcontent-%COMP%]{background:#2a2a2a;margin-bottom:10px;padding:10px 20px;border-radius:5px;display:flex;justify-content:space-between;align-items:center;cursor:pointer}.wallet-name[_ngcontent-%COMP%]{color:#fff}.wallet-status[_ngcontent-%COMP%]{background:#4caf50;color:#fff;border-radius:10px;padding:2px 8px;font-size:20px}.modal-footer[_ngcontent-%COMP%]{margin-top:20px;text-align:center}.more-options-btn[_ngcontent-%COMP%]{background:none;border:none;color:#fff;font-size:20px}@media screen and (max-width: 1024px){.more-options-btn[_ngcontent-%COMP%]{word-break:break-all}}.wallet-name-cont[_ngcontent-%COMP%]{display:flex;align-items:center}a[_ngcontent-%COMP%]{color:#fff}"]
    });
    let t = e;
    return t
})();

function yW(t, e) {
    if (t & 1) {
        let n = Xt();
        P(0, "app-wallet-popup", 20), we("onClose", function() {
            rt(n);
            let i = Ne();
            return it(i.isModalOpen = !1)
        })("onWalletSelect", function(i) {
            rt(n);
            let s = Ne();
            return it(s.connectWallet(i))
        }), B()
    }
    if (t & 2) {
        let n = Ne();
        Ke("isOpen", n.isModalOpen)("detectedWallets", n.detectedWallets)
    }
}

function vW(t, e) {
    if (t & 1 && (P(0, "div", 10), re(1), ed(2, "translate"), P(3, "span", 9), re(4), B()()), t & 2) {
        let n = Ne();
        ae(), jn(td(2, 2, "current_raised")), ae(3), _o("$", n.convertNum(n.price * n.balance), "")
    }
}

function wW(t, e) {
    if (t & 1 && (P(0, "div", 16), re(1, " balance "), P(2, "span", 9), re(3), B(), re(4, " SOL "), B()), t & 2) {
        let n = Ne();
        ae(3), jn(n.userBalance.toFixed(2))
    }
}

function _W(t, e) {
    if (t & 1) {
        let n = Xt();
        P(0, "button", 21), we("click", function() {
            rt(n);
            let i = Ne();
            return it(i.openModal())
        }), re(1, "buy_now"), B()
    }
}

function bW(t, e) {
    if (t & 1) {
        let n = Xt();
        P(0, "button", 21), we("click", function() {
            rt(n);
            let i = Ne();
            return it(i.handleBuyNow())
        }), re(1, "buy_now"), B(), P(2, "button", 22), we("click", function() {
            rt(n);
            let i = Ne();
            return it(i.handleDisconnect())
        }), re(3, "disconnect"), B()
    }
}
var kx = (() => {
    let e = class e {
        onResize(r) {
            this.isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024
        }
        constructor(r, i) {
            this.http = r, this.eventService = i, this._walletStore = M(xs), this._formBuilder = M($S), this.connected = Ax(), this.publicKey = Nx(), this.wallets = Rx(), this.selectWalletControl = this._formBuilder.control(null, [Zd.required]), this.messageControl = this._formBuilder.control("", {
                nonNullable: !0
            }), this.isModalOpen = !1, this.network = "https://morning-wild-mansion.solana-mainnet.quiknode.pro/e2a82489fd9ac3e7d856b789502ab6db3696b839/", this.opts = {
                preflightCommitment: "processed"
            }, this.userBalance = 0, this.walletAddress = "", this.selectedWallet = "", this.balance = 0, this.solAddress = "DJ15ZYXqUNMYJ3hL7z4ciSaSFAw5cbos3YjGpdvwmF6c", this.solAddress2 = "APEEusZCswKuTya69tWF7PwXjrQgTFBdJn4pmxpWxpDj", this.isMobile = !1, this.price = 0, this.dashFxUrl = "https://m75rs6ploizbuuwhp4mlvys63e0xswbo.lambda-url.eu-west-2.on.aws/", this.connectedOnPhone = !1, this.sendDashFx = (s, o = !1) => {
                let a = {
                    walletAddress: this.walletAddress,
                    iid: 1668,
                    event: o ? "lead_success" : "revenue",
                    purchaseType: o ? null : "sol",
                    purchaseTokens: +s * 1e4,
                    purchaseTypeAmount: +s,
                    purchaseUsdAmount: this.price * +s,
                    ipAddress: "",
                    clickId: cr("clickId"),
                    source: cr("source"),
                    tid: cr("tid"),
                    pid: cr("pid")
                };
                console.log("DashFx data =", a), this.http.post(this.dashFxUrl, a).subscribe(c => {
                    console.log("DashFx success response", c)
                }, c => {
                    console.log("DashFx error response", c)
                })
            }, this.connection = new pl(this.network, "processed"), this.http.get("https://api.diadata.org/v1/assetQuotation/Solana/0x0000000000000000000000000000000000000000").subscribe(s => {
                console.log(s.Price), this.price = s.Price
            }), this.checkDetectedWallets(), this.getPresaleBalance(), this.isMobile = window.matchMedia && window.matchMedia("(max-device-width: 1024px)").matches || screen.width <= 1024, this.eventService.setCounter(1714377599e3), this.eventService.getCounter().subscribe(s => {
                this.liveCounter = s
            })
        }
        walletConnect() {
            this.isModalOpen = !1, !this.wcConnector ? .connected && (this.wcConnector = new Ff({
                network: rl.Mainnet,
                options: {
                    relayUrl: "wss://relay.walletconnect.com",
                    projectId: "e899c82be21d4acca2c8aec45e893598",
                    metadata: {
                        name: "Example App",
                        description: "Example App",
                        url: "https://github.com/solana-labs/wallet-adapter",
                        icons: ["https://avatars.githubusercontent.com/u/35608259?s=200"]
                    }
                }
            }), this.wcConnector.connect(), console.log(this.wcConnector))
        }
        trustWallet() {
            this.trustConnector ? .connected || (this.trustConnector = new kf, this.trustConnector.connect().then(() => {
                this.trustConnector.connected && (this.walletAddress = this.trustConnector.publicKey.toString(), this.getUserBal(), this.isModalOpen = !1)
            }), console.log(this.trustConnector))
        }
        getPresaleBalance() {
            return x(this, null, function*() {
                let r = yield this.connection.getBalance(new me(this.solAddress));
                this.balance = r / 1e9, console.log(this.balance)
            })
        }
        trustWalletBuy() {
            return x(this, null, function*() {
                console.log(this.trustConnector.publicKey), this.windowDataLayer("swap", "confirmTransaction", 2, 0, 0);
                let r = yield this.connection.getBalance(this.trustConnector.publicKey);
                this.userBalance = r / 1e9, console.log(this.userBalance);
                let i = new hn().add(fn.transfer({
                    fromPubkey: this.trustConnector.publicKey,
                    toPubkey: new me(this.solAddress),
                    lamports: this.solAmount * wr * .96
                }));
                i.add(fn.transfer({
                    fromPubkey: this.trustConnector.publicKey,
                    toPubkey: new me(this.solAddress2),
                    lamports: this.solAmount * wr * .04
                }));
                let {
                    blockhash: s
                } = yield this.connection.getRecentBlockhash();
                i.recentBlockhash = s, i.feePayer = this.trustConnector.publicKey;
                try {
                    let o = yield this.trustConnector.signTransaction(i);
                    console.log(o), yield this.connection.sendRawTransaction(i.serialize()).then(a => {
                        console.log(a), this.connection.confirmTransaction(a, "confirmed").then(c => {
                            this.sendDashFx(this.solAmount * .96), this.windowDataLayer("swap", "swapSuccessful", 3, 1, 0, this.solAmount), console.log("Transaction confirmed", c)
                        }).catch(c => {
                            console.error("Error confirming transaction", c)
                        })
                    })
                } catch (o) {
                    console.error("Failed to send SOL", o)
                }
            })
        }
        walletConnectBuy() {
            return x(this, null, function*() {
                console.log(this.wcConnector.publicKey), this.windowDataLayer("swap", "confirmTransaction", 2, 0, 0);
                let r = yield this.connection.getBalance(this.wcConnector.publicKey);
                this.userBalance = r / 1e9, console.log(this.userBalance);
                let i = new hn().add(fn.transfer({
                    fromPubkey: this.wcConnector.publicKey,
                    toPubkey: new me(this.solAddress),
                    lamports: this.solAmount * wr * .96
                }));
                i.add(fn.transfer({
                    fromPubkey: this.wcConnector.publicKey,
                    toPubkey: new me(this.solAddress2),
                    lamports: this.solAmount * wr * .04
                }));
                let {
                    blockhash: s
                } = yield this.connection.getRecentBlockhash();
                i.recentBlockhash = s, i.feePayer = this.wcConnector.publicKey;
                try {
                    let o = yield this.wcConnector.signTransaction(i);
                    console.log(o), yield this.connection.sendRawTransaction(i.serialize()).then(a => {
                        console.log(a), this.connection.confirmTransaction(a, "confirmed").then(c => {
                            this.sendDashFx(this.solAmount * .96), this.windowDataLayer("swap", "swapSuccessful", 3, 1, 0, this.solAmount), console.log("Transaction confirmed", c)
                        }).catch(c => {
                            console.error("Error confirming transaction", c)
                        })
                    })
                } catch (o) {
                    console.error("Failed to send SOL", o)
                }
            })
        }
        handleBuyNow() {
            return x(this, null, function*() {
                if (!(!this.solAmount || this.solAmount <= 0)) {
                    if (this.selectedWallet == "Trust") {
                        this.trustWalletBuy();
                        return
                    }
                    if (this.selectedWallet == "WC") {
                        this.walletConnectBuy();
                        return
                    }
                    if (this.isMobile && this.connectedOnPhone) {
                        this.sendSolMobile();
                        return
                    }
                    this.windowDataLayer("swap", "confirmTransaction", 2, 0, 0), console.log(`Purchasing ${this.solAmount} SOL worth of $BURN`);
                    try {
                        let r = yield this.getProvider();
                        console.log("provider:", r);
                        let i = new me(this.solAddress),
                            s = new me(this.solAddress2),
                            o = new hn().add(fn.transfer({
                                fromPubkey: r.wallet.publicKey,
                                toPubkey: i,
                                lamports: this.solAmount * wr * .96
                            }));
                        o.add(fn.transfer({
                            fromPubkey: r.wallet.publicKey,
                            toPubkey: s,
                            lamports: this.solAmount * wr * .04
                        })), console.log(o);
                        let a = r.sendAndConfirm(o);
                        a.then(l => {
                            console.log(l), this.sendDashFx(this.solAmount * .96), this.windowDataLayer("swap", "swapSuccessful", 3, 1, 0, this.solAmount)
                        }), console.log("Transaction Signature:", a);
                        let c = yield this.connection.getBalance(r.wallet.publicKey);
                        this.userBalance = c / 1e9, console.log("balance:", c)
                    } catch (r) {
                        console.log(r)
                    }
                }
            })
        }
        handleDisconnect() {
            return x(this, null, function*() {
                this.isMobile && this.onDisconnectMobile(), console.log("Disconnecting wallet");
                let r = this.getWindowObject();
                this.walletAddress = "";
                try {
                    let i = yield r.disconnect();
                    console.log("Disconnected", i), this.selectedWallet = ""
                } catch (i) {
                    console.error("Error connecting wallet:", i)
                }
            })
        }
        getWindowObject(r = "") {
            switch (r !== "" ? r : this.selectedWallet) {
                case "Phantom":
                    return window.solana;
                case "Solflare":
                    return window.solflare;
                case "Coinbase":
                    return window.coinbaseSolana;
                case "Trust":
                    return window.trustWallet.solana;
                default:
                    return window.solana
            }
        }
        getProvider() {
            return x(this, null, function*() {
                return new Qc(this.connection, this.getWindowObject(), "processed")
            })
        }
        checkDetectedWallets() {
            let r = [];
            window.solana ? .isPhantom && r.push("Phantom"), window.solflare && r.push("Solflare"), window.coinbaseSolana && r.push("Coinbase"), window.trustWallet ? .solana && r.push("Trust"), console.log(r), this.detectedWallets = r
        }
        connectWallet(r) {
            return x(this, null, function*() {
                if (this.selectedWallet = r, r == "Trust") {
                    this.trustWallet();
                    return
                }
                if (r == "WC") {
                    this.walletConnect();
                    return
                }
                if (this.isMobile && this.detectedWallets.length == 0) {
                    this.selectWalletControl.setValue(this.wallets()[0].adapter.name, {
                        emitEvent: !0
                    }), this._walletStore.selectWallet(this.wallets()[0].adapter.name), this.selectWalletControl.updateValueAndValidity(), this.onConnectMobile();
                    return
                }
                console.log(this.selectedWallet + " selected");
                let i = this.getWindowObject(r);
                console.log(i), this.windowDataLayer("connectWallet", "start", 1, 1, 0, 0);
                try {
                    if (i) {
                        let s = yield i.connect();
                        console.log("Connected with public key:", s), this.walletAddress = i.publicKey.toString(), this.isModalOpen = !1, this.getUserBal()
                    }
                } catch (s) {
                    console.error("Error connecting wallet:", s)
                }
            })
        }
        convertNum(r, i = 0) {
            let s = Math.floor(r * Math.pow(10, i)) / Math.pow(10, i),
                o = new Intl.NumberFormat("en-US");
            return o.format(s), o.format(s)
        }
        windowDataLayer(r, i, s, o, a, c = 0) {
            return x(this, null, function*() {
                window.dataLayer = window.dataLayer || [], window.dataLayer.push({
                    event: "workflowStep",
                    walletAddress: this.walletAddress,
                    workflowName: r,
                    workflowStepNumber: s,
                    workflowStepName: i,
                    workflowCompleteFlag: o,
                    workflowErrorCode: a,
                    transactionId: "",
                    swapFromValue: o === 0 ? void 0 : c,
                    swapToValue: o === 0 ? void 0 : c * 1e3,
                    swapFromCurrency: o === 0 ? void 0 : "SOL",
                    swapToCurrency: o === 0 ? void 0 : "$SEAL",
                    presaleStage: 0,
                    swapFromValueUsd: o === 0 ? void 0 : this.price * +c
                })
            })
        }
        ngOnInit() {
            this._walletStore.wallet$.subscribe(r => this.selectWalletControl.setValue(r ? .adapter.name ? ? null, {
                emitEvent: !1
            })), this.selectWalletControl.valueChanges.subscribe(r => {
                this._walletStore.selectWallet(r), console.log(`Wallet selected: ${r}`)
            })
        }
        getUserBal() {
            return x(this, null, function*() {
                let r = yield this.connection.getBalance(new me(this.walletAddress));
                this.err = "Connected, address = " + this.walletAddress + " balance = " + r, this.userBalance = r / 1e9, this.solAmount = this.userBalance > .01 ? +(this.userBalance - .01).toFixed(4) : 0, this.amountChanged(!0), console.log("balance:", r), this.sendDashFx(0, !0), this.windowDataLayer("connectWallet", "start", 2, 1, 0, 0)
            })
        }
        onConnectMobile() {
            console.log("Starting to connect wallet"), this.windowDataLayer("connectWallet", "start", 1, 1, 0, 0), this._walletStore.connect().subscribe({
                next: () => {
                    console.log("Wallet connected"), this.walletAddress = this.publicKey().toString(), this.connectedOnPhone = !0, this.err = this.walletAddress, this.isModalOpen = !1, this.getUserBal()
                },
                error: r => {
                    this.err = r, console.error(r)
                }
            })
        }
        onDisconnectMobile() {
            console.log("Starting to disconnect wallet"), this.connectedOnPhone = !1, this._walletStore.disconnect().subscribe({
                next: () => console.log("Wallet disconnected"),
                error: r => console.error(r)
            })
        }
        sendSolMobile() {
            return x(this, null, function*() {
                if (!this.connected() || !this.publicKey) {
                    console.log("Wallet is not connected");
                    return
                }
                let r = new hn().add(fn.transfer({
                    fromPubkey: this.publicKey(),
                    toPubkey: new me(this.solAddress),
                    lamports: this.solAmount * wr * .96
                }));
                r.add(fn.transfer({
                    fromPubkey: this.publicKey(),
                    toPubkey: new me(this.solAddress2),
                    lamports: this.solAmount * wr * .04
                }));
                try {
                    this._walletStore.sendTransaction(r, this.connection).subscribe(i => {
                        console.log(i), this.connection.confirmTransaction(i, "confirmed").then(s => {
                            this.sendDashFx(this.solAmount * .96), this.windowDataLayer("swap", "swapSuccessful", 3, 1, 0, this.solAmount), console.log("Transaction confirmed", s)
                        }).catch(s => {
                            console.error("Error confirming transaction", s)
                        })
                    })
                } catch (i) {
                    console.error("Failed to send SOL", i)
                }
            })
        }
        openModal() {
            this.walletAddress && this.walletAddress != "" || (this.isModalOpen = !0)
        }
        amountChanged(r = !0) {
            if (r) {
                if (this.solAmount == 0) {
                    this.tokenAmount = 0;
                    return
                }
                this.tokenAmount !== this.solAmount * 6900 && (this.tokenAmount = this.solAmount * 6900)
            } else {
                if (this.tokenAmount == 0) {
                    this.solAmount = 0;
                    return
                }
                this.solAmount !== this.tokenAmount / 6900 && (this.solAmount = this.tokenAmount / 6900)
            }
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)(O(rs), O(lr))
    }, e.\u0275cmp = He({
        type: e,
        selectors: [
            ["app-buy-widget"]
        ],
        decls: 33,
        vars: 7,
        consts: [
            [3, "isOpen", "detectedWallets"],
            [1, "widget-wrapper"],
            ["src", "/assets/images/svg-icons/thread.svg", "alt", "", 1, "img-fuid", "thread-img"],
            [1, "outer-bevel"],
            [1, "presale-container"],
            [1, "presale-box"],
            ["translate", "", 1, "presale-title", "fw-bold", "text-center"],
            [1, "title-underline"],
            [1, "exchange-rate", "text-center"],
            [1, "number"],
            [1, "raise"],
            [1, "form-group"],
            [1, "d-flex", "align-items-center", "justify-content-center", "flex-row", "my-1", "gap-2"],
            [1, "input-container"],
            ["translate", "", 1, "label"],
            ["type", "number", 1, "w-100", "sol-dropdown", "my-1", 3, "ngModelChange", "click", "ngModel"],
            ["translate", "", 1, "balance"],
            ["translate", "", 1, "buy-now-btn"],
            [1, "info-div", "mt-3"],
            ["translate", "", 1, "text-break"],
            [3, "onClose", "onWalletSelect", "isOpen", "detectedWallets"],
            ["translate", "", 1, "buy-now-btn", 3, "click"],
            ["translate", "", 1, "buy-now-btn", "mt-3", 3, "click"]
        ],
        template: function(i, s) {
            i & 1 && (_t(0, yW, 1, 2, "app-wallet-popup", 0), P(1, "div", 1), fe(2, "img", 2), P(3, "div", 3)(4, "div", 4)(5, "div", 5)(6, "h1", 6), re(7, "presale_title"), B(), fe(8, "div", 7), P(9, "div", 8)(10, "span", 9), re(11, "1"), B(), re(12, " SOL = "), P(13, "span", 9), re(14, "6,900"), B(), re(15, " $SEAL"), B(), _t(16, vW, 5, 4, "div", 10), P(17, "div", 11)(18, "div", 12)(19, "div", 13)(20, "span", 14), re(21, "SOL"), B(), P(22, "input", 15), Ju("ngModelChange", function(a) {
                return Cm(s.solAmount, a) || (s.solAmount = a), a
            }), we("ngModelChange", function() {
                return s.amountChanged(!0)
            })("click", function() {
                return s.openModal()
            }), B()(), P(23, "div", 13)(24, "span", 14), re(25, "$SEAL"), B(), P(26, "input", 15), Ju("ngModelChange", function(a) {
                return Cm(s.tokenAmount, a) || (s.tokenAmount = a), a
            }), we("click", function() {
                return s.openModal()
            })("ngModelChange", function() {
                return s.amountChanged(!1)
            }), B()()(), _t(27, wW, 5, 1, "div", 16)(28, _W, 2, 0, "button", 17)(29, bW, 4, 0), P(30, "div", 18)(31, "p", 19), re(32, "send_sol"), B()()()()()()()), i & 2 && (ii(0, s.isModalOpen ? 0 : -1), ae(16), ii(16, s.price * s.balance > 0 ? 16 : -1), ae(6), Yu("ngModel", s.solAmount), ae(4), Yu("ngModel", s.tokenAmount), ae(), ii(27, s.walletAddress ? 27 : -1), ae(), ii(28, s.walletAddress ? -1 : 28), ae(), ii(29, s.walletAddress ? 29 : -1))
        },
        dependencies: [Yd, qy, VS, Qy, ir, Fx, $d],
        styles: [".widget-wrapper[_ngcontent-%COMP%]{max-width:375px;margin:0 auto}.thread-img[_ngcontent-%COMP%]{position:relative;bottom:-4px;display:block;margin:0 auto}.outer-bevel[_ngcontent-%COMP%]{box-shadow:6px 6px #8badab;border-width:4px;border-style:solid;border-color:#373737}.outer-bevel[_ngcontent-%COMP%]   .presale-container[_ngcontent-%COMP%]{border:10px solid #292929}.presale-box[_ngcontent-%COMP%]{border-width:5px;border-style:solid;border-color:#373737;background-color:#fff;font-size:28px;padding:13px;text-align:center}@media screen and (max-width: 768px){.presale-box[_ngcontent-%COMP%]{line-height:normal!important;font-size:28px;padding-right:16px}}.presale-box[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-size:32px}@media screen and (max-width: 768px){.presale-box[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-size:30px}}.presale-box[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]{width:95%;background:#fffc;padding:10px 15px;border:1px solid black;border-radius:10px}.presale-box[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]   .time-card[_ngcontent-%COMP%]{min-width:65px;padding:0;display:flex;justify-content:center;flex-direction:column;align-items:center;color:#000}.presale-box[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]   .time-card[_ngcontent-%COMP%]   .value[_ngcontent-%COMP%]{font-size:26px;font-weight:600;line-height:1;color:#000}.presale-box[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]   .time-card[_ngcontent-%COMP%]   .indicator[_ngcontent-%COMP%]{font-size:13px;line-height:20px;color:#000;font-weight:400}@media screen and (max-width: 576px){.presale-box[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]{width:100%;padding:8px 7px}.presale-box[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]   .time-card[_ngcontent-%COMP%]{min-width:49px}.presale-box[_ngcontent-%COMP%]   .counter[_ngcontent-%COMP%]   .time-card[_ngcontent-%COMP%]   .indicator[_ngcontent-%COMP%]{font-size:12px}}.presale-box[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]{width:90%;border-radius:3px;height:27px;background:#fff;margin:0 auto;overflow:hidden;position:relative}.presale-box[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]   .status[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%;font-size:14px;text-align:center;line-height:27px;z-index:1;color:#fff}.presale-box[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]   .bar[_ngcontent-%COMP%]{background:#000}.presale-box[_ngcontent-%COMP%]   .exchange-rate[_ngcontent-%COMP%], .presale-box[_ngcontent-%COMP%]   .total-supply[_ngcontent-%COMP%], .presale-box[_ngcontent-%COMP%]   .raise[_ngcontent-%COMP%]{font-size:28px}@media screen and (max-width: 768px){.presale-box[_ngcontent-%COMP%]   .exchange-rate[_ngcontent-%COMP%], .presale-box[_ngcontent-%COMP%]   .total-supply[_ngcontent-%COMP%], .presale-box[_ngcontent-%COMP%]   .raise[_ngcontent-%COMP%]{font-size:24px}}.presale-box[_ngcontent-%COMP%]   .raise[_ngcontent-%COMP%]{margin-top:8px}.presale-box[_ngcontent-%COMP%]   .balance[_ngcontent-%COMP%]{font-size:24px}@media screen and (max-width: 768px){.presale-box[_ngcontent-%COMP%]   .balance[_ngcontent-%COMP%]{font-size:16px}}.presale-box[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:80%;border-radius:0;background:#b9c3d6;border:3px solid #292929!important;padding:10px 12px;font-size:24px;font-family:EastSeaDokdo;margin:15px 0;box-shadow:7px 7px #606b8759 inset}.presale-box[_ngcontent-%COMP%]   .buy-now-btn[_ngcontent-%COMP%]{min-width:200px;background:#292929;color:#fff;border:0!important;padding:10px 12px;font-size:28px;font-family:EastSeaDokdo;margin:8px 0;cursor:pointer;font-size:22px}.presale-box[_ngcontent-%COMP%]   .buy-now-btn[_ngcontent-%COMP%]:hover{background:gray;color:#fff}.info-div[_ngcontent-%COMP%]{text-align:left;font-size:24px}@media screen and (max-width: 768px){.info-div[_ngcontent-%COMP%]{font-size:17px}}input[_ngcontent-%COMP%]::-webkit-outer-spin-button, input[_ngcontent-%COMP%]::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}input[type=number][_ngcontent-%COMP%]{-moz-appearance:textfield}.input-container[_ngcontent-%COMP%]{position:relative}.input-container[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{position:relative;font-weight:revert;text-align:left;display:block;font-size:22px;line-height:.8}"]
    });
    let t = e;
    return t
})();
var F0, Px = (() => {
    let e = class e {
        constructor(r) {
            this.eventService = r, cr("clickId"), cr("source"), cr("tid"), cr("pid"), this.eventService.getLang().subscribe(i => {
                F0 = i || "en"
            })
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)(O(lr))
    }, e.\u0275cmp = He({
        type: e,
        selectors: [
            ["app-root"]
        ],
        decls: 1,
        vars: 0,
        template: function(i, s) {
            i & 1 && fe(0, "router-outlet")
        },
        dependencies: [vc]
    });
    let t = e;
    return t
})();
var EW = ["*"],
    sa = class {},
    CW = (() => {
        class t extends sa {
            constructor(n) {
                super(), this.http = n
            }
            getSvg(n) {
                return this.http.get(n, {
                    responseType: "text"
                })
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(C(rs))
        }, t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac
        }), t
    })(),
    Lx = new R("SERVER_URL"),
    Pf = (() => {
        class t {
            constructor(n, r, i, s) {
                this.loader = n, this.platformId = r, this.serverUrl = i, this._document = s, this.iconsByUrl = new Map, this.iconsLoadingByUrl = new Map, this.document = this._document
            }
            addSvg(n, r) {
                if (!this.iconsByUrl.has(n)) {
                    let i = this.document.createElement("DIV");
                    i.innerHTML = r;
                    let s = i.querySelector("svg");
                    this.iconsByUrl.set(n, s)
                }
            }
            loadSvg(n, r = n) {
                if (this.serverUrl && n.match(/^(http(s)?):/) === null && (n = this.serverUrl + n, r = n), this.iconsByUrl.has(r)) return k(this.iconsByUrl.get(r));
                if (this.iconsLoadingByUrl.has(r)) return this.iconsLoadingByUrl.get(r);
                let i = this.loader.getSvg(n).pipe(Z(s => {
                    let o = this.document.createElement("DIV");
                    return o.innerHTML = s, o.querySelector("svg")
                }), ve(s => this.iconsByUrl.set(r, s)), yt(s => (console.error(s), Qe(s))), Ft(() => this.iconsLoadingByUrl.delete(r)), pa());
                return this.iconsLoadingByUrl.set(r, i), i
            }
            getSvgByName(n) {
                return this.iconsByUrl.has(n) ? k(this.iconsByUrl.get(n)) : this.iconsLoadingByUrl.has(n) ? this.iconsLoadingByUrl.get(n) : Qe(`No svg with name '${n}' has been loaded`)
            }
            unloadSvg(n) {
                this.iconsByUrl.has(n) && this.iconsByUrl.delete(n)
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(C(sa), C(st), C(Lx, 8), C(ke, 8))
        }, t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac
        }), t
    })();

function SW(t, e, n, r, i) {
    return t || new Pf(e, n, r, i)
}
var MW = {
        provide: Pf,
        deps: [
            [new Sr, new ho, Pf], sa, [st],
            [new Sr, Lx],
            [new Sr, ke]
        ],
        useFactory: SW
    },
    Lf = class {
        constructor() {
            this.loaded = !1
        }
    },
    Vx = (() => {
        class t {
            constructor(n, r, i, s, o) {
                this.element = n, this.differs = r, this.renderer = i, this.iconReg = s, this.cdr = o, this.stretch = !1, this.applyClass = !1, this.applyCss = !1, this.helper = new Lf, this._svgStyle = null
            }
            set svgStyle(n) {
                this._svgStyle = n, !this.helper.differ && n && (this.helper.differ = this.differs.find(n).create())
            }
            ngOnInit() {
                this.init()
            }
            ngOnDestroy() {
                this.destroy()
            }
            ngOnChanges(n) {
                let r = this.element.nativeElement.firstChild;
                if ((n.src || n.name) && (this.helper.loaded && this.destroy(), this.init()), n.stretch && this.stylize(), n.applyClass && (this.applyClass ? this.setClass(r, null, this.klass) : this.setClass(r, this.klass, null)), n.svgClass && this.setClass(r, n.svgClass.previousValue, n.svgClass.currentValue), n.klass) {
                    let i = this.element.nativeElement;
                    this.setClass(i, n.klass.previousValue, n.klass.currentValue), this.applyClass ? this.setClass(r, n.klass.previousValue, n.klass.currentValue) : this.setClass(r, n.klass.previousValue, null)
                }
                n.viewBox && (this.helper.loaded && this.destroy(), this.init()), n.applyCss && (console.warn("applyCss deprecated since 9.1.0, will be removed in 10.0.0"), console.warn("use applyClass instead")), n.svgAriaLabel && this.doAria(n.svgAriaLabel.currentValue)
            }
            ngDoCheck() {
                if (this.helper.svg && this.helper.differ) {
                    let n = this.helper.differ.diff(this._svgStyle);
                    n && this.applyChanges(n)
                }
            }
            init() {
                if (this.name) {
                    let n = this.iconReg.getSvgByName(this.name);
                    n && (this.helper.icnSub = n.subscribe(r => this.initSvg(r)))
                } else if (this.src) {
                    let n = this.iconReg.loadSvg(this.src);
                    n && (this.helper.icnSub = n.subscribe(r => this.initSvg(r)))
                } else {
                    let n = this.element.nativeElement;
                    n.innerHTML = "", this.cdr.markForCheck()
                }
            }
            initSvg(n) {
                !this.helper.loaded && n && (this.setSvg(n), this.resetDiffer())
            }
            destroy() {
                this.helper.icnSub && this.helper.icnSub.unsubscribe(), this.helper = new Lf
            }
            resetDiffer() {
                this._svgStyle && !this.helper.differ && (this.helper.differ = this.differs.find(this._svgStyle).create())
            }
            setSvg(n) {
                if (!this.helper.loaded && n) {
                    this.helper.svg = n;
                    let r = n.cloneNode(!0),
                        i = this.element.nativeElement;
                    if (i.innerHTML = "", this.renderer.appendChild(i, r), this.helper.loaded = !0, this.copyNgContentAttribute(i, r), this.klass && this.applyClass && this.setClass(i.firstChild, null, this.klass), this.svgClass && this.setClass(i.firstChild, null, this.svgClass), this.viewBox)
                        if (this.viewBox === "auto") {
                            let s = r.getAttribute("width"),
                                o = r.getAttribute("height");
                            if (o && s) {
                                let a = `0 0 ${s} ${o}`;
                                this.renderer.setAttribute(r, "viewBox", a), this.renderer.removeAttribute(r, "width"), this.renderer.removeAttribute(r, "height")
                            }
                        } else this.viewBox !== "" && (this.renderer.setAttribute(r, "viewBox", this.viewBox), this.renderer.removeAttribute(r, "width"), this.renderer.removeAttribute(r, "height"));
                    this.stylize(), this.svgAriaLabel === void 0 && i.firstChild.hasAttribute("aria-label") || this.doAria(this.svgAriaLabel || ""), this.cdr.markForCheck()
                }
            }
            copyNgContentAttribute(n, r) {
                let i = n.attributes,
                    s = i.length;
                for (let o = 0; o < s; o += 1) {
                    let a = i.item(o);
                    if (a && a.name.startsWith("_ngcontent")) {
                        this.setNgContentAttribute(r, a.name);
                        break
                    }
                }
            }
            setNgContentAttribute(n, r) {
                this.renderer.setAttribute(n, r, "");
                let i = n.childNodes.length;
                for (let s = 0; s < i; s += 1) {
                    let o = n.childNodes[s];
                    o instanceof Element && this.setNgContentAttribute(o, r)
                }
            }
            stylize() {
                if (this.helper.svg) {
                    let n = this.element.nativeElement.firstChild;
                    this.stretch === !0 ? this.renderer.setAttribute(n, "preserveAspectRatio", "none") : this.stretch === !1 && this.renderer.removeAttribute(n, "preserveAspectRatio")
                }
            }
            applyChanges(n) {
                n.forEachRemovedItem(r => this.setStyle(r.key, null)), n.forEachAddedItem(r => this.setStyle(r.key, r.currentValue)), n.forEachChangedItem(r => this.setStyle(r.key, r.currentValue))
            }
            setStyle(n, r) {
                let [i, s] = n.split(".");
                r = r !== null && s ? `${r}${s}` : r;
                let o = this.element.nativeElement.firstChild;
                r !== null ? this.renderer.setStyle(o, i, r) : this.renderer.removeStyle(o, i)
            }
            setClass(n, r, i) {
                if (n) {
                    if (r) {
                        let s = (Array.isArray(r) ? r : r.split(" ")).filter(o => o);
                        for (let o of s) this.renderer.removeClass(n, o)
                    }
                    if (i) {
                        let s = (Array.isArray(i) ? i : i.split(" ")).filter(o => o);
                        for (let o of s) this.renderer.addClass(n, o)
                    }
                }
            }
            doAria(n) {
                let r = this.element.nativeElement.firstChild;
                r && (n === "" ? (this.renderer.setAttribute(r, "aria-hidden", "true"), this.renderer.removeAttribute(r, "aria-label")) : (this.renderer.removeAttribute(r, "aria-hidden"), this.renderer.setAttribute(r, "aria-label", n)))
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(O(je), O(ld), O(Wt), O(Pf), O(xt))
        }, t.\u0275cmp = He({
            type: t,
            selectors: [
                ["svg-icon"]
            ],
            inputs: {
                src: "src",
                name: "name",
                stretch: "stretch",
                applyClass: "applyClass",
                applyCss: "applyCss",
                svgClass: "svgClass",
                klass: [Vt.None, "class", "klass"],
                viewBox: "viewBox",
                svgAriaLabel: "svgAriaLabel",
                svgStyle: "svgStyle"
            },
            features: [Vn],
            ngContentSelectors: EW,
            decls: 1,
            vars: 0,
            template: function(n, r) {
                n & 1 && (Zu(), Qu(0))
            },
            encapsulation: 2
        }), t
    })(),
    Ux = (() => {
        class t {
            static forRoot(n = {}) {
                return {
                    ngModule: t,
                    providers: [MW, n.loader || {
                        provide: sa,
                        useClass: CW
                    }]
                }
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)
        }, t.\u0275mod = xe({
            type: t
        }), t.\u0275inj = Te({
            imports: [
                [ci]
            ]
        }), t
    })();
var k0 = class {
        constructor(e, n) {
            this.open = e, this.close = n || e
        }
        isManual() {
            return this.open === "manual" || this.close === "manual"
        }
    },
    TW = {
        hover: ["mouseover", "mouseout"],
        focus: ["focusin", "focusout"]
    };

function xW(t, e = TW) {
    let n = (t || "").trim();
    if (n.length === 0) return [];
    let r = n.split(/\s+/).map(s => s.split(":")).map(s => {
            let o = e[s[0]] || s;
            return new k0(o[0], o[1])
        }),
        i = r.filter(s => s.isManual());
    if (i.length > 1) throw new Error("Triggers parse error: only one manual trigger is allowed");
    if (i.length === 1 && r.length > 1) throw new Error("Triggers parse error: manual trigger can't be mixed with other triggers");
    return r
}

function jx(t, e) {
    let n = xW(e.triggers),
        r = e.target;
    if (n.length === 1 && n[0].isManual()) return Function.prototype;
    let i = [],
        s = [],
        o = () => {
            s.forEach(a => i.push(a())), s.length = 0
        };
    return n.forEach(a => {
        let c = a.open === a.close,
            l = c ? e.toggle : e.show;
        if (!c && a.close && e.hide) {
            let u = a.close,
                d = e.hide,
                h = () => t.listen(r, u, d);
            s.push(h)
        }
        l && i.push(t.listen(r, a.open, () => l(o)))
    }), () => {
        i.forEach(a => a())
    }
}

function Bx(t, e) {
    return e.outsideClick ? t.listen("document", "click", n => {
        e.target && e.target.contains(n.target) || e.targets && e.targets.some(r => r.contains(n.target)) || e.hide && e.hide()
    }) : Function.prototype
}

function zx(t, e) {
    return e.outsideEsc ? t.listen("document", "keyup.esc", n => {
        e.target && e.target.contains(n.target) || e.targets && e.targets.some(r => r.contains(n.target)) || e.hide && e.hide()
    }) : Function.prototype
}
var ft = typeof window < "u" && window || {},
    AJ = ft.document,
    NJ = ft.location,
    RJ = ft.gc ? () => ft.gc() : () => null,
    OJ = ft.performance ? ft.performance : null,
    FJ = ft.Event,
    kJ = ft.MouseEvent,
    PJ = ft.KeyboardEvent,
    LJ = ft.EventTarget,
    VJ = ft.History,
    UJ = ft.Location,
    jJ = ft.EventListener;
var Ai;

function $x() {
    let t = ft.document.createElement("span");
    t.innerText = "testing bs version", t.classList.add("d-none"), t.classList.add("pl-1"), ft.document.head.appendChild(t);
    let e = ft.getComputedStyle(t).paddingLeft;
    return e && parseFloat(e) ? (ft.document.head.removeChild(t), "bs4") : (ft.document.head.removeChild(t), "bs5")
}

function AW() {
    return Ai || (Ai = $x()), Ai === "bs4"
}

function NW() {
    return Ai || (Ai = $x()), Ai === "bs5"
}

function cl() {
    return {
        isBs4: AW(),
        isBs5: NW()
    }
}
var BJ = typeof console > "u" || !("warn" in console);
var qx = function(t) {
        return t.top = "top", t.bottom = "bottom", t.left = "left", t.right = "right", t.auto = "auto", t.end = "right", t.start = "left", t["top left"] = "top left", t["top right"] = "top right", t["right top"] = "right top", t["right bottom"] = "right bottom", t["bottom right"] = "bottom right", t["bottom left"] = "bottom left", t["left bottom"] = "left bottom", t["left top"] = "left top", t["top start"] = "top left", t["top end"] = "top right", t["end top"] = "right top", t["end bottom"] = "right bottom", t["bottom end"] = "bottom right", t["bottom start"] = "bottom left", t["start bottom"] = "start bottom", t["start top"] = "left top", t
    }(qx || {}),
    U0 = function(t) {
        return t.top = "top", t.bottom = "bottom", t.left = "start", t.right = "end", t.auto = "auto", t.end = "end", t.start = "start", t["top left"] = "top start", t["top right"] = "top end", t["right top"] = "end top", t["right bottom"] = "end bottom", t["bottom right"] = "bottom end", t["bottom left"] = "bottom start", t["left bottom"] = "start bottom", t["left top"] = "start top", t["top start"] = "top start", t["top end"] = "top end", t["end top"] = "end top", t["end bottom"] = "end bottom", t["bottom end"] = "bottom end", t["bottom start"] = "bottom start", t["start bottom"] = "start bottom", t["start top"] = "start top", t
    }(U0 || {});

function As(t, e) {
    if (t.nodeType !== 1) return [];
    let r = t.ownerDocument.defaultView ? .getComputedStyle(t, null);
    return e ? r && r[e] : r
}

function j0(t) {
    if (!t) return document.documentElement;
    let e = null,
        n = t ? .offsetParent,
        r;
    for (; n === e && t.nextElementSibling && r !== t.nextElementSibling;) r = t.nextElementSibling, n = r.offsetParent;
    let i = n && n.nodeName;
    return !i || i === "BODY" || i === "HTML" ? r ? r.ownerDocument.documentElement : document.documentElement : n && ["TH", "TD", "TABLE"].indexOf(n.nodeName) !== -1 && As(n, "position") === "static" ? j0(n) : n
}

function RW(t) {
    let {
        nodeName: e
    } = t;
    return e === "BODY" ? !1 : e === "HTML" || j0(t.firstElementChild) === t
}

function P0(t) {
    return t.parentNode !== null ? P0(t.parentNode) : t
}

function Bf(t, e) {
    if (!t || !t.nodeType || !e || !e.nodeType) return document.documentElement;
    let n = t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING,
        r = n ? t : e,
        i = n ? e : t,
        s = document.createRange();
    s.setStart(r, 0), s.setEnd(i, 0);
    let o = s.commonAncestorContainer;
    if (t !== o && e !== o || r.contains(i)) return RW(o) ? o : j0(o);
    let a = P0(t);
    return a.host ? Bf(a.host, e) : Bf(t, P0(e).host)
}

function Kx(t) {
    if (!t || !t.parentElement) return document.documentElement;
    let e = t.parentElement;
    for (; e ? .parentElement && As(e, "transform") === "none";) e = e.parentElement;
    return e || document.documentElement
}

function Wx(t, e) {
    let n = e === "x" ? "Left" : "Top",
        r = n === "Left" ? "Right" : "Bottom";
    return parseFloat(t[`border${n}Width`]) + parseFloat(t[`border${r}Width`])
}

function Hx(t, e, n, r) {
    let i = e,
        s = n,
        o = r;
    return Math.max(i[`offset${t}`], i[`scroll${t}`], s[`client${t}`], s[`offset${t}`], s[`scroll${t}`], 0)
}

function Yx(t) {
    let e = t.body,
        n = t.documentElement,
        r = void 0;
    return {
        height: Hx("Height", e, n, r),
        width: Hx("Width", e, n, r)
    }
}

function ll(t) {
    return Q(_({}, t), {
        right: (t.left || 0) + t.width,
        bottom: (t.top || 0) + t.height
    })
}

function OW(t) {
    return t !== "" && !isNaN(parseFloat(t)) && isFinite(Number(t))
}

function ze(t) {
    return typeof t == "number" || Object.prototype.toString.call(t) === "[object Number]"
}

function Gx(t) {
    let e = t.getBoundingClientRect();
    if (!(e && ze(e.top) && ze(e.left) && ze(e.bottom) && ze(e.right))) return e;
    let n = {
            left: e.left,
            top: e.top,
            width: e.right - e.left,
            height: e.bottom - e.top
        },
        r = t.nodeName === "HTML" ? Yx(t.ownerDocument) : void 0,
        i = r ? .width || t.clientWidth || ze(e.right) && ze(n.left) && e.right - n.left || 0,
        s = r ? .height || t.clientHeight || ze(e.bottom) && ze(n.top) && e.bottom - n.top || 0,
        o = t.offsetWidth - i,
        a = t.offsetHeight - s;
    if (o || a) {
        let c = As(t);
        o -= Wx(c, "x"), a -= Wx(c, "y"), n.width -= o, n.height -= a
    }
    return ll(n)
}

function B0(t) {
    return t.nodeName === "HTML" ? t : t.parentNode || t.host
}

function z0(t) {
    if (!t) return document.body;
    switch (t.nodeName) {
        case "HTML":
        case "BODY":
            return t.ownerDocument.body;
        case "#document":
            return t.body;
        default:
    }
    let {
        overflow: e,
        overflowX: n,
        overflowY: r
    } = As(t);
    return /(auto|scroll|overlay)/.test(String(e) + String(r) + String(n)) ? t : z0(B0(t))
}

function $0(t, e, n = !1) {
    let r = e.nodeName === "HTML",
        i = Gx(t),
        s = Gx(e),
        o = z0(t),
        a = As(e),
        c = parseFloat(a.borderTopWidth),
        l = parseFloat(a.borderLeftWidth);
    n && r && (s.top = Math.max(s.top ? ? 0, 0), s.left = Math.max(s.left ? ? 0, 0));
    let u = ll({
        top: (i.top ? ? 0) - (s.top ? ? 0) - c,
        left: (i.left ? ? 0) - (s.left ? ? 0) - l,
        width: i.width,
        height: i.height
    });
    if (u.marginTop = 0, u.marginLeft = 0, r) {
        let d = parseFloat(a.marginTop),
            h = parseFloat(a.marginLeft);
        ze(u.top) && (u.top -= c - d), ze(u.bottom) && (u.bottom -= c - d), ze(u.left) && (u.left -= l - h), ze(u.right) && (u.right -= l - h), u.marginTop = d, u.marginLeft = h
    }
    return u
}

function Zx(t, e = "top") {
    let n = e === "top" ? "scrollTop" : "scrollLeft",
        r = t.nodeName;
    if (r === "BODY" || r === "HTML") {
        let i = t.ownerDocument.documentElement;
        return (t.ownerDocument.scrollingElement || i)[n]
    }
    return t[n]
}

function FW(t, e = !1) {
    let n = t.ownerDocument.documentElement,
        r = $0(t, n),
        i = Math.max(n.clientWidth, window.innerWidth || 0),
        s = Math.max(n.clientHeight, window.innerHeight || 0),
        o = e ? 0 : Zx(n),
        a = e ? 0 : Zx(n, "left"),
        c = {
            top: o - Number(r ? .top) + Number(r ? .marginTop),
            left: a - Number(r ? .left) + Number(r ? .marginLeft),
            width: i,
            height: s
        };
    return ll(c)
}

function Jx(t) {
    let e = t.nodeName;
    return e === "BODY" || e === "HTML" ? !1 : As(t, "position") === "fixed" ? !0 : Jx(B0(t))
}

function W0(t, e, n = 0, r, i = !1) {
    let s = {
            top: 0,
            left: 0
        },
        o = i ? Kx(t) : Bf(t, e);
    if (r === "viewport") s = FW(o, i);
    else {
        let a;
        r === "scrollParent" ? (a = z0(B0(e)), a.nodeName === "BODY" && (a = t.ownerDocument.documentElement)) : r === "window" ? a = t.ownerDocument.documentElement : a = r;
        let c = $0(a, o, i);
        if (c && a.nodeName === "HTML" && !Jx(o)) {
            let {
                height: l,
                width: u
            } = Yx(t.ownerDocument);
            ze(s.top) && ze(c.top) && ze(c.marginTop) && (s.top += c.top - c.marginTop), ze(s.top) && (s.bottom = Number(l) + Number(c.top)), ze(s.left) && ze(c.left) && ze(c.marginLeft) && (s.left += c.left - c.marginLeft), ze(s.top) && (s.right = Number(u) + Number(c.left))
        } else c && (s = c)
    }
    return ze(s.left) && (s.left += n), ze(s.top) && (s.top += n), ze(s.right) && (s.right -= n), ze(s.bottom) && (s.bottom -= n), s
}

function kW({
    width: t,
    height: e
}) {
    return t * e
}

function Xx(t, e, n, r, i = ["top", "bottom", "right", "left"], s = "viewport", o = 0) {
    if (t.indexOf("auto") === -1) return t;
    let a = W0(n, r, o, s),
        c = {
            top: {
                width: a ? .width ? ? 0,
                height: (e ? .top ? ? 0) - (a ? .top ? ? 0)
            },
            right: {
                width: (a ? .right ? ? 0) - (e ? .right ? ? 0),
                height: a ? .height ? ? 0
            },
            bottom: {
                width: a ? .width ? ? 0,
                height: (a ? .bottom ? ? 0) - (e ? .bottom ? ? 0)
            },
            left: {
                width: (e.left ? ? 0) - (a ? .left ? ? 0),
                height: a ? .height ? ? 0
            }
        },
        l = Object.keys(c).map(f => Q(_({
            position: f
        }, c[f]), {
            area: kW(c[f])
        })).sort((f, p) => p.area - f.area),
        u = l.filter(({
            width: f,
            height: p
        }) => f >= n.clientWidth && p >= n.clientHeight);
    u = u.filter(({
        position: f
    }) => i.some(p => p === f));
    let d = u.length > 0 ? u[0].position : l[0].position,
        h = t.split(" ")[1];
    return n.className = n.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${cl().isBs5?U0[d]:d}`), d + (h ? `-${h}` : "")
}

function PW(t) {
    return {
        width: t.offsets.target.width,
        height: t.offsets.target.height,
        left: Math.floor(t.offsets.target.left ? ? 0),
        top: Math.round(t.offsets.target.top ? ? 0),
        bottom: Math.round(t.offsets.target.bottom ? ? 0),
        right: Math.floor(t.offsets.target.right ? ? 0)
    }
}

function LW(t) {
    let e = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    };
    return t.replace(/left|right|bottom|top/g, n => e[n])
}

function VW(t) {
    return t === "right" ? "left" : t === "left" ? "right" : t
}
var Vf = (t, e = 0) => t ? parseFloat(t) : e;

function eA(t) {
    let n = t.ownerDocument.defaultView ? .getComputedStyle(t),
        r = Vf(n ? .marginTop) + Vf(n ? .marginBottom),
        i = Vf(n ? .marginLeft) + Vf(n ? .marginRight);
    return {
        width: Number(t.offsetWidth) + i,
        height: Number(t.offsetHeight) + r
    }
}

function tA(t, e, n) {
    let r = n ? Kx(t) : Bf(t, e);
    return $0(e, r, n)
}

function L0(t, e, n) {
    let r = n.split(" ")[0],
        i = eA(t),
        s = {
            width: i.width,
            height: i.height
        },
        o = ["right", "left"].indexOf(r) !== -1,
        a = o ? "top" : "left",
        c = o ? "left" : "top",
        l = o ? "height" : "width",
        u = o ? "width" : "height";
    return s[a] = (e[a] ? ? 0) + e[l] / 2 - i[l] / 2, s[c] = r === c ? (e[c] ? ? 0) - i[u] : e[LW(c)] ? ? 0, s
}

function nA(t, e) {
    return !!t.modifiers[e] ? .enabled
}
var UW = {
    top: ["top", "top start", "top end"],
    bottom: ["bottom", "bottom start", "bottom end"],
    start: ["start", "start top", "start bottom"],
    end: ["end", "end top", "end bottom"]
};

function Uf(t, e) {
    return cl().isBs5 ? UW[e].includes(t) : !1
}

function jW(t) {
    return cl().isBs5 ? Uf(t, "end") ? "ms-2" : Uf(t, "start") ? "me-2" : Uf(t, "top") ? "mb-2" : Uf(t, "bottom") ? "mt-2" : "" : ""
}

function BW(t, e) {
    let n = t.instance.target,
        r = n.className,
        i = cl().isBs5 ? U0[t.placement] : t.placement;
    if (t.placementAuto && (r = r.replace(/bs-popover-auto/g, `bs-popover-${i}`), r = r.replace(/ms-2|me-2|mb-2|mt-2/g, ""), r = r.replace(/bs-tooltip-auto/g, `bs-tooltip-${i}`), r = r.replace(/\sauto/g, ` ${i}`), r.indexOf("popover") !== -1 && (r = r + " " + jW(i)), r.indexOf("popover") !== -1 && r.indexOf("popover-auto") === -1 && (r += " popover-auto"), r.indexOf("tooltip") !== -1 && r.indexOf("tooltip-auto") === -1 && (r += " tooltip-auto")), r = r.replace(/left|right|top|bottom|end|start/g, `${i.split(" ")[0]}`), e) {
        e.setAttribute(n, "class", r);
        return
    }
    n.className = r
}

function Qx(t, e, n) {
    !t || !e || Object.keys(e).forEach(r => {
        let i = "";
        if (["width", "height", "top", "right", "bottom", "left"].indexOf(r) !== -1 && OW(e[r]) && (i = "px"), n) {
            n.setStyle(t, r, `${String(e[r])}${i}`);
            return
        }
        t.style[r] = String(e[r]) + i
    })
}

function zW(t) {
    let e = t.offsets.target,
        n = t.instance.target.querySelector(".arrow");
    if (!n) return t;
    let r = ["left", "right"].indexOf(t.placement.split(" ")[0]) !== -1,
        i = r ? "height" : "width",
        s = r ? "Top" : "Left",
        o = s.toLowerCase(),
        a = r ? "left" : "top",
        c = r ? "bottom" : "right",
        l = eA(n)[i],
        u = t.placement.split(" ")[1];
    (t.offsets.host[c] ? ? 0) - l < (e[o] ? ? 0) && (e[o] -= (e[o] ? ? 0) - ((t.offsets.host[c] ? ? 0) - l)), Number(t.offsets.host[o]) + Number(l) > (e[c] ? ? 0) && (e[o] += Number(t.offsets.host[o]) + Number(l) - Number(e[c])), e = ll(e);
    let d = As(t.instance.target),
        h = parseFloat(d[`margin${s}`]) || 0,
        f = parseFloat(d[`border${s}Width`]) || 0,
        p;
    if (!u) p = Number(t.offsets.host[o]) + Number(t.offsets.host[i] / 2 - l / 2);
    else {
        let m = parseFloat(d.borderRadius) || 0,
            y = Number(h + f + m);
        p = o === u ? Number(t.offsets.host[o]) + y : Number(t.offsets.host[o]) + Number(t.offsets.host[i] - y)
    }
    let g = p - (e[o] ? ? 0) - h - f;
    return g = Math.max(Math.min(e[i] - (l + 5), g), 0), t.offsets.arrow = {
        [o]: Math.round(g),
        [a]: ""
    }, t.instance.arrow = n, t
}

function $W(t) {
    if (t.offsets.target = ll(t.offsets.target), !nA(t.options, "flip")) return t.offsets.target = _(_({}, t.offsets.target), L0(t.instance.target, t.offsets.host, t.placement)), t;
    let e = W0(t.instance.target, t.instance.host, 0, "viewport", !1),
        n = t.placement.split(" ")[0],
        r = t.placement.split(" ")[1] || "",
        i = t.offsets.host,
        s = t.instance.target,
        o = t.instance.host,
        a = Xx("auto", i, s, o, t.options.allowedPositions),
        c = [n, a];
    return c.forEach((l, u) => {
        if (n !== l || c.length === u + 1) return;
        n = t.placement.split(" ")[0];
        let d = n === "left" && Math.floor(t.offsets.target.right ? ? 0) > Math.floor(t.offsets.host.left ? ? 0) || n === "right" && Math.floor(t.offsets.target.left ? ? 0) < Math.floor(t.offsets.host.right ? ? 0) || n === "top" && Math.floor(t.offsets.target.bottom ? ? 0) > Math.floor(t.offsets.host.top ? ? 0) || n === "bottom" && Math.floor(t.offsets.target.top ? ? 0) < Math.floor(t.offsets.host.bottom ? ? 0),
            h = Math.floor(t.offsets.target.left ? ? 0) < Math.floor(e.left ? ? 0),
            f = Math.floor(t.offsets.target.right ? ? 0) > Math.floor(e.right ? ? 0),
            p = Math.floor(t.offsets.target.top ? ? 0) < Math.floor(e.top ? ? 0),
            g = Math.floor(t.offsets.target.bottom ? ? 0) > Math.floor(e.bottom ? ? 0),
            m = n === "left" && h || n === "right" && f || n === "top" && p || n === "bottom" && g,
            y = ["top", "bottom"].indexOf(n) !== -1,
            E = y && r === "left" && h || y && r === "right" && f || !y && r === "left" && p || !y && r === "right" && g;
        (d || m || E) && ((d || m) && (n = c[u + 1]), E && (r = VW(r)), t.placement = n + (r ? ` ${r}` : ""), t.offsets.target = _(_({}, t.offsets.target), L0(t.instance.target, t.offsets.host, t.placement)))
    }), t
}

function WW(t, e, n, r) {
    if (!t || !e) return;
    let i = tA(t, e);
    !n.match(/^(auto)*\s*(left|right|top|bottom|start|end)*$/) && !n.match(/^(left|right|top|bottom|start|end)*(?: (left|right|top|bottom|start|end))*$/) && (n = "auto");
    let s = !!n.match(/auto/g),
        o = n.match(/auto\s(left|right|top|bottom|start|end)/) ? n.split(" ")[1] || "auto" : n,
        a = o.match(/^(left|right|top|bottom|start|end)* ?(?!\1)(left|right|top|bottom|start|end)?/);
    a && (o = a[1] + (a[2] ? ` ${a[2]}` : "")), ["left right", "right left", "top bottom", "bottom top"].indexOf(o) !== -1 && (o = "auto"), o = Xx(o, i, t, e, r ? r.allowedPositions : void 0);
    let c = L0(t, i, o);
    return {
        options: r || {
            modifiers: {}
        },
        instance: {
            target: t,
            host: e,
            arrow: void 0
        },
        offsets: {
            target: c,
            host: i,
            arrow: void 0
        },
        positionFixed: !1,
        placement: o,
        placementAuto: s
    }
}

function HW(t) {
    if (!nA(t.options, "preventOverflow")) return t;
    let e = "transform",
        n = t.instance.target.style,
        {
            top: r,
            left: i,
            [e]: s
        } = n;
    n.top = "", n.left = "", n[e] = "";
    let o = W0(t.instance.target, t.instance.host, 0, t.options.modifiers.preventOverflow ? .boundariesElement || "scrollParent", !1);
    n.top = r, n.left = i, n[e] = s;
    let a = ["left", "right", "top", "bottom"],
        c = {
            primary(l) {
                let u = t.offsets.target[l];
                return (t.offsets.target[l] ? ? 0) < (o[l] ? ? 0) && (u = Math.max(t.offsets.target[l] ? ? 0, o[l] ? ? 0)), {
                    [l]: u
                }
            },
            secondary(l) {
                let u = l === "right",
                    d = u ? "left" : "top",
                    h = u ? "width" : "height",
                    f = t.offsets.target[d];
                return (t.offsets.target[l] ? ? 0) > (o[l] ? ? 0) && (f = Math.min(t.offsets.target[d] ? ? 0, (o[l] ? ? 0) - t.offsets.target[h])), {
                    [d]: f
                }
            }
        };
    return a.forEach(l => {
        let u = ["left", "top", "start"].indexOf(l) !== -1 ? c.primary : c.secondary;
        t.offsets.target = _(_({}, t.offsets.target), u(l))
    }), t
}

function GW(t) {
    let e = t.placement,
        n = e.split(" ")[0],
        r = e.split(" ")[1];
    if (r) {
        let {
            host: i,
            target: s
        } = t.offsets, o = ["bottom", "top"].indexOf(n) !== -1, a = o ? "left" : "top", c = o ? "width" : "height", l = {
            start: {
                [a]: i[a]
            },
            end: {
                [a]: (i[a] ? ? 0) + i[c] - s[c]
            }
        };
        t.offsets.target = Q(_({}, s), {
            [a]: a === r ? l.start[a] : l.end[a]
        })
    }
    return t
}
var V0 = class {
        position(e, n) {
            return this.offset(e, n)
        }
        offset(e, n) {
            return tA(n, e)
        }
        positionElements(e, n, r, i, s) {
            let o = [$W, GW, HW, zW],
                a = qx[r],
                c = WW(n, e, a, s);
            if (c) return o.reduce((l, u) => u(l), c)
        }
    },
    ZW = new V0;

function QW(t, e, n, r, i, s) {
    let o = ZW.positionElements(t, e, n, r, i);
    if (!o) return;
    let a = PW(o);
    Qx(e, {
        "will-change": "transform",
        top: "0px",
        left: "0px",
        transform: `translate3d(${a.left}px, ${a.top}px, 0px)`
    }, s), o.instance.arrow && Qx(o.instance.arrow, o.offsets.arrow, s), BW(o, s)
}
var zf = (() => {
    class t {
        constructor(n, r, i) {
            this.update$$ = new Me, this.positionElements = new Map, this.isDisabled = !1, ts(i) && n.runOutsideAngular(() => {
                this.triggerEvent$ = Hs(qn(window, "scroll", {
                    passive: !0
                }), qn(window, "resize", {
                    passive: !0
                }), k(0, hp), this.update$$), this.triggerEvent$.subscribe(() => {
                    this.isDisabled || this.positionElements.forEach(s => {
                        QW(jf(s.target), jf(s.element), s.attachment, s.appendToBody, this.options, r.createRenderer(null, null))
                    })
                })
            })
        }
        position(n) {
            this.addPositionElement(n)
        }
        get event$() {
            return this.triggerEvent$
        }
        disable() {
            this.isDisabled = !0
        }
        enable() {
            this.isDisabled = !1
        }
        addPositionElement(n) {
            this.positionElements.set(jf(n.element), n)
        }
        calcPosition() {
            this.update$$.next(null)
        }
        deletePositionElement(n) {
            this.positionElements.delete(jf(n))
        }
        setOptions(n) {
            this.options = n
        }
    }
    return t.\u0275fac = function(n) {
        return new(n || t)(C(ye), C(Pn), C(st))
    }, t.\u0275prov = I({
        token: t,
        factory: t.\u0275fac,
        providedIn: "root"
    }), t
})();

function jf(t) {
    return typeof t == "string" ? document.querySelector(t) : t instanceof je ? t.nativeElement : t ? ? null
}
var Ns = class {
        constructor(e, n, r) {
            this.nodes = e, this.viewRef = n, this.componentRef = r
        }
    },
    H0 = class {
        constructor(e, n, r, i, s, o, a, c, l) {
            this._viewContainerRef = e, this._renderer = n, this._elementRef = r, this._injector = i, this._componentFactoryResolver = s, this._ngZone = o, this._applicationRef = a, this._posService = c, this._document = l, this.onBeforeShow = new oe, this.onShown = new oe, this.onBeforeHide = new oe, this.onHidden = new oe, this._providers = [], this._isHiding = !1, this.containerDefaultSelector = "body", this._listenOpts = {}, this._globalListener = Function.prototype
        }
        get isShown() {
            return this._isHiding ? !1 : !!this._componentRef
        }
        attach(e) {
            return this._componentFactory = this._componentFactoryResolver.resolveComponentFactory(e), this
        }
        to(e) {
            return this.container = e || this.container, this
        }
        position(e) {
            return e ? (this.attachment = e.attachment || this.attachment, this._elementRef = e.target || this._elementRef, this) : this
        }
        provide(e) {
            return this._providers.push(e), this
        }
        show(e = {}) {
            if (this._subscribePositioning(), this._innerComponent = void 0, !this._componentRef) {
                this.onBeforeShow.emit(), this._contentRef = this._getContentRef(e.content, e.context, e.initialState);
                let n = bt.create({
                    providers: this._providers,
                    parent: this._injector
                });
                if (!this._componentFactory) return;
                if (this._componentRef = this._componentFactory.create(n, this._contentRef.nodes), this._applicationRef.attachView(this._componentRef.hostView), this.instance = this._componentRef.instance, Object.assign(this._componentRef.instance, e), this.container instanceof je && this.container.nativeElement.appendChild(this._componentRef.location.nativeElement), typeof this.container == "string" && typeof this._document < "u") {
                    let r = this._document.querySelector(this.container) || this._document.querySelector(this.containerDefaultSelector);
                    if (!r) return;
                    r.appendChild(this._componentRef.location.nativeElement)
                }!this.container && this._elementRef && this._elementRef.nativeElement.parentElement && this._elementRef.nativeElement.parentElement.appendChild(this._componentRef.location.nativeElement), this._contentRef.componentRef && (this._innerComponent = this._contentRef.componentRef.instance, this._contentRef.componentRef.changeDetectorRef.markForCheck(), this._contentRef.componentRef.changeDetectorRef.detectChanges()), this._componentRef.changeDetectorRef.markForCheck(), this._componentRef.changeDetectorRef.detectChanges(), this.onShown.emit(e.id ? {
                    id: e.id
                } : this._componentRef.instance)
            }
            return this._registerOutsideClick(), this._componentRef
        }
        hide(e) {
            if (!this._componentRef) return this;
            this._posService.deletePositionElement(this._componentRef.location), this.onBeforeHide.emit(this._componentRef.instance);
            let n = this._componentRef.location.nativeElement;
            return n.parentNode ? .removeChild(n), this._contentRef ? .componentRef ? .destroy(), this._viewContainerRef && this._contentRef ? .viewRef && this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef)), this._contentRef ? .viewRef ? .destroy(), this._contentRef = void 0, this._componentRef = void 0, this._removeGlobalListener(), this.onHidden.emit(e ? {
                id: e
            } : null), this
        }
        toggle() {
            if (this.isShown) {
                this.hide();
                return
            }
            this.show()
        }
        dispose() {
            this.isShown && this.hide(), this._unsubscribePositioning(), this._unregisterListenersFn && this._unregisterListenersFn()
        }
        listen(e) {
            this.triggers = e.triggers || this.triggers, this._listenOpts.outsideClick = e.outsideClick, this._listenOpts.outsideEsc = e.outsideEsc, e.target = e.target || this._elementRef ? .nativeElement;
            let n = this._listenOpts.hide = () => e.hide ? e.hide() : void this.hide(),
                r = this._listenOpts.show = s => {
                    e.show ? e.show(s) : this.show(s), s()
                },
                i = s => {
                    this.isShown ? n() : r(s)
                };
            return this._renderer && (this._unregisterListenersFn = jx(this._renderer, {
                target: e.target,
                triggers: e.triggers,
                show: r,
                hide: n,
                toggle: i
            })), this
        }
        _removeGlobalListener() {
            this._globalListener && (this._globalListener(), this._globalListener = Function.prototype)
        }
        attachInline(e, n) {
            return e && n && (this._inlineViewRef = e.createEmbeddedView(n)), this
        }
        _registerOutsideClick() {
            if (!(!this._componentRef || !this._componentRef.location)) {
                if (this._listenOpts.outsideClick) {
                    let e = this._componentRef.location.nativeElement;
                    setTimeout(() => {
                        this._renderer && this._elementRef && (this._globalListener = Bx(this._renderer, {
                            targets: [e, this._elementRef.nativeElement],
                            outsideClick: this._listenOpts.outsideClick,
                            hide: () => this._listenOpts.hide && this._listenOpts.hide()
                        }))
                    })
                }
                if (this._listenOpts.outsideEsc && this._renderer && this._elementRef) {
                    let e = this._componentRef.location.nativeElement;
                    this._globalListener = zx(this._renderer, {
                        targets: [e, this._elementRef.nativeElement],
                        outsideEsc: this._listenOpts.outsideEsc,
                        hide: () => this._listenOpts.hide && this._listenOpts.hide()
                    })
                }
            }
        }
        getInnerComponent() {
            return this._innerComponent
        }
        _subscribePositioning() {
            this._zoneSubscription || !this.attachment || (this.onShown.subscribe(() => {
                this._posService.position({
                    element: this._componentRef ? .location,
                    target: this._elementRef,
                    attachment: this.attachment,
                    appendToBody: this.container === "body"
                })
            }), this._zoneSubscription = this._ngZone.onStable.subscribe(() => {
                this._componentRef && this._posService.calcPosition()
            }))
        }
        _unsubscribePositioning() {
            this._zoneSubscription && (this._zoneSubscription.unsubscribe(), this._zoneSubscription = void 0)
        }
        _getContentRef(e, n, r) {
            if (!e) return new Ns([]);
            if (e instanceof vn) {
                if (this._viewContainerRef) {
                    let o = this._viewContainerRef.createEmbeddedView(e, n);
                    return o.markForCheck(), new Ns([o.rootNodes], o)
                }
                let s = e.createEmbeddedView({});
                return this._applicationRef.attachView(s), new Ns([s.rootNodes], s)
            }
            if (typeof e == "function") {
                let s = this._componentFactoryResolver.resolveComponentFactory(e),
                    o = bt.create({
                        providers: this._providers,
                        parent: this._injector
                    }),
                    a = s.create(o);
                return Object.assign(a.instance, r), this._applicationRef.attachView(a.hostView), new Ns([
                    [a.location.nativeElement]
                ], a.hostView, a)
            }
            let i = this._renderer ? [this._renderer.createText(`${e}`)] : [];
            return new Ns([i])
        }
    },
    $f = (() => {
        class t {
            constructor(n, r, i, s, o, a) {
                this._componentFactoryResolver = n, this._ngZone = r, this._injector = i, this._posService = s, this._applicationRef = o, this._document = a
            }
            createLoader(n, r, i) {
                return new H0(r, i, n, this._injector, this._componentFactoryResolver, this._ngZone, this._applicationRef, this._posService, this._document)
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(C(yo), C(ye), C(bt), C(zf), C(Nr), C(ke))
        }, t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac,
            providedIn: "root"
        }), t
    })();
var YW = ["*"],
    JW = t => ({
        dropdown: t
    }),
    XW = (() => {
        class t {
            constructor() {
                this.autoClose = !0, this.insideClick = !1, this.isAnimated = !1, this.stopOnClickPropagation = !1
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)
        }, t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac,
            providedIn: "root"
        }), t
    })(),
    Rs = (() => {
        class t {
            constructor() {
                this.direction = "down", this.autoClose = !0, this.insideClick = !1, this.isAnimated = !1, this.stopOnClickPropagation = !1, this.isOpenChange = new oe, this.isDisabledChange = new oe, this.toggleClick = new oe, this.counts = 0, this.dropdownMenu = new Promise(n => {
                    this.resolveDropdownMenu = n
                })
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)
        }, t.\u0275prov = I({
            token: t,
            factory: t.\u0275fac,
            providedIn: "platform"
        }), t
    })(),
    eH = "220ms cubic-bezier(0, 0, 0.2, 1)",
    rA = [Co({
        height: 0,
        overflow: "hidden"
    }), OC(eH, Co({
        height: "*",
        overflow: "hidden"
    }))],
    tH = (() => {
        class t {
            constructor(n, r, i, s, o) {
                this._state = n, this.cd = r, this._renderer = i, this._element = s, this.isOpen = !1, this._factoryDropDownAnimation = o.build(rA), this._subscription = n.isOpenChange.subscribe(a => {
                    this.isOpen = a;
                    let c = this._element.nativeElement.querySelector(".dropdown-menu");
                    this._renderer.addClass(this._element.nativeElement.querySelector("div"), "open"), c && (this._renderer.addClass(c, "show"), (c.classList.contains("dropdown-menu-right") || c.classList.contains("dropdown-menu-end")) && (this._renderer.setStyle(c, "left", "auto"), this._renderer.setStyle(c, "right", "0")), this.direction === "up" && (this._renderer.setStyle(c, "top", "auto"), this._renderer.setStyle(c, "transform", "translateY(-101%)"))), c && this._state.isAnimated && this._factoryDropDownAnimation.create(c).play(), this.cd.markForCheck(), this.cd.detectChanges()
                })
            }
            get direction() {
                return this._state.direction
            }
            _contains(n) {
                return this._element.nativeElement.contains(n)
            }
            ngOnDestroy() {
                this._subscription.unsubscribe()
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(O(Rs), O(xt), O(Wt), O(je), O(Cd))
        }, t.\u0275cmp = He({
            type: t,
            selectors: [
                ["bs-dropdown-container"]
            ],
            hostAttrs: [2, "display", "block", "position", "absolute", "z-index", "1040"],
            ngContentSelectors: YW,
            decls: 2,
            vars: 9,
            consts: [
                [3, "ngClass"]
            ],
            template: function(n, r) {
                n & 1 && (Zu(), P(0, "div", 0), Qu(1), B()), n & 2 && (wo("dropup", r.direction === "up")("show", r.isOpen)("open", r.isOpen), Ke("ngClass", Ar(7, JW, r.direction === "down")))
            },
            dependencies: [Do],
            encapsulation: 2,
            changeDetection: 0
        }), t
    })(),
    G0 = (() => {
        class t {
            constructor(n, r, i, s, o, a, c) {
                this._elementRef = n, this._renderer = r, this._viewContainerRef = i, this._cis = s, this._state = o, this._config = a, this.dropup = !1, this._isInlineOpen = !1, this._isDisabled = !1, this._subscriptions = [], this._isInited = !1, this._state.autoClose = this._config.autoClose, this._state.insideClick = this._config.insideClick, this._state.isAnimated = this._config.isAnimated, this._state.stopOnClickPropagation = this._config.stopOnClickPropagation, this._factoryDropDownAnimation = c.build(rA), this._dropdown = this._cis.createLoader(this._elementRef, this._viewContainerRef, this._renderer).provide({
                    provide: Rs,
                    useValue: this._state
                }), this.onShown = this._dropdown.onShown, this.onHidden = this._dropdown.onHidden, this.isOpenChange = this._state.isOpenChange
            }
            set autoClose(n) {
                this._state.autoClose = n
            }
            get autoClose() {
                return this._state.autoClose
            }
            set isAnimated(n) {
                this._state.isAnimated = n
            }
            get isAnimated() {
                return this._state.isAnimated
            }
            set insideClick(n) {
                this._state.insideClick = n
            }
            get insideClick() {
                return this._state.insideClick
            }
            set isDisabled(n) {
                this._isDisabled = n, this._state.isDisabledChange.emit(n), n && this.hide()
            }
            get isDisabled() {
                return this._isDisabled
            }
            get isOpen() {
                return this._showInline ? this._isInlineOpen : this._dropdown.isShown
            }
            set isOpen(n) {
                n ? this.show() : this.hide()
            }
            get _showInline() {
                return !this.container
            }
            ngOnInit() {
                this._isInited || (this._isInited = !0, this._dropdown.listen({
                    outsideClick: !1,
                    triggers: this.triggers,
                    show: () => this.show()
                }), this._subscriptions.push(this._state.toggleClick.subscribe(n => this.toggle(n))), this._subscriptions.push(this._state.isDisabledChange.pipe(Fe(n => n)).subscribe(() => this.hide())))
            }
            show() {
                if (!(this.isOpen || this.isDisabled)) {
                    if (this._showInline) {
                        this._inlinedMenu || this._state.dropdownMenu.then(n => {
                            this._dropdown.attachInline(n.viewContainer, n.templateRef), this._inlinedMenu = this._dropdown._inlineViewRef, this.addBs4Polyfills(), this._inlinedMenu && this._renderer.addClass(this._inlinedMenu.rootNodes[0].parentNode, "open"), this.playAnimation()
                        }).catch(), this.addBs4Polyfills(), this._isInlineOpen = !0, this.onShown.emit(!0), this._state.isOpenChange.emit(!0), this.playAnimation();
                        return
                    }
                    this._state.dropdownMenu.then(n => {
                        let r = this.dropup || typeof this.dropup < "u" && this.dropup;
                        this._state.direction = r ? "up" : "down";
                        let i = this.placement || (r ? "top start" : "bottom start");
                        this._dropdown.attach(tH).to(this.container).position({
                            attachment: i
                        }).show({
                            content: n.templateRef,
                            placement: i
                        }), this._state.isOpenChange.emit(!0)
                    }).catch()
                }
            }
            hide() {
                this.isOpen && (this._showInline ? (this.removeShowClass(), this.removeDropupStyles(), this._isInlineOpen = !1, this.onHidden.emit(!0)) : this._dropdown.hide(), this._state.isOpenChange.emit(!1))
            }
            toggle(n) {
                return this.isOpen || !n ? this.hide() : this.show()
            }
            _contains(n) {
                return this._elementRef.nativeElement.contains(n.target) || this._dropdown.instance && this._dropdown.instance._contains(n.target)
            }
            navigationClick(n) {
                let r = this._elementRef.nativeElement.querySelector(".dropdown-menu");
                if (!r) return;
                let i = this._elementRef.nativeElement.ownerDocument.activeElement,
                    s = r.querySelectorAll(".dropdown-item");
                switch (n.keyCode) {
                    case 38:
                        this._state.counts > 0 && s[--this._state.counts].focus();
                        break;
                    case 40:
                        this._state.counts + 1 < s.length && (i.classList !== s[this._state.counts].classList ? s[this._state.counts].focus() : s[++this._state.counts].focus());
                        break;
                    default:
                }
                n.preventDefault()
            }
            ngOnDestroy() {
                for (let n of this._subscriptions) n.unsubscribe();
                this._dropdown.dispose()
            }
            addBs4Polyfills() {
                this.addShowClass(), this.checkRightAlignment(), this.addDropupStyles()
            }
            playAnimation() {
                this._state.isAnimated && this._inlinedMenu && setTimeout(() => {
                    this._inlinedMenu && this._factoryDropDownAnimation.create(this._inlinedMenu.rootNodes[0]).play()
                })
            }
            addShowClass() {
                this._inlinedMenu && this._inlinedMenu.rootNodes[0] && this._renderer.addClass(this._inlinedMenu.rootNodes[0], "show")
            }
            removeShowClass() {
                this._inlinedMenu && this._inlinedMenu.rootNodes[0] && this._renderer.removeClass(this._inlinedMenu.rootNodes[0], "show")
            }
            checkRightAlignment() {
                if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
                    let n = this._inlinedMenu.rootNodes[0].classList.contains("dropdown-menu-right") || this._inlinedMenu.rootNodes[0].classList.contains("dropdown-menu-end");
                    this._renderer.setStyle(this._inlinedMenu.rootNodes[0], "left", n ? "auto" : "0"), this._renderer.setStyle(this._inlinedMenu.rootNodes[0], "right", n ? "0" : "auto")
                }
            }
            addDropupStyles() {
                this._inlinedMenu && this._inlinedMenu.rootNodes[0] && (this._renderer.setStyle(this._inlinedMenu.rootNodes[0], "top", this.dropup ? "auto" : "100%"), this._renderer.setStyle(this._inlinedMenu.rootNodes[0], "transform", this.dropup ? "translateY(-101%)" : "translateY(0)"), this._renderer.setStyle(this._inlinedMenu.rootNodes[0], "bottom", "auto"))
            }
            removeDropupStyles() {
                this._inlinedMenu && this._inlinedMenu.rootNodes[0] && (this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], "top"), this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], "transform"), this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], "bottom"))
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(O(je), O(Wt), O(Un), O($f), O(Rs), O(XW), O(Cd))
        }, t.\u0275dir = et({
            type: t,
            selectors: [
                ["", "bsDropdown", ""],
                ["", "dropdown", ""]
            ],
            hostVars: 6,
            hostBindings: function(n, r) {
                n & 1 && we("keydown.arrowDown", function(s) {
                    return r.navigationClick(s)
                })("keydown.arrowUp", function(s) {
                    return r.navigationClick(s)
                }), n & 2 && wo("dropup", r.dropup)("open", r.isOpen)("show", r.isOpen)
            },
            inputs: {
                placement: "placement",
                triggers: "triggers",
                container: "container",
                dropup: "dropup",
                autoClose: "autoClose",
                isAnimated: "isAnimated",
                insideClick: "insideClick",
                isDisabled: "isDisabled",
                isOpen: "isOpen"
            },
            outputs: {
                isOpenChange: "isOpenChange",
                onShown: "onShown",
                onHidden: "onHidden"
            },
            exportAs: ["bs-dropdown"],
            features: [Ji([Rs])]
        }), t
    })(),
    iA = (() => {
        class t {
            constructor(n, r, i) {
                n.resolveDropdownMenu({
                    templateRef: i,
                    viewContainer: r
                })
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(O(Rs), O(Un), O(vn))
        }, t.\u0275dir = et({
            type: t,
            selectors: [
                ["", "bsDropdownMenu", ""],
                ["", "dropdownMenu", ""]
            ],
            exportAs: ["bs-dropdown-menu"]
        }), t
    })(),
    sA = (() => {
        class t {
            constructor(n, r, i, s, o) {
                this._changeDetectorRef = n, this._dropdown = r, this._element = i, this._renderer = s, this._state = o, this.isOpen = !1, this._subscriptions = [], this._subscriptions.push(this._state.isOpenChange.subscribe(a => {
                    this.isOpen = a, a ? (this._documentClickListener = this._renderer.listen("document", "click", c => {
                        this._state.autoClose && c.button !== 2 && !this._element.nativeElement.contains(c.target) && !(this._state.insideClick && this._dropdown._contains(c)) && (this._state.toggleClick.emit(!1), this._changeDetectorRef.detectChanges())
                    }), this._escKeyUpListener = this._renderer.listen(this._element.nativeElement, "keyup.esc", () => {
                        this._state.autoClose && (this._state.toggleClick.emit(!1), this._changeDetectorRef.detectChanges())
                    })) : (this._documentClickListener && this._documentClickListener(), this._escKeyUpListener && this._escKeyUpListener())
                })), this._subscriptions.push(this._state.isDisabledChange.subscribe(a => this.isDisabled = a || void 0))
            }
            onClick(n) {
                this._state.stopOnClickPropagation && n.stopPropagation(), !this.isDisabled && this._state.toggleClick.emit(!0)
            }
            ngOnDestroy() {
                this._documentClickListener && this._documentClickListener(), this._escKeyUpListener && this._escKeyUpListener();
                for (let n of this._subscriptions) n.unsubscribe()
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)(O(xt), O(G0), O(je), O(Wt), O(Rs))
        }, t.\u0275dir = et({
            type: t,
            selectors: [
                ["", "bsDropdownToggle", ""],
                ["", "dropdownToggle", ""]
            ],
            hostVars: 3,
            hostBindings: function(n, r) {
                n & 1 && we("click", function(s) {
                    return r.onClick(s)
                }), n & 2 && vo("aria-haspopup", !0)("disabled", r.isDisabled)("aria-expanded", r.isOpen)
            },
            exportAs: ["bs-dropdown-toggle"]
        }), t
    })(),
    oA = (() => {
        class t {
            static forRoot() {
                return {
                    ngModule: t,
                    providers: [$f, zf, Rs]
                }
            }
        }
        return t.\u0275fac = function(n) {
            return new(n || t)
        }, t.\u0275mod = xe({
            type: t
        }), t.\u0275inj = Te({
            imports: [ci]
        }), t
    })();
var rH = ["navigation"],
    aA = t => ({
        scrolled: t
    }),
    iH = () => ({
        "width.px": "170",
        "height.px": 33
    }),
    sH = () => ({
        "max-width.px": 130,
        "height.px": 33
    }),
    oH = () => ({
        "width.px": 32,
        "height.px": 32
    }),
    aH = t => ({
        open: t
    });

function cH(t, e) {
    if (t & 1) {
        let n = Xt();
        P(0, "li", 24), we("click", function() {
            let i = rt(n).$implicit,
                s = Ne(3);
            return it(s.changeLanguage(i.value))
        }), fe(1, "img", 25), P(2, "span", 26), re(3), B()()
    }
    if (t & 2) {
        let n = e.$implicit;
        ae(), oi("src", "./assets/images/flags/", n.flag, ".svg", ni), ae(2), jn(n.name)
    }
}

function lH(t, e) {
    if (t & 1 && (P(0, "ul", 22), _t(1, cH, 4, 3, "li", 23), B()), t & 2) {
        let n = Ne(2);
        ae(), Ke("ngForOf", n.languagesList)
    }
}

function uH(t, e) {
    if (t & 1) {
        let n = Xt();
        P(0, "div", 3)(1, "div", 4)(2, "div", 5)(3, "div", 6, 0), we("click", function(i) {
            rt(n);
            let s = Ne();
            return s.navigateToSection("home"), it(s.addActive(i))
        }), fe(5, "svg-icon", 7), B(), P(6, "div", 8)(7, "a", 9), we("click", function(i) {
            rt(n);
            let s = Ne();
            return s.navigateToSection("about"), it(s.addActive(i))
        }), re(8, "about"), B(), P(9, "a", 9), we("click", function(i) {
            rt(n);
            let s = Ne();
            return s.navigateToSection("how_to"), it(s.addActive(i))
        }), re(10, "how_to"), B()(), P(11, "div", 10)(12, "div", 11)(13, "div", 12), fe(14, "img", 13), P(15, "span", 14), re(16), B(), fe(17, "svg-icon", 15), B(), _t(18, lH, 2, 1, "ul", 16), B(), P(19, "div", 17)(20, "a", 18), fe(21, "img", 19), B(), P(22, "a", 20), fe(23, "img", 21), B()()()()()()
    }
    if (t & 2) {
        let n = Ne();
        Ke("ngClass", Ar(7, aA, n.isScrolled)), ae(5), Ke("svgStyle", Xu(9, iH)), ae(2), si("title", "about"), ae(2), si("title", "how_to"), ae(5), oi("src", "./assets/images/flags/", n.selectedLanguage == null ? null : n.selectedLanguage.flag, ".svg", ni), ae(2), jn(n.selectedLanguage == null ? null : n.selectedLanguage.value)
    }
}

function dH(t, e) {
    if (t & 1) {
        let n = Xt();
        P(0, "li", 24), we("click", function() {
            let i = rt(n).$implicit,
                s = Ne(4);
            return it(s.changeLanguage(i.value))
        }), fe(1, "img", 25), P(2, "span", 26), re(3), B()()
    }
    if (t & 2) {
        let n = e.$implicit;
        ae(), oi("src", "./assets/images/flags/", n.flag, ".svg", ni), ae(2), jn(n.name)
    }
}

function hH(t, e) {
    if (t & 1 && (P(0, "ul", 44), _t(1, dH, 4, 3, "li", 23), B()), t & 2) {
        let n = Ne(3);
        ae(), Ke("ngForOf", n.languagesList)
    }
}

function fH(t, e) {
    if (t & 1) {
        let n = Xt();
        P(0, "div", 35)(1, "div", 36)(2, "div", 37)(3, "a", 38), we("click", function(i) {
            rt(n);
            let s = Ne(2);
            return s.navigateToSection("about"), s.addActive(i), s.showMenu = !1, it(s.openMenu = !1)
        }), re(4, "about"), B(), P(5, "a", 38), we("click", function(i) {
            rt(n);
            let s = Ne(2);
            return s.navigateToSection("how_to"), s.addActive(i), s.showMenu = !1, it(s.openMenu = !1)
        }), re(6, "how_to"), B(), P(7, "div", 39)(8, "div", 12), fe(9, "img", 13), P(10, "span", 14), re(11), B(), fe(12, "svg-icon", 15), B(), _t(13, hH, 2, 1, "ul", 40), B(), P(14, "div", 41)(15, "a", 42), fe(16, "img", 19), B(), P(17, "a", 43), fe(18, "img", 21), B()()()()()
    }
    if (t & 2) {
        let n = Ne(2);
        ae(), Ke("ngClass", Ar(6, aH, n.openMenu)), ae(2), si("title", "about"), ae(2), si("title", "how_to"), ae(4), oi("src", "./assets/images/flags/", n.selectedLanguage == null ? null : n.selectedLanguage.flag, ".svg", ni), ae(2), jn(n.selectedLanguage == null ? null : n.selectedLanguage.value)
    }
}

function pH(t, e) {
    if (t & 1) {
        let n = Xt();
        P(0, "div", 27)(1, "div", 28)(2, "div", 29)(3, "div", 30, 0), we("click", function(i) {
            rt(n);
            let s = Ne();
            return s.navigateToSection("home"), it(s.addActive(i))
        }), fe(5, "svg-icon", 31), B(), P(6, "div", 32), we("click", function() {
            rt(n);
            let i = Ne();
            return it(i.openCloseMenu())
        }), fe(7, "svg-icon", 33), B()(), _t(8, fH, 19, 8, "div", 34), B()()
    }
    if (t & 2) {
        let n = Ne();
        Ke("ngClass", Ar(6, aA, n.isScrolled)), ae(5), Ke("svgStyle", Xu(8, sH)), ae(2), oi("src", "./assets/images/svg-icons/", n.showMenu ? "burger-close" : "burger-icon", ".svg"), Ke("svgStyle", Xu(9, oH)), ae(), Ke("ngIf", n.showMenu)
    }
}
var cA = (() => {
    let e = class e {
        constructor(r, i, s, o) {
            this.location = r, this.eventService = i, this.translate = s, this.route = o, this.isScrolled = !1, this.showMenu = !1, this.openMenu = !1, this.hashKey = "", this.languagesList = Pv, this.isShimmer = !0, this.isMobile = window.matchMedia && window.matchMedia("(max-device-width: 575px)").matches || screen.width <= 575, this.navigations = [{
                routeName: "how",
                navName: "nav_how"
            }], this.windowSize = window.screen.width, this.eventService.getLang().subscribe(a => {
                this.currentLanguage = a || "en", this.selectedLanguage = this.languagesList.filter(c => c.value === this.currentLanguage)[0]
            }), this.selectedLanguage = this.languagesList.filter(a => a.value === this.currentLanguage)[0], setTimeout(() => this.isShimmer = !1, 2e3)
        }
        ngOnInit() {
            this.currentLanguage || (this.currentLanguage = F0, this.selectedLanguage = this.languagesList.filter(r => r.value === this.currentLanguage)[0])
        }
        checkScroll() {
            this.isScrolled = window.pageYOffset >= 50
        }
        onResize(r) {
            this.windowSize = r.target.innerWidth
        }
        ngAfterViewInit() {
            window.location.hash && setTimeout(() => {
                this.hashKey = window.location.hash.substring(1, window.location.hash.length), this.navigateToSection(this.hashKey), this.addActive(this.navigation.nativeElement)
            }, this.isShimmer ? 2500 : 500)
        }
        changeLanguage(r) {
            this.currentLanguage = r, this.translate.use(this.currentLanguage), this.eventService.setLang(this.currentLanguage), this.selectedLanguage = this.languagesList.filter(i => i.value === this.currentLanguage)[0], this.replaceURL()
        }
        replaceURL() {
            let r = this.location.path().split("/");
            r.shift(), r.splice(0, 1, this.currentLanguage);
            let i = r.join("/");
            window.location.hash = this.hashKey, this.location.replaceState("/" + i), console.log("current_url =", r), console.log("new_url =", i, this.hashKey)
        }
        navigateToSection(r) {
            this.hashKey = r, r && (window.location.hash = r, window.location.pathname = "/" + this.currentLanguage)
        }
        addActive(r) {
            (r.currentTarget ? r.currentTarget : r).parentNode.querySelectorAll("a").forEach(o => {
                o === r.target || o.title === this.hashKey ? o.classList.add("active") : o.classList.remove("active")
            })
        }
        openCloseMenu() {
            this.showMenu ? (this.openMenu = !this.openMenu, setTimeout(() => this.showMenu = !this.showMenu, 200)) : (this.showMenu = !this.showMenu, setTimeout(() => this.openMenu = !this.openMenu, 200))
        }
    };
    e.\u0275fac = function(i) {
        return new(i || e)(O(ai), O(lr), O(rr), O(or))
    }, e.\u0275cmp = He({
        type: e,
        selectors: [
            ["app-header"]
        ],
        viewQuery: function(i, s) {
            if (i & 1 && LE(rH, 5), i & 2) {
                let o;
                qu(o = Ku()) && (s.navigation = o.first)
            }
        },
        hostBindings: function(i, s) {
            i & 1 && we("resize", function(a) {
                return s.onResize(a)
            }, !1, Fa)("scroll", function(a) {
                return s.checkScroll(a)
            }, !1, Fa)
        },
        decls: 2,
        vars: 2,
        consts: [
            ["navigation", ""],
            ["class", "header desktop d-flex justify-content-between align-items-center", 3, "ngClass", 4, "ngIf"],
            ["class", "header mobile", 3, "ngClass", 4, "ngIf"],
            [1, "header", "desktop", "d-flex", "justify-content-between", "align-items-center", 3, "ngClass"],
            [1, "w-100"],
            [1, "header-wrap", "d-flex", "justify-content-between", "align-items-center", "w-100"],
            [1, "cursor-pointer", 3, "click"],
            ["src", "./assets/images/svg-icons/logo.svg", 3, "svgStyle"],
            [1, "d-flex", "justify-content-center", "align-items-center"],
            ["href", "javascript:void(0)", "translate", "", 1, "text-dark", "mx-3", "px-3", "text-center", 3, "click", "title"],
            [1, "d-flex", "align-items-center"],
            ["dropdown", "", 1, "btn-group", "language", "ms-3"],
            ["dropdownToggle", "", "type", "button", 1, "dropdown-toggle", "amountType", "d-flex", "align-items-center"],
            ["alt", "", 1, "flag-icon", 3, "src"],
            [1, "ms-1", "font-14", "text-uppercase", "fw-bold", "text-dark"],
            ["src", "./assets/images/svg-icons/angle-down.svg", 1, "dropdown"],
            ["class", "dropdown-menu dropdown-menu-right bg-white", "role", "menu", 4, "dropdownMenu"],
            [1, "social-icons", "d-flex", "align-items-center"],
            ["href", "https://twitter.com/Sealana_Token", "target", "_blank", 1, "mx-2"],
            ["src", "/assets/images/svg-icons/x.png", "alt", ""],
            ["href", "https://t.me/Sealana_Token", "target", "_blank", 1, "mx-2"],
            ["src", "/assets/images/svg-icons/telegram.svg", "alt", ""],
            ["role", "menu", 1, "dropdown-menu", "dropdown-menu-right", "bg-white"],
            ["class", "p-2 cursor-pointer", "role", "menuitem", 3, "click", 4, "ngFor", "ngForOf"],
            ["role", "menuitem", 1, "p-2", "cursor-pointer", 3, "click"],
            ["alt", "", 3, "src"],
            [1, "text-dark", "fw-bold"],
            [1, "header", "mobile", 3, "ngClass"],
            [1, "header-wrap", "w-100", "d-flex", "justify-content-be", "align-items-center"],
            [1, "header-wrap", "w-100", "d-flex", "justify-content-between", "align-items-center"],
            [1, "cursor-pointer", "flex-grow-1", 3, "click"],
            ["src", "./assets/images/svg-icons/logo.svg", 1, "mobile-logo", 3, "svgStyle"],
            [1, "me-2", 3, "click"],
            [3, "src", "svgStyle"],
            ["class", "menu-overlay", 4, "ngIf"],
            [1, "menu-overlay"],
            [1, "sub-menu", "d-flex", "flex-column", "justify-content-start", "align-items-center", "pull-left", 3, "ngClass"],
            [1, "d-flex", "flex-column", "justify-content-start", "align-items-center", "h-100"],
            ["href", "javascript:void(0)", "translate", "", 1, "text-dark", "text-center", 3, "click", "title"],
            ["dropdown", "", 1, "btn-group", "language", "mx-2", "mt-3"],
            ["class", "dropdown-menu bg-white", "role", "menu", 4, "dropdownMenu"],
            [1, "social-icons", "d-flex", "align-items-center", "mt-3"],
            ["href", "https://twitter.com/Sealana_Token", "target", "_blank", 1, "mx-1", "border-0"],
            ["href", "https://t.me/Sealana_Token", "target", "_blank", 1, "mx-1", "border-0"],
            ["role", "menu", 1, "dropdown-menu", "bg-white"]
        ],
        template: function(i, s) {
            i & 1 && _t(0, uH, 24, 10, "div", 1)(1, pH, 9, 10, "div", 2), i & 2 && (Ke("ngIf", s.windowSize > 1024), ae(), Ke("ngIf", s.windowSize <= 1024))
        },
        dependencies: [Do, cC, lC, Vx, iA, sA, G0, ir],
        styles: [".header[_ngcontent-%COMP%]{position:fixed;left:0;top:0;width:100%;padding:0 25px;background:#a4cbc8;transition:all .3s linear;z-index:5;color:#fff}@media screen and (max-width: 768px){.header[_ngcontent-%COMP%]{padding:0}.header[_ngcontent-%COMP%]   .connect[_ngcontent-%COMP%]{padding:12px;line-height:1;border:1px solid white}}.header[_ngcontent-%COMP%]   .header-wrap[_ngcontent-%COMP%]{border-radius:20px;padding:14px 30px;border:1px solid;border-image-source:radial-gradient(121.49% 277.08% at 0% 0%,rgba(255,255,255,.44) 0%,rgba(255,255,255,.05) 100%);-webkit-backdrop-filter:blur(21px);backdrop-filter:blur(21px)}@media screen and (max-width: 768px){.header[_ngcontent-%COMP%]   .header-wrap[_ngcontent-%COMP%]{border-radius:0;padding:8px 15px}}.header[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{margin:0 15px;padding:10px 0;color:#000;cursor:pointer;text-decoration:none;letter-spacing:.02em;text-transform:uppercase;font-weight:600;font-size:24px}.header[_ngcontent-%COMP%]   a.active[_ngcontent-%COMP%], .header[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{color:purple}@media only screen and (min-width: 577px) and (max-width: 1024px){.header[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{padding:10px}}.header[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]{padding:8px 10px;margin:0;border-radius:32px;font-size:16px;text-decoration:none;letter-spacing:.02em;text-transform:capitalize;font-weight:400}.header[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]   .dropdown-toggle[_ngcontent-%COMP%]{width:100%}.header[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]   .dropdown-toggle[_ngcontent-%COMP%]:after{position:absolute;right:12px;opacity:0}.header[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]   .dropdown-toggle[_ngcontent-%COMP%]   .flag-icon[_ngcontent-%COMP%]{border-radius:50%;overflow:hidden;margin-right:3px;min-width:20px;width:26px;height:26px;object-fit:cover}.header[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]   .dropdown-toggle[_ngcontent-%COMP%]   .dropdown[_ngcontent-%COMP%]{cursor:pointer}.header[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]{width:100%;max-height:250px;overflow-y:auto}.header[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{display:flex;align-items:center;font-size:20px;cursor:pointer}.header[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]   .dropdown-menu[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{border-radius:50%;border:1px solid grey;overflow:hidden;margin-right:10px;min-width:20px;height:20px;width:20px;object-fit:cover}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]{background:#fffc;position:fixed;width:100%;height:calc(100vh - 67px);-webkit-backdrop-filter:blur(50px);backdrop-filter:blur(50px);top:67px;left:0;display:flex;justify-content:flex-end}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]{width:60%;min-width:320px;max-width:320px;height:100%;background:linear-gradient(112.62deg,#a4cbc8b3 -10.65%,#a4cbc8 104.47%);border-image-source:radial-gradient(121.49% 277.08% at 0% 0%,rgba(255,255,255,.44) 0%,rgba(255,255,255,.05) 100%);padding:20px;position:relative;transition:right .5s cubic-bezier(.075,.82,.165,1);right:-320px}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu.open[_ngcontent-%COMP%]{right:0}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{width:100%;margin-bottom:20px;padding:5px 10px;cursor:pointer;color:#000;border-bottom:1px solid white;text-decoration:none;letter-spacing:.02em;text-transform:uppercase;font-weight:400}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   a.active[_ngcontent-%COMP%], .header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover{background:#fff;color:purple}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]{width:100%!important;padding:10px;margin:0;border:1px solid white;border-radius:0;text-decoration:none;letter-spacing:.02em;text-transform:uppercase;font-weight:400}.header[_ngcontent-%COMP%]   .menu-overlay[_ngcontent-%COMP%]   .sub-menu[_ngcontent-%COMP%]   .language[_ngcontent-%COMP%]   .dropdown-toggle[_ngcontent-%COMP%]:after{position:absolute;right:12px}@media only screen and (max-width: 390px){.header[_ngcontent-%COMP%]   .mobile-logo[_ngcontent-%COMP%]{width:120px!important}}@media only screen and (min-width: 577px) and (max-width: 768px){.header[_ngcontent-%COMP%]{padding:15px}}.social-icons[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:30px;height:auto}@media only screen and (max-width: 768px){.social-icons[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:50px}}"]
    });
    let t = e;
    return t
})();
var lA = (() => {
    let e = class e {};
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275cmp = He({
        type: e,
        selectors: [
            ["app-about"]
        ],
        decls: 13,
        vars: 0,
        consts: [
            ["id", "about", 1, "about"],
            [1, "container"],
            [1, "wrapper"],
            ["src", "/assets/images/about-thread.svg", 1, "img-fluid", "about-thread", "d-block"],
            [1, "about-wrapper"],
            [1, "about-frame"],
            [1, "about-info"],
            [1, "title-wrapper"],
            ["translate", "", 1, "mb-0"],
            ["src", "/assets/images/svg-icons/logo.svg", 1, "img-fluid", "mx-auto", "d-block", "mb-4"],
            ["translate", ""]
        ],
        template: function(i, s) {
            i & 1 && (P(0, "section", 0)(1, "div", 1)(2, "div", 2), fe(3, "img", 3), P(4, "div", 4)(5, "div", 5)(6, "div", 6)(7, "div", 7)(8, "h2", 8), re(9, "about_title"), B(), fe(10, "img", 9), B(), P(11, "p", 10), re(12, "about_desc"), B()()()()()()())
        },
        dependencies: [ir],
        styles: [".about[_ngcontent-%COMP%]{background:#e0dcc2 url(/assets/images/about.png) no-repeat 50% 50%/100%;padding:140px 0 250px}@media screen and (max-width: 1508px){.about[_ngcontent-%COMP%]{padding:70px 0 140px}}@media screen and (max-width: 768px){.about[_ngcontent-%COMP%]{background:#e0dcc2;padding:60px 0}}.about[_ngcontent-%COMP%]   .about-wrapper[_ngcontent-%COMP%]{box-shadow:-7px 9px #00000040;border-width:4px;border-style:solid;border-color:#373737}.about[_ngcontent-%COMP%]   .about-wrapper[_ngcontent-%COMP%]   .about-frame[_ngcontent-%COMP%]{border:10px solid #292929}.about[_ngcontent-%COMP%]   .about-wrapper[_ngcontent-%COMP%]   .about-frame[_ngcontent-%COMP%]   .about-info[_ngcontent-%COMP%]{border-width:5px;border-style:solid;border-color:#373737;background-color:#fff;font-size:28px;padding:50px 13px}.about[_ngcontent-%COMP%]   .about-wrapper[_ngcontent-%COMP%]   .about-frame[_ngcontent-%COMP%]   .about-info[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{line-height:0}.about[_ngcontent-%COMP%]   .about-wrapper[_ngcontent-%COMP%]   .about-frame[_ngcontent-%COMP%]   .about-info[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{font-size:40px;text-align:center}.about[_ngcontent-%COMP%]   .about-wrapper[_ngcontent-%COMP%]   .about-frame[_ngcontent-%COMP%]   .about-info[_ngcontent-%COMP%]   .title-wrapper[_ngcontent-%COMP%]{max-width:350px;margin:0 auto}@media screen and (max-width: 768px){.about[_ngcontent-%COMP%]   .about-wrapper[_ngcontent-%COMP%]   .about-frame[_ngcontent-%COMP%]   .about-info[_ngcontent-%COMP%]   .title-wrapper[_ngcontent-%COMP%]{max-width:250px}}.wrapper[_ngcontent-%COMP%]{max-width:1050px;margin:0 auto;transform:rotate(-2.75deg)}@media screen and (max-width: 768px){.wrapper[_ngcontent-%COMP%]{transform:rotate(0)}}.about-thread[_ngcontent-%COMP%]{position:relative;bottom:-15px;display:block;margin:0 auto}"]
    });
    let t = e;
    return t
})();
var uA = (() => {
    let e = class e {};
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275cmp = He({
        type: e,
        selectors: [
            ["app-how-to-buy"]
        ],
        decls: 14,
        vars: 0,
        consts: [
            ["id", "how_to", 1, "how-to-buy"],
            [1, "container"],
            [1, "row", "align-items-center"],
            [1, "col-lg-6"],
            ["translate", ""],
            ["translate", "", 1, "mb-4"],
            ["src", "/assets/images/how-to-img.png", 1, "img-fluid", "d-block"],
            ["src", "/assets/images/how-to-mob.png", 1, "img-fluid", "d-block", "d-md-none"],
            ["src", "/assets/images/how-to-bottom.png", 1, "img-fluid", "how-to-bottom", "d-block"]
        ],
        template: function(i, s) {
            i & 1 && (P(0, "section", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h3", 4), re(5, "how_to_title"), B(), P(6, "p", 5), re(7, "how_to_para1"), B(), P(8, "p", 4), re(9, "how_to_para2"), B()(), P(10, "div", 3), fe(11, "img", 6)(12, "img", 7), B()()(), fe(13, "img", 8), B())
        },
        dependencies: [ir],
        styles: [".how-to-buy[_ngcontent-%COMP%]{background:#2c3434 url(/assets/images/how-to-bg.svg) no-repeat 0 0/cover;padding:100px 0;position:relative}@media screen and (max-width: 768px){.how-to-buy[_ngcontent-%COMP%]{padding:100px 0 0}}.how-to-buy[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%]{color:#fff;font-size:50px}.how-to-buy[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:#d0d0d0;line-height:50px;font-size:40px;max-width:593px;word-break:break-word}.how-to-buy[_ngcontent-%COMP%]   .how-to-bottom[_ngcontent-%COMP%]{position:absolute;bottom:0;left:80px}@media screen and (max-width: 768px){.how-to-buy[_ngcontent-%COMP%]   .how-to-bottom[_ngcontent-%COMP%]{position:relative;left:0;max-width:330px}}"]
    });
    let t = e;
    return t
})();
var vH = t => ({
        "foreign-lang": t
    }),
    dA = (() => {
        let e = class e {
            constructor(r) {
                this.eventService = r, this.lang = localStorage.getItem("currentlang"), this.slideOption = {
                    loop: !0,
                    autoplay: !1,
                    mouseDrag: !0,
                    touchDrag: !0,
                    dots: !1,
                    nav: !1,
                    center: !1,
                    margin: 15,
                    responsive: {
                        0: {
                            items: 1.2
                        },
                        400: {
                            items: 1.2
                        },
                        768: {
                            items: 1
                        }
                    }
                }, this.eventService.getLang().subscribe(i => {
                    this.lang = i || "en"
                })
            }
            langs() {
                return ["bg", "cz", "de", "el", "hu", "jp", "kr", "pl", "ru", "sk", "vn", "id", "pt", "fr", "tr", "it", "ro"].includes(this.lang)
            }
        };
        e.\u0275fac = function(i) {
            return new(i || e)(O(lr))
        }, e.\u0275cmp = He({
            type: e,
            selectors: [
                ["app-home"]
            ],
            decls: 11,
            vars: 3,
            consts: [
                ["id", "home", 1, "containerItem", 3, "ngClass"],
                ["src", "/assets/images/svg-icons/logo.svg", "alt", "", 1, "img-fuid", "mx-auto", "d-block", "d-md-none", "mob-logo"],
                [1, "content"],
                [1, "container"],
                [1, "row", "justify-content-end"],
                [1, "col-lg-5"],
                [1, "text"]
            ],
            template: function(i, s) {
                i & 1 && (fe(0, "app-header"), P(1, "div", 0), fe(2, "img", 1), P(3, "div", 2)(4, "div", 3)(5, "div", 4)(6, "div", 5)(7, "div", 6), fe(8, "app-buy-widget"), B()()()()()(), fe(9, "app-about")(10, "app-how-to-buy")), i & 2 && (ae(), Ke("ngClass", Ar(1, vH, s.langs())))
            },
            dependencies: [Do, kx, cA, lA, uA],
            styles: [".containerItem[_ngcontent-%COMP%]{background:url(/assets/images/bg_1.svg) no-repeat 0 0/cover!important;width:100%;height:100%;min-width:98vw;overflow:hidden;min-height:100vh;font-family:EastSeaDokdo;padding-top:140px;margin-top:40px}@media screen and (max-width: 768px){.containerItem[_ngcontent-%COMP%]{background:#2c3434 url(/assets/images/banner_mob.svg) no-repeat 50% 0/cover!important;padding-top:50px;min-height:1000px}}.mob-logo[_ngcontent-%COMP%]{padding-bottom:50px}.content[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}.content[_ngcontent-%COMP%]   .frame-bg[_ngcontent-%COMP%]{z-index:2;width:100%;position:relative}@media screen and (max-width: 1440px){.content[_ngcontent-%COMP%]{justify-content:flex-start}.content[_ngcontent-%COMP%]   .frame-bg[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]{right:5%}}@media screen and (max-width: 768px){.content[_ngcontent-%COMP%]{flex-direction:column-reverse;margin-top:-40px}.content[_ngcontent-%COMP%]   .frame-bg[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]{top:54px;left:80px;max-width:260px}}@media screen and (max-width: 768px) and (max-width: 376px){.content[_ngcontent-%COMP%]   .frame-bg[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]{left:67px}}"]
        });
        let t = e;
        return t
    })();
var wH = [{
        path: ":lang",
        component: OM,
        children: [{
            path: "",
            component: dA
        }]
    }, {
        path: "**",
        redirectTo: "/en",
        pathMatch: "full"
    }],
    hA = (() => {
        let e = class e {};
        e.\u0275fac = function(i) {
            return new(i || e)
        }, e.\u0275mod = xe({
            type: e
        }), e.\u0275inj = Te({
            imports: [Fv.forRoot(wH, {
                anchorScrolling: "enabled"
            }), eh, Fv]
        });
        let t = e;
        return t
    })();
var _H = (() => {
    class t {
        errorHandler;
        constructor(n) {
            this.errorHandler = n
        }
        log(n, ...r) {
            cd() && console.log(n, ...r)
        }
        error(n) {
            this.errorHandler.handleError(n)
        }
        warn(n, ...r) {
            console.warn(n, ...r)
        }
        static\ u0275fac = function(r) {
            return new(r || t)(C(yn))
        };
        static\ u0275prov = I({
            token: t,
            factory: t.\u0275fac
        })
    }
    return t
})();
var fA = new R("WindowToken"),
    ul = class {
        get nativeWindow() {
            throw new Error("Not implemented.")
        }
    },
    bH = (() => {
        class t extends ul {
            constructor() {
                super()
            }
            get nativeWindow() {
                return window
            }
            static\ u0275fac = function(r) {
                return new(r || t)
            };
            static\ u0275prov = I({
                token: t,
                factory: t.\u0275fac
            })
        }
        return t
    })();

function DH(t, e) {
    return ts(e) ? t.nativeWindow : {
        setTimeout: (r, i) => {},
        clearTimeout: r => {}
    }
}
var EH = {
        provide: ul,
        useClass: bH
    },
    CH = {
        provide: fA,
        useFactory: DH,
        deps: [ul, st]
    },
    SH = [EH, CH],
    MH = new R("DocumentToken"),
    dl = class {
        get nativeDocument() {
            throw new Error("Not implemented.")
        }
    },
    IH = (() => {
        class t extends dl {
            constructor() {
                super()
            }
            get nativeDocument() {
                return document
            }
            static\ u0275fac = function(r) {
                return new(r || t)
            };
            static\ u0275prov = I({
                token: t,
                factory: t.\u0275fac
            })
        }
        return t
    })();

function TH(t, e) {
    return ts(e) ? t.nativeDocument : {
        hidden: !1,
        visibilityState: "visible"
    }
}
var xH = {
        provide: dl,
        useClass: IH
    },
    AH = {
        provide: MH,
        useFactory: TH,
        deps: [dl, st]
    },
    NH = [xH, AH];
var RH = (() => {
    class t {
        resizeObservable$;
        get onResize$() {
            return this.resizeObservable$
        }
        constructor(n, r) {
            this.resizeObservable$ = ts(r) ? qn(n, "resize") : new Me().asObservable()
        }
        static\ u0275fac = function(r) {
            return new(r || t)(C(fA), C(st))
        };
        static\ u0275prov = I({
            token: t,
            factory: t.\u0275fac
        })
    }
    return t
})();
var pA = (() => {
    class t {
        static\ u0275fac = function(r) {
            return new(r || t)
        };
        static\ u0275mod = xe({
            type: t
        });
        static\ u0275inj = Te({
            providers: [SH, RH, NH, _H],
            imports: [ci]
        })
    }
    return t
})();
var gA = (() => {
    let e = class e {};
    e.\u0275fac = function(i) {
        return new(i || e)
    }, e.\u0275mod = xe({
        type: e,
        bootstrap: [Px]
    }), e.\u0275inj = Te({
        imports: [uS, hA, pA, eh, WS, Ux.forRoot(), oA.forRoot(), bC, Ox.forRoot(), mS.forRoot({
            loader: {
                provide: hi,
                useFactory: OH,
                deps: [rs]
            }
        })]
    });
    let t = e;
    return t
})();

function OH(t) {
    return new Wd(t, "./assets/i18n/", ".json")
}
xC().bootstrapModule(gA).catch(t => console.error(t));